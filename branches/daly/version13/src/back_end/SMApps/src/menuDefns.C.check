// Copyright (C) 1995 The New York Group Theory Cooperative
// See magnus/doc/COPYRIGHT for the full notice.
//
// Contents: Implementation of ObjectSmith methods outputCheckinMenuDefns,
//           outputToolsMenuDefns
//
// Principal Author: Dmitry Bormotov
//
// Status: Always being added to.
//
// Revision History:
//
// * 1/96 Dmitry B. completely rewrote almost all tools menus.
//

#include "ObjectSmith.h"

/////////////////////////////////////////////////////////////////////////
// Include the header for everything that can be made by choosing a
// menu item here:
//

#include "SMFPGroup.h"
#include "SMWord.h"
#include "SMEquation.h"
#include "SMEnumerator.h"
#include "SMHomomorphism.h"
#include "SMSetOfWords.h"
#include "SMEqSystem.h"
#include "SMPermutation.h"

#include "fastProblems.h"
#include "WordProblem.h"
#include "KBModule.h"
#include "AbelianProblems.h"
#include "NilpotentQuotients.h"
#include "QuadEquationSolver.h"
#include "HomologyProblem.h"
#include "FreeProblems.h"
#include "OrderProblem.h"
#include "ConjugacyProblem.h"
#include "NilpotentProblems.h"
//#include "FNGroupProblems.h"
#include "FreeIsPartOfBasisProblem.h"
#include "IsTrivialProblem.h"
#include "IsFreeProblem.h"
#include "IsFiniteProblem.h"
#include "ExtendToHomProblem.h"
#include "IsAbelianProblem.h"
#include "IsNilpotentProblem.h"
#include "IsEltCentral.h"
#include "AreEltsEqual.h"
#include "OrderOfElt.h"
#include "SubgroupProblems.h"
#include "HNNProblems.h" 
#include "OneRelatorProblems.h"
#include "TTProblem.h"
#include "ToddCoxeter.h"
#include "GAEquations.h"
#include "ACConjecture.h"
#include "WhiteheadMinimal.h"
#include "KernelPresentation.h"
#include "PresentationProblems.h"
#include "GAConjProblemForORGroup.h"
#include "RankOfSubgroup.h"

// Lists and Enumerators

#include "SGREnumerator.h"
#include "WEnumerator.h"
#include "REnumerator.h"
#include "AutoEnumerator.h"
#include "SGREnumerator.h"
#include "SubgroupEnumerator.h"
#include "ORConsequencesEnumerator.h"
#include "SubgroupContainmentProblem.h"
#include "Rewrites.h"
#include "HomEnumerators.h"
#include "EquationsInFPProblem.h"
#include "ListProblems.h"
#include "SMListWordProblem.h"
#include "SMListSubgroupProblems.h"
#include "FreeListProblems.h"


// --------------- ObjectSmith::outputCheckinMenuDefns --------------------- //


void ObjectSmith::outputCheckinMenuDefns(ostream& ostr)
{

  
// ----------------------------- Groups ------------------------------------ //

  {
    Menu0 M( Menu::CHECKIN );
	 


    M.startItemGroup();

    M.add( ReadSMAbelianGroup(), "Abelian Group", DefineAbelianGroup() );

    M.addDisabled( "Automatic Group" );
	 
    M.add( ReadSMFPGroup(), "Finitely Presented Group", DefineFPGroup() );

    M.add( ReadSMFreeGroup(), "Free Group", DefineFreeGroup() );

    M.addDisabled( "Hyperbolic Group" );

    M.addDisabled( "Matrix Group" );

    M.addDisabled( "Metabelian Group" );

    M.add( ReadSMNilpotentGroup(), "Nilpotent Group",
	   DefineNilpotentGroup() );

    M.add( ReadSMFreeNilpotentGroup(), "Free Nilpotent Group",
	   DefineFreeNilpotentGroup() );

    M.add( ReadSMORGroup(), "One Relator Group", DefineORGroup() );

    M.addDisabled( "Permutation Group" );

    M.addDisabled( "Polycyclic Group" );

    M.add( ReadSMSmallCancGroup(), "Small Cancellation Group",
	   DefineSmallCancGroup() );

    M.separator();

    M.addDisabled( "Direct Product" );

    M.addDisabled( "Semidirect Product" );
	 
    M.addDisabled( "Free Product" );

    M.add( Ctor0<CheckinAPOfFree>(), "Amalgamated Product" );

    M.add( Ctor0<CheckinHNNofFreeGroup>(), "HNN-extension" );

    M.addDisabled( "Tree Product" );

    M.addDisabled( "Graph Product" );

    M.separator();
    
    M.startCascade( "Group definition templates" );

    M.add( ReadSymmetricGroup(), "Symmetric group", 
	   DefineInt("Enter the number N", 2) );

    M.closeCascade();

    M.separator();
    
    M.add( ReadSMPermutation(), "Permutation", DefinePermutation() );
	 
    M.done();
  }

  //----------------------------- Substructures -------------------------------//

  {
    Menu1<SMFPGroup> M( Menu::CHECKIN );
	 

    M.startItemGroup();
	 
    M.add(ReadSMWord(), Text("Word in the generators of") + Name(1),
	  DefineWord());

    M.add(ReadSMSubgroup(), Text("Subgroup of") + Name(1),
	  DefineSubgroup());


    M.add(ReadSMMap(),
	  Text("Map from the generators of") + Name(1) + "to" + Name(1),
	  DefineMap()
	  );

  
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
		      CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION 
		      );
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE );

    M.add(ReadSMEquation2(),
	  Text("Equation in") + Name(1),
	  DefineEquation2()
	  );

    M.add(ReadSMEquation(),
	  Text("Quadratic equation in") + Name(1),
	  DefineEquation()
	  );

    M.add(ReadSMEqSystem(),
	  Text("System of equations in") + Name(1),
	  DefineEqSystem()
	  );

    M.add(ReadSMSetOfWords(), Text("Set of words in") + Name(1),
	  DefineSetOfWords());

    M.add(ReadSMVectorOfWords(), Text("Tuple of words in") + Name(1),
	  DefineVectorOfWords());

 	 
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
		      CheckinType( 1 ) == SMFPGroup::ABELIAN );
    
    M.add(ReadSMEquation2(),
	  Text("Equation in") + Name(1),
	  DefineEquation2()
	  );
    
    M.add(ReadSMEqSystem(),
	  Text("System of equations in") + Name(1),
	  DefineEqSystem()
	  );	 
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP 
		      );
    
    M.add(ReadSMVectorOfWords(), Text("Tuple of words in") + Name(1),
	  DefineVectorOfWords());

    M.done();
  }

  {
    Menu2<SMFPGroup,SMFPGroup> M( Menu::CHECKIN );
    
    M.startItemGroup();
    
    M.add(ReadSMMap2(),
	  Text("Map from the generators of") + Name(1) + "to" + Name(2),
	  DefineMap2()
	  );
    
    M.add(ReadSMMap2(true),
	  Text("Map from the generators of") + Name(2) + "to" + Name(1),
	  DefineInverseMap2()
	  );
    
    M.done();
  }

}


//---------------------------------------------------------------------------//
//----------------- ObjectSmith::outputToolsMenuDefns -----------------------//
//---------------------------------------------------------------------------//

void ObjectSmith::outputToolsMenuDefns(ostream& ostr)
{

  {
    Menu1<SMFPGroup> M( Menu::TOOLS );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ONE_RELATOR
		      || CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );

/*@db trivial questions

    M.add( Ctor1<ORIsTrivial, SMFPGroup>(), 
	   Text("Is") + Name(1) + Text("trivial ?")
	   );
    
    M.add( Ctor1<ORIsFinite, SMFPGroup>(), 
	   Text("Is") + Name(1) + Text("finite ?")
	   );
*/

    M.add( Ctor1<ORIsAbelian, SMFPGroup>(), 
	   Text("Is") + Name(1) + Text("abelian ?")
	   );

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::HNN_FREE
		      );

/*@db trivial questions
    M.add( Ctor1<HNNofFreeGroup_IsTrivial, SMFPGroup>(), 
	   Text("Is") + Name(1) + Text("trivial ?")
	   );
    
    M.add( Ctor1<HNNofFreeGroup_IsFinite, SMFPGroup>(), 
	   Text("Is") + Name(1) + Text("finite ?")
	   );
*/

    M.add( Ctor1<HNNofFreeGroup_IsAbelian, SMFPGroup>(), 
	   Text("Is") + Name(1) + Text("abelian ?")
	   );
    
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION
		      );

    M.add( Ctor1<MSCIsTrivial, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("trivial ?")
	   );

    M.add( Ctor1<MSCIsFinite, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("finite ?")
	   );
    
    M.add( Ctor1<MSCIsAbelian, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("abelian ?")
	   );


/*@db The following algorithms are too trivial and likely will
      be removed permanently

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::AP_FREE ||
		      CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
		      );

    M.add( Ctor1<APOfFreeIsTrivial, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("trivial ?")
	   );

    M.add( Ctor1<APOfFreeIsFinite, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("finite ?")
	   );
    
    M.add( Ctor1<APOfFreeIsAbelian, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("abelian ?")
	   );

*/    
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN ||
		      CheckinType( 1 ) == SMFPGroup::NILPOTENT ||
		      CheckinType( 1 ) == SMFPGroup::FP 
		      );
    
    M.add( Ctor1<IsTrivialProblem, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("trivial ?")
	   );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN ||
		      CheckinType( 1 ) == SMFPGroup::FP ||
                      CheckinType( 1 ) == SMFPGroup::NILPOTENT
		      );
    
    M.add( Ctor1<IsFiniteProblem, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("finite ?")
	   );


    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::NILPOTENT
		      );

    M.add( Ctor1<IsAbelianProblem, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("abelian ?")
	   );
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP
		      );
    
    M.add( Ctor1<IsAbelianProblem, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("abelian ?")
	   );

    M.add( ReadIsNilpotentProblemItem(),
	   Text("Is") + Name(1) + Text("nilpotent ?"),
	   DefineInt("Enter the nilpotency class: ", 1)
	   );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR
		      || CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );

    M.addDisabled( Text("Is") + Name(1) + Text("nilpotent ?") );


    
    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::FREE &&
		      CheckinType( 1 ) != SMFPGroup::NILPOTENT &&
		      CheckinType( 1 ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( 1 ) != SMFPGroup::ABELIAN &&
		      CheckinType( 1 ) != SMFPGroup::AP_FREE
		      );

    
    M.addDisabled( Text("Is") + Name(1) + Text("polycyclic ?") );

    M.addDisabled( Text("Is") + Name(1) + Text("metabelian ?") );
    

    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
		      CheckinType( 1 ) == SMFPGroup::AP_FREE ||
		      CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR
		      || CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );
    
    M.add( Ctor1<FPIsMSC,SMFPGroup>(),
	   Text("Is") + Name(1) + Text("metric small cancellation ?")
	   );


    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::NILPOTENT
		      );
    
    //    M.addDisabled( Text("Is") + Name(1) + Text("metric small cancellation ?"));


    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
		      //		      CheckinType( 1 ) == SMFPGroup::NILPOTENT ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR
		      );

    M.addDisabled( Text("Is") + Name(1) + Text("hyperbolic ?") );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::AP_FREE ||
		      CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
		      );
    
    M.add( Ctor1<APOfFreeIsHyperbolic,SMFPGroup>(),
	   Text("Is") + Name(1) + Text("hyperbolic ?")
	   );


    
    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::FREE &&
		      CheckinType( 1 ) != SMFPGroup::ONE_RELATOR &&
		      CheckinType( 1 ) != SMFPGroup::ONE_RELATOR_WITH_TORSION &&
		      CheckinType( 1 ) != SMFPGroup::ABELIAN &&
		      CheckinType( 1 ) != SMFPGroup::AP_FREE_CYCLIC &&
		      CheckinType( 1 ) != SMFPGroup::NILPOTENT
		      );

    M.addDisabled( Text("Is") + Name(1) + Text("a one-relator group ?")
		   );
   
    

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );
    
    M.add( Ctor1<ORIsFreeProblem, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("free ?") );
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::AP_FREE ||
		      CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
		      );
    
    M.add( Ctor1<APofFreeIsFree, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("free ?") );
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::HNN_FREE );
    
    M.add( Ctor1<HNNofFreeIsFree, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("free ?") );
        
      
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION ||
		      CheckinType( 1 ) == SMFPGroup::FP 
		      // CheckinType( 1 ) == SMFPGroup::AP_FREE ||
		      // CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
		      );

    M.addDisabled( Text("Is") + Name(1) + Text("free ?") );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN
		      );
    
    M.add( Ctor1<IsFreeProblem, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("free abelian ?") );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::NILPOTENT
		      );
    
    M.add( Ctor1<NGisFreeNilpotentProblem, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("free nilpotent ?") );
	
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::AP_FREE 
		      );

    M.add( Ctor1<APofFreeIsPerfect, SMFPGroup>(),
	   Text("Is") + Name(1) + Text("perfect ?") );
    /*
      M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
      CheckinType( 1 ) == SMFPGroup::AP_FREE ||
      CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
      );
      // It contains only one algorithm now, so we decided to comment it out
      // for a while.
   
      M.add( Ctor1<IsFreeProblem, SMFPGroup>(),
      Text("Is") + Name(1) + Text("free ?") );
      */	   


    
    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::FREE &&
		      CheckinType( 1 ) != SMFPGroup::FREE_NILPOTENT
		      );

    M.separator();



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN );

    M.add( Ctor1<AbelianOrderProblem, SMFPGroup>(),
	   Text("Compute the order of") + Name(1) );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION
		      );

    M.add( Ctor1<MSCOrder,SMFPGroup>(),
	   Text("Compute the order of") + Name(1)
	   );
 


    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ONE_RELATOR
		      || CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );

/*@db trivial question

    M.add( Ctor1<OROrder,SMFPGroup>(),
	   Text("Compute the order of") + Name(1)
	   );
*/ 

    M.add( ReadSMMagnusBreakdown(),
	   Text("Find HNN-presentation of") + Name(1)
	   );

    /*    M.add( Ctor1<ORConsequencesEnumerator,SMFPGroup >(),
	   Text("Enumerate all relator's consequences of") + Name(1)
	   );
	   */

/*@db The following algorithm is too trivial and likely to
      be removed permanently

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::AP_FREE ||
		      CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
		      );

    M.add( Ctor1<APOfFreeOrder,SMFPGroup>(),
	   Text("Compute the order of") + Name(1)
	   );
*/

    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP
		      );

    M.add( Ctor1<OrderProblem,SMFPGroup>(),
	   Text("Compute the order of") + Name(1)
	   );


     M.add( Ctor1<SchreierTransversal,SMFPGroup>(),
	   Text("Compute Schreier representatives for") + Name(1)
	   );

    M.add( Ctor1<PermutationRepProblem, SMFPGroup>(),
	   Text("Find a permutation representation of") + Name(1)
	   );

   
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::NILPOTENT
		      );

    M.add( Ctor1<OrderProblem,SMFPGroup>(),
	   Text("Compute the order of") + Name(1)
	   );
    
    M.add( Ctor1<NGcomputeNClassProblem, SMFPGroup>(),
	   Text("Compute the class of") + Name(1) 
	   );
    
    M.add( Ctor1<NGHirschNumberProblem,SMFPGroup>(),
	   Text("Compute the Hirsch number of") + Name(1)
	   );
   /*    M.add( Ctor1<NilpotentOrderProblem,SMFPGroup>(),
	   Text("Compute the order of") + Name(1)
	   );
	   */

   M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE_NILPOTENT
		      );
   
   M.add( Ctor1<NGHirschNumberProblem, SMFPGroup>(), 
	  Text("Compute the Hirsch number of") + Name(1)
	  );
   
   M.add( Ctor1<NGcomputeBasisProblem, SMFPGroup>(),
	  Text("Compute a basis of ") + Name(1)
	  );
   
   M.add( Ctor1<NGbuildPresentationProblem, SMFPGroup>(),
	  Text("Compute a presentation for ") + Name(1)
	  );
	  
   M.add( ReadLCStermProblem(),
	  Text("Find a term of lower central series of") + Name(1),
	  DefineInt("Enter the number of the term ", 1)
	  );

   M.startItemGroup( CheckinType( 1 ) != SMFPGroup::ABELIAN &&
		     CheckinType( 1 ) != SMFPGroup::FREE &&
		     CheckinType( 1 ) != SMFPGroup::FREE_NILPOTENT 
		      );

    M.add( Ctor1<AbelInvariantsProb,SMFPGroup>(),
	   Text("Compute the canonical decomposition of") + Name(1)
	   + Text("abelianized")
	   );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ONE_RELATOR
		      || CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );

    M.add( Ctor1<FastHomology,SMFPGroup>(),
	   Text("Compute the integral homology of") + Name(1)
	   );
        
    /*@rn FastHomology does not handle this yet.

      M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN );
   
      M.add( Ctor1<FastHomology,SMFPGroup>(),
      Text("Compute the integral homology of") + Name(1)
      );
      */


    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
		      // CheckinType( 1 ) == SMFPGroup::AP_FREE ||
		      // CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC ||
		      CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION ||
		      CheckinType( 1 ) == SMFPGroup::HNN_FREE 
		      );
    
    M.add( ReadHomologyItem(),
	   Text("Compute an integral homology group of") + Name(1),
	   DefineInt("What dimension?", 2)
	   );

   
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::AP_FREE
		      || CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
		      );

    M.add( Ctor1<APofFreeHomologyProblem,SMFPGroup>(),
	   Text("Compute the integral homology of") + Name(1)
	   );
    

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN
		      );
    
    M.add( ReadHomologyItem1(),
	   Text("Compute an integral homology group of") + Name(1),
	   DefineInt("What dimension?", 2)
	   );

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::NILPOTENT
		      );
    
    M.addDisabled( Text("Compute the integral homology of") + Name(1) );
    

    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::NILPOTENT );
   
    /*    M.add( Ctor1<NilpotentCenterProblem,SMFPGroup>(),
	   Text("Compute the center of") + Name(1)
	   );
	   */


    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::FREE &&
		      CheckinType( 1 ) != SMFPGroup::ABELIAN &&
		      CheckinType( 1 ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( 1 ) != SMFPGroup::NILPOTENT
		      );
    
    M.addDisabled( Text("Compute the center of") + Name(1)
		   );

    

    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::FREE &&
		      CheckinType( 1 ) != SMFPGroup::ABELIAN &&
		      CheckinType( 1 ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( 1 ) != SMFPGroup::NILPOTENT
		      );
    
    M.add( Ctor1<KBProblem,SMFPGroup>(),
	   Text("Find a finite rewriting system for") + Name(1)
	   );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE );  

    M.add( Ctor1<FreeIsAutomatic,SMFPGroup>(),
	   Text("Is") + Name(1) + Text("automatic ?")
	   );


    
    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::FREE &&
		      CheckinType( 1 ) != SMFPGroup::ABELIAN &&
		      CheckinType( 1 ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( 1 ) != SMFPGroup::NILPOTENT
		      );  

    M.add( Ctor1<AGProblem,SMFPGroup>(),
	   Text("Find a ShortLex automatic structure for") + Name(1)
	   );
    


    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN ||
		      CheckinType( 1 ) == SMFPGroup::FREE ||
		      CheckinType( 1 ) == SMFPGroup::NILPOTENT
		      );
    M.separator();


    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN );

    M.add( Ctor1<AbelianTorsionFreeRankProblem, SMFPGroup>(),
	   Text("Compute the torsion-free rank of") + Name(1) );

    M.add( Ctor1<AbelianComputeTorsionSubgroup, SMFPGroup>(),
	   Text("Compute the torsion subgroup of") + Name(1) );
    
    M.add( Ctor1<AbelianOrderOfTheTorsionSubgroupProblem, SMFPGroup>(),
	   Text("Compute the order of the torsion subgroup of") + Name(1) );

    M.add( Ctor1<AbelInvariantsProb,SMFPGroup>(),
	   Text("Compute the canonical decomposition of") + Name(1)
	   );
    M.add( Ctor1<AbelianPrimeDecomp,SMFPGroup>(),
	   Text("Compute the primary decomposition of") + Name(1)
	   );

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE );

    M.add( ReadFreeGetN_thElementItem(),
	   Text("Find the n-th element of") + Name(1),
	   DefineInt("Enter the number n: ", 0)
	   );
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE );
    /*    M.add( ReadAutEnumItem(),
	   Text("Randomly enumerate automorphisms of") + Name(1),
	   DefineInt("Average number of Nielsen generators?", 1)
	   );
    
    M.add( ReadFinAutEnumItem(),
	   Text("Randomly enumerate automorphisms of") + Name(1)
	   + Text("of finite order"),
	   DefineInt("Average number of Nielsen generators?", 1)
	   );

	   */
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::NILPOTENT );

    M.add( Ctor1<NGcomputeBasisProblem,SMFPGroup>(),
	   Text("Compute a basis of ")
	   + Name(1)
	   );

    M.add( Ctor1<NGcomputeBasisProblem,SMFPGroup>(),
	   Text("Compute the lower central factors of") + Name(1)
	   );

    M.add( ReadLCStermProblem(),
	   Text("Find a term of lower central series of") + Name(1),
	   DefineInt("Enter the number of the term ", 1)
	   );
    
    M.add( Ctor1<NGbuildPresentationProblem, SMFPGroup>(),
	  Text("Find a polycyclic presentation of") + Name(1)
	  );

    /*    M.addDisabled( Text("Compute a Malcev basis for the the")
		   + Text("relation subgroup of") + Name(1)
		   );
		   */
    
    
  // Enumerators

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
		      CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION 
		      );
    
    M.separator();

    M.add( Ctor1<NCRelatorEnumerator, SMFPGroup>(), 
	   Text("Enumerate relators of ") + Name( 1 ) +
	   Text(" using normal closure")
	   );
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FP ||
		      CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );
   
    M.add( Ctor1<WordEnumeratorProblem, SMFPGroup>(), 
	   Text("Enumerate words of ") + Name( 1 )
	   );
    
    M.add( Ctor1<SGEnumeratorProblem, SMFPGroup>(), 
	   Text("Enumerate subgroups of ") + Name( 1 )
	   );
    
    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE
		      );
    
    M.separator();
    
    M.add( Ctor1<AutoEnumeratorProblem, SMFPGroup>(), 
	   Text("Randomly enumerate automorphisms of ") + Name( 1 )
	   );

    M.add( Ctor1<FiniteAutoEnumeratorProblem, SMFPGroup>(), 
	   Text("Randomly enumerate automorphisms of ") + Name( 1 )
	   + Text("of finite order")
	   );

    M.add( Ctor1<WordEnumeratorProblem, SMFPGroup>(), 
	   Text("Enumerate words of ") + Name( 1 )
	   );
    
    M.add( Ctor1<SGEnumeratorProblem, SMFPGroup>(), 
	   Text("Enumerate subgroups of ") + Name( 1 )
	   );

   M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION 
		      );
    
    M.add( Ctor1<ORConsequencesEnumerator,SMFPGroup>(),
	   Text("Enumerate all consequences of the relator of ") + 
	   Name( 1 )
	   );
    
  
    M.done();
  }

  {
   
    //@@@@@@

    Menu1<SMWord> M( Menu::TOOLS );

    M.startItemGroup( 
		     //CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT &&
		     //CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::ABELIAN );

    M.add( Ctor1<FreelyReduceWord,SMWord>(),
	   Text("Freely reduce") + Name(1)
	   );

    M.add( Ctor1<CyclicallyReduceWord,SMWord>(),
	   Text("Cyclically reduce") + Name(1)
	   );

    M.add( Ctor1<FormalInverseOfWord,SMWord>(),
	   Text("Compute the inverse of") + Name(1) +Text("in the freely reduced form")
	   );
    
    M.add( Ctor1<WordLength,SMWord>(),
	   Text("Compute the length of") + Name(1) + Text("in the freely reduced form")
	   );
    
    M.startItemGroup( 
		     CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT &&
		     CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT &&
		     CheckinType( Parent(1) ) != SMFPGroup::ABELIAN );
    M.add( ReadInitialSegmentItem(),
	   Text("Find the i-th initial segment of the freely reduced form of") + Name(1),
	   DefineInt("Enter length of the initial segment: ", 1)
	   );

    M.add( ReadTerminalSegmentItem(),
	   Text("Find the i-th terminal segment of the freely reduced form of") 
	   + Name(1),
	   DefineInt("Enter length of the terminal segment: ", 1)
	   );

/*@db temporary removed

    M.add( ReadSegmentOfWordItem(),
	   Text("Find a subword of") + Name(1),
	   //		DefineInt("(due a bug in program, a length of subword is 1 always), "
	   //			  "so you should enter only the initial position: ", 1)
	   DefineInt2("Enter the initial position: ", 1,
		      "Enter the length: ", 1)
	   );

    M.add( ReadFreeGetNextN_thElementItem(),
	   Text("Find the n-th element of") + Name( Parent(1) ) + 
	   Text("(after the word") + Name(1) + Text("in the lex order)"),
	   DefineInt("Enter the number n: ", 0)
	   );
*/



    M.startItemGroup( CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::ABELIAN 
//++		      CheckinType( Parent(1) ) != SMFPGroup::ONE_RELATOR
//++		      CheckinType( Parent(1) ) != SMFPGroup::SMALL_CANCELLATION
		      );
	 
    M.separator();

	 
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE );

    M.add( Ctor1<WordProblemInFree,SMWord>(),
	   Text("Is") + Name(1) + "trivial in" + Name( Parent(1) ) + "?");
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::HNN_FREE );
	 
    M.add( Ctor1<HNNofFreeGroup_WordProblem,SMWord>(),
	   Text("Is") + Name(1) + "trivial in" + Name( Parent(1) ) + "?"
	   );

    M.add( Ctor1<HNNofFreeGroup_IsProperPower, SMWord>(),
	   Text("Is") + Name(1) + Text("a proper power in")
	   + Name( Parent(1) ) + Text("?")
	   );

    M.startItemGroup
      ( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE ||
	CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
	);
	 
    M.add( Ctor1<APOfFreeWordProblem,SMWord>(),
	   Text("Is") + Name(1) + "trivial in" + Name( Parent(1) ) + "?"
	   );
	 


    M.startItemGroup
      ( CheckinType( Parent(1) ) != SMFPGroup::FREE &&
	CheckinType( Parent(1) ) != SMFPGroup::AP_FREE &&
	CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT &&
	CheckinType( Parent(1) ) != SMFPGroup::AP_FREE_CYCLIC &&
	CheckinType( Parent(1) ) != SMFPGroup::HNN_FREE
	);
	 
    M.add( Ctor1<WordProblem,SMWord>(),
	   Text("Is") + Name(1) + "trivial in" + Name( Parent(1) ) + "?");

	 
	 
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::ABELIAN );


    M.add( Ctor1<AbelianPowerProblem, SMWord>(),
	   Text("Is ") + Name(1) + Text(" a proper power ?")
	   );

    M.add( Ctor1<AbelianSGGenedByWordPurityProblem, SMWord>(),
	   Text("Is the subgroup generated by")
	   + Name(1) + Text("pure ?")	
	   );
    M.add( Ctor1<AbelianDoesGensSummand, SMWord>(),
	   Text("Does ") + Name(1) + Text(" generate a direct summand ?")	
	   );

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT ); 
    
    M.add( Ctor1<NGisCentralProblem, SMWord>(),
	   Text("Is") + Name(1) + Text("central in")
	   + Name( Parent(1) ) + Text("?")
	   );
    
    M.add( Ctor1<NGisWordInCommutatorSGProblem, SMWord>(),
	   Text("Is") + Name(1) + Text("an element of the commutator subgroup of")
	   + Name( Parent(1) ) + Text("?")
	   );	
    
    M.add( Ctor1<NGorderOfEltProblem, SMWord>(),
	   Text("Compute the order of ") + Name(1) 
	   );

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE_NILPOTENT ); 

    M.add( Ctor1<WordProblem, SMWord>(),
	   Text("Is") + Name(1) + Text("trivial in")
	   + Name( Parent(1) ) + Text("?")
	   );

    M.add( Ctor1<NGisCentralProblem, SMWord>(),
	   Text("Is") + Name(1) + Text("central in")
	   + Name( Parent(1) ) + Text("?")
	   );


    M.add( Ctor1<NGisWordInCommutatorSGProblem, SMWord>(),
	   Text("Is") + Name(1) + Text("an element of the commutator subgroup of")
	   + Name( Parent(1) ) + Text("?")
	   );	 

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION );
    
    M.add( Ctor1<ORWithTorsionEltFiniteOrder, SMWord>(),
	   Text("Is") + Name(1) + Text("of finite order in") 
	   + Name( Parent(1) ) + Text("?")
	   );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( Parent(1) ) == SMFPGroup::SMALL_CANCELLATION
		      );

    M.addDisabled( Text("Is") + Name(1) + Text("of finite order in")
		   + Name( Parent(1) ) + Text("?")
		   );



    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FP ); 
	 
    M.add( Ctor1<OrderOfElt, SMWord>(),
	   Text("Is") + Name(1) + Text("of finite order in")
	   + Name( Parent(1) ) + Text("?")
	   );

    M.add( Ctor1<WordRepresentativeProblem, SMWord>(),
	   Text("Find the Schreier representative of ") + Name(1) 
	   );	 

    M.startItemGroup
      ( CheckinType( Parent(1) ) != SMFPGroup::ABELIAN &&
	CheckinType( Parent(1) ) != SMFPGroup::FREE &&
	CheckinType( Parent(1) ) != SMFPGroup::AP_FREE_CYCLIC &&
	CheckinType( Parent(1) ) != SMFPGroup::HNN_FREE
	);

    M.addDisabled( Text("Is") + Name(1) + Text("a proper power in")
		   + Name( Parent(1) ) + Text("?")
		   );



    M.startItemGroup
      ( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
	);

    M.add( Ctor1<APOfFreeCyclic_IsEltAProperPower, SMWord>(),
	   Text("Is") + Name(1) + Text("a proper power in")
	   + Name( Parent(1) ) + Text("?")
	   );

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE );

    M.add( Ctor1<FreeIsElementAProperPower,SMWord>(),
	   Text("Is") + Name(1) + Text("a proper power in")
	   + Name( Parent(1) ) + Text("?")
	   );
	 
    M.add( Ctor1<FreeMaximalRootOfElement,SMWord>(),
	   Text("Compute the maximal root of") + Name(1)
	   + Text("in") + Name( Parent(1) )
	   );
	 

	 
    M.startItemGroup( CheckinType( Parent(1) ) != SMFPGroup::ABELIAN &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE &&
		      CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::FP &&
		      CheckinType( Parent(1) ) != SMFPGroup::AP_FREE
		      );

    M.addDisabled( Text("Is") + Name(1) + Text("central in")
		   + Name( Parent(1) ) + Text("?")
		   );



    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FP ||
		      CheckinType( Parent(1) ) == SMFPGroup::FP
		      );

    M.add( Ctor1<IsEltCentral,SMWord>(),
	   Text("Is") + Name(1) + Text("central in")
	   + Name( Parent(1) ) + Text("?")
	   );

    M.startItemGroup( CheckinType( Parent(1) ) != SMFPGroup::ABELIAN &&
		      CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::AP_FREE
		      );

    M.add( Ctor1<CommutatorRewriteProblem,SMWord>(),
	   Text("Rewrite") + Name(1) + Text("as a product of commutators")
	   );

    M.add( Ctor1<SquareRewriteProblem,SMWord>(),
	   Text("Rewrite") + Name(1) + Text("as a product of squares")
	   );

    //@dp Need to be checked for new item group with separator.
    M.startItemGroup( 
		     CheckinType( Parent(1) ) != SMFPGroup::ONE_RELATOR
		  && CheckinType( Parent(1) ) != SMFPGroup::SMALL_CANCELLATION
		  && CheckinType( Parent(1) ) != SMFPGroup::FP
		     );
    
    /*
    M.startItemGroup( );

    M.separator();
    */

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT );

    M.add( Ctor1<NGdecomposeWordProblem,SMWord> (),
	   Text("Compute the canonical decomposition of") + Name(1)
	   );

    M.add( Ctor1<NGweightOfWordProblem,SMWord>(),
	   Text("Find in which term of the lower central series") + Name(1)
	   + "lies"
	   );

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE_NILPOTENT );

    M.add( Ctor1<NGIsProperPower, SMWord>(),
	   Text("Is ") + Name(1) + Text(" a proper power ?")
	   );

    M.add( Ctor1<NGcentralizer, SMWord>(),
	   Text("Compute the centralizer of ") + Name(1)
	   );

    M.add( Ctor1<NGMaximalRootProblem, SMWord>(),
	   Text("Compute the maximal root of ") + Name(1)
	   );

    M.add( Ctor1<NGdecomposeWordProblem,SMWord> (),
	   Text("Compute the canonical decomposition of") + Name(1)
	   );

    M.add( Ctor1<NGweightOfWordProblem,SMWord>(),
	   Text("Find in which term of the lower central series") + Name(1)
	   + "lies"
	   );


 

    
    M.startItemGroup
      ( CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
	);
	 
    M.add( Ctor1<ORWithTorsionCentralizerOfElt, SMWord>(),
	   Text("Compute the centralizer of") + Name(1) + "in"
	   + Name( Parent(1) )
	   );
	 

    M.startItemGroup
      ( CheckinType( Parent(1) ) != SMFPGroup::ABELIAN &&
	CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT &&
	CheckinType( Parent(1) ) != SMFPGroup::AP_FREE_CYCLIC &&
	CheckinType( Parent(1) ) != SMFPGroup::ONE_RELATOR_WITH_TORSION &&
	CheckinType( Parent(1) ) != SMFPGroup::FREE
	);
	 
    M.addDisabled( Text("Compute the centralizer of") + Name(1) + "in"
		   + Name( Parent(1) )
		   );



    M.startItemGroup
      ( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
	);
	 
    M.add( Ctor1<APOfFreeCyclic_CentralizerOfElt, SMWord>(),
	   Text("Compute the centralizer of") + Name(1) + "in"
	   + Name( Parent(1) )
	   );
	 


    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE );

    M.add( Ctor1<FreeCentolizerOfElement, SMWord>(),
	   Text("Compute the centralizer of") + Name(1) + "in"
	   + Name( Parent(1) )
	   );

    M.add( Ctor1<CommutatorInFree,SMWord>(),
	   Text("Is") + Name(1) + "a commutator in" + Name( Parent(1) )
	   + Text("?")
	   );

    M.add( Ctor1<TwoCommProblem,SMWord>(),
	   Text("Is") + Name(1) + "a product of two commutators in" 
	   + Name( Parent(1) ) + Text("?")
	   );

    M.add( Ctor1<FreeInCommutatorSG,SMWord>(),
	   Text("Is") + Name(1) + "in the commutator subgroup of"
	   + Name( Parent(1) ) + Text("?")
	   );

    M.add( Ctor1<ProductOfCommutators,SMWord>(),
	   Text("Rewrite") + Name(1) + "as a product of commutators" 
	   + Name( Parent(1) )
	   );
    
    M.add( Ctor1<ProductOfSquares,SMWord>(),
	   Text("Rewrite") + Name(1) + "as a product of squares" 
	   + Name( Parent(1) )
	   );

    M.add( Ctor1<FreeIsPartOfBasisProblem,SMWord>(),
	   Text("Is") + Name(1) + "part of a basis of" +
	   Name( Parent(1) ) + "?"
	   );

    M.add( Ctor1<IsWordAPEProblem,SMWord>(),
	   Text("Is ") + Name(1) + "almost primitive element in " 
	   + Name( Parent(1) ) + "?"
	   );
    
    
    M.add( Ctor1<RankOfElementProblem,SMWord>(),
	   Text("Compute a rank of ") + Name(1) + " in " 
	   + Name( Parent(1) ) + "?"
	   );
	 
    M.startItemGroup
      ( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE ||
	CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
	);
	 
    M.add( Ctor1<APOfFreeReducedForm,SMWord>(),
	   Text("Compute the reduced form of") + Name(1)
	   );

    M.add( Ctor1<APOfFreeNormalForm,SMWord>(),
	   Text("Compute the normal form of") + Name(1)
	   );

    M.add( Ctor1<APOfFreeCyclicNormalForm,SMWord>(),
	   Text("Compute the cyclic normal form of") + Name(1)
	   );



    M.startItemGroup
      ( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
	);

    M.add( Ctor1<APOfFreeCyclic_MaximalRoot, SMWord>(),
	   Text("Compute the maximal root of") + Name(1)
	   + Text("in") + Name( Parent(1) )
	   );
	 

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::HNN_FREE );

    M.add( Ctor1<HNNofFreeGroup_ReducedForm,SMWord>(),
	   Text("Compute the reduced form of") + Name(1)
	   );

    M.add( Ctor1<HNNofFreeGroup_NormalForm,SMWord>(),
	   Text("Compute the normal form of") + Name(1)
	   );

    M.add( Ctor1<HNNofFreeGroup_CyclicallyReducedForm,SMWord>(),
	   Text("Compute the cyclic normal form of") + Name(1) 
	   + Text("in") + Name( Parent(1) )
	   );

    M.add( Ctor1<HNNofFreeGroup_MaximalRoot, SMWord>(),
	   Text("Compute the maximal root of") + Name(1)
	   );
	 
    M.done();
  }

  {
    Menu1<SMSubgroup> M( Menu::TOOLS );

    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE
		      );
    
    M.add( Ctor1<FreeIsSGTrivial,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("trivial ?")
	   );


    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::ABELIAN ||
		      CheckinType( Parent(1) ) == SMFPGroup::FP ||
		      CheckinType( Parent(1) ) == SMFPGroup::SMALL_CANCELLATION
		      );
  
    M.add( Ctor1<IsSGTrivial,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("trivial ?")
	   );
    
    M.startItemGroup( 
      CheckinType( Parent(1) ) == SMFPGroup::FP
      || CheckinType( Parent(1) ) == SMFPGroup::SMALL_CANCELLATION
    );

    M.addDisabled( Text("Is") + Name(1) + Text("finite ?") );

    M.startItemGroup( 
      CheckinType( Parent(1) ) == SMFPGroup::FP
      || CheckinType( Parent(1) ) == SMFPGroup::SMALL_CANCELLATION
      || CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR
      || CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
      
    );

    M.add( Ctor1<IsSGAbelian,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("abelian ?")
	   );

    M.startItemGroup( 
      CheckinType( Parent(1) ) == SMFPGroup::FP
      || CheckinType( Parent(1) ) == SMFPGroup::SMALL_CANCELLATION
      || CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR
      || CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
      || CheckinType( Parent(1) ) == SMFPGroup::AP_FREE
      || CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
      || CheckinType( Parent(1) ) == SMFPGroup::HNN_FREE
    );

    M.add( Ctor1<IsSGNormal,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("normal ?")
	   );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE ||
		      CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
		      );

    M.add( Ctor1<APOfFreeIsSGAbelian,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("abelian ?")
	   );

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::HNN_FREE );

    M.add( Ctor1<HNNofFreeGroup_IsSGAbelian,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("abelian ?")
	   );


    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FP
		      );
    
    M.add( ReadIsSGNilpotentItem(),
	   Text("Is") + Name(1) + Text("nilpotent ?"),
	   DefineInt("Enter the nilpotency class: ", 1)
	   );

    M.add( Ctor1<IsSGCentral,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("central ?")
	   );
    
    M.separator();

    M.add( Ctor1<SGIndexProblem, SMSubgroup>(),
	   Text("Compute the index of") + Name(1) + Text("in")
	   + Name( Parent(1) )
	   );
  
    M.add( Ctor1<SchreierTransversal, SMSubgroup>(),
	   Text("Compute a Schreier transversal of") + Name(1)
	   );
 
    M.add( Ctor1<PermutationRepProblem, SMSubgroup>(),
	   Text("Find a permutation representation of") + Name(Parent(1)) +
	   " modulo " + Name( 1 )
	   );

     M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::ABELIAN );

    M.add( Ctor1<AbelianIsSGIsolatedProblem, SMSubgroup>(),
	   Text("Is") + Name(1) + "isolated in" + Name( Parent(1) ) + "?"
	   );

    M.add( Ctor1<AbelianSGOrder, SMSubgroup>(),
	   Text("Compute  the order of ") + Name(1)
	   );
 
    M.add( Ctor1<AbelianTorsionFreeRankOfSG, SMSubgroup>(),
           Text("Compute the torsion-free rank of") + Name(1)
	   );

    M.add( Ctor1<AbelianOrderOfTheTorsionSubgroupOfSG, SMSubgroup>(),
           Text("Compute the order of the torsion subgroup of")
		   + Name(1)
	   );

    M.separator();

    M.add( Ctor1<AbelianSGCyclicDecomposition, SMSubgroup>(),
	   Text("Compute the canonical decomposition for") + Name(1)
	   );

    M.add( Ctor1<AbelianSGPrimesDecomposition, SMSubgroup>(),
	   Text("Compute the primary decomposition for ") + Name(1)
	   );
    
    M.separator();
    
    M.add( Ctor1<AbelianIsSGEqualToTheGroup, SMSubgroup>(),
	   Text("Is") + Name(1) + "=" + Name( Parent(1) ) + "?"
	   );
    
    M.add( Ctor1<AbelianSGIndexProblem, SMSubgroup>(),
	   Text("Compute the index of") + Name(1) + Text("in")
	   + Name( Parent(1) )
	   );
    M.add( Ctor1<SubgroupIsolator, SMSubgroup>(),
	   Text("Compute the isolator of ") + Name(1)
	   );

    M.add( Ctor1<virtualFreeComp, SMSubgroup>(),
	   Text("Compute a virtual free complement of ") + Name(1) +
	   Text("in") + Name( Parent(1) )
	   );

    M.add( Ctor1<AbelianSGPurityProblem, SMSubgroup>(),
	   Text("Is") + Name(1) + "pure in" + Name( Parent(1) ) + "?"
	   );
   


    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT );

    M.add( Ctor1<IsSGTrivial,SMSubgroup>(),
	   Text("Is") + Name(1) + "trivial ?"
	   );

    /*    M.add( Ctor1<NilpotentIsSGFiniteProblem,SMSubgroup>(),
	   Text("Is") + Name(1) + "finite ?"
	   );
	   */
    M.add( Ctor1<IsSGAbelian,SMSubgroup>(),
	   Text("Is") + Name(1) + "abelian ?"
	   );
    
    M.add( Ctor1<IsSGCentral,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("central ?")
	   );
    
    M.add( Ctor1<SGOfNGisNormalProblem,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("normal ?")
	   );

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE ||
		      CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
		      );

    M.add( Ctor1<APOfFreeIsSGTrivial,SMSubgroup>(),
	   Text("Is") + Name(1) + "trivial ?"
	   );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::HNN_FREE );

    M.add( Ctor1<HNNofFreeGroup_IsSGTrivial,SMSubgroup>(),
	   Text("Is") + Name(1) + "trivial ?"
	   );

    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE );
    
    M.add( Ctor1<SGOfFreeIsNormal,SMSubgroup>(),
	   Text("Is") + Name(1) + "normal in" + Name( Parent(1) ) + "?"
	   );

    M.add( Ctor1<SGOfFreeIsMalnormal,SMSubgroup>(),
	   Text("Is") + Name(1) + "malnormal in" + Name( Parent(1) ) + "?"
	   );
    
    M.add( Ctor1<SGOfFreeIndex,SMSubgroup>(),
	   Text("What is the index of") + Name(1) + "in"
	   + Name( Parent(1) ) + "?"
	   );
    
    M.add( Ctor1<SGOfFreeRank,SMSubgroup>(),
	   Text("Compute a rank of") + Name(1) + "?"
	   );
    
    M.separator();
    
    M.add( Ctor1<SGOfFreeNielsenBasis,SMSubgroup>(),
	   Text("Compute a Nielsen basis for") + Name(1)
	   );
    
    M.add( Ctor1<SGOfFreeNormaliser,SMSubgroup>(),
	   Text("Compute the normaliser of") + Name(1) + "in"
	   + Name( Parent(1) ) + "?"
	   );
    
    M.add( Ctor1<SGOfFreeHallCompletion,SMSubgroup>(),
	   Text("Compute a finite index subgroup of") + Name( Parent(1) )
	   + "with" + Name(1) + "as a free factor"
	   );
    
    M.add( Ctor1<RankOfSubgroupProblem,SMSubgroup>(),
	   Text("Compute the rank of ") + Name(1) + " in "
	   + Name( Parent(1) ) + "?"
	   );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR 
		      || CheckinType( Parent(1) ) 
		      == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );
    
    M.add( Ctor1<ORIsMagnusSubgroup,SMSubgroup>(),
	   Text("Is") + Name(1) + " a Magnus subgroup ?"
	   );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FP ||
		      CheckinType( Parent(1) ) == SMFPGroup::AP_FREE ||
		      CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC ||
		      CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( Parent(1) ) == SMFPGroup::SMALL_CANCELLATION
		      || CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );
    
    M.add( Ctor1<SGPresentationProblem,SMSubgroup>(),
	   Text("Compute a presentation for") + Name(1) 
	   );
    
    //    M.separator();
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT );

    M.separator();

    M.add( Ctor1<SGOfNGhirschNumberProblem,SMSubgroup>(),
	   Text("Compute the Hirsch length of") + Name(1)
	   );
    /* @am Due to a bug in the algorthm
       M.add( Ctor1<SGOfNGindexProblem,SMSubgroup>(),
       Text("Compute the index of") + Name(1) + "in" + Name( Parent(1) )
       );
    */
    M.add( Ctor1<SGOfNGcomputeNClassProblem,SMSubgroup>(),
	   Text("Compute the class of") + Name(1)
	   );

    M.separator();    

    M.add( Ctor1<SGOfNGcomputeBasisProblem,SMSubgroup>(),
	   Text("Compute a basis for") + Name(1)
	   );

    M.add( Ctor1<SGOfNGbuildPresentationProblem,SMSubgroup>(),
	   Text("Find a presentation of") + Name(1)
	  );

    M.add( Ctor1<SGOfNGnormalClosureProblem,SMSubgroup>(),
	   Text("Find the normal closure of") + Name(1) +
	   Text("in") + Name( Parent(1) )
	   );
	 
    /*   M.add( Ctor1<SGOfNGnormalClosureGens,SMSubgroup>(),
	   Text("Find normal closure of") + Name(1)
	   );
	   */
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE_NILPOTENT );
    
    M.add( Ctor1<IsSGCentral,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("central ?")
	   );
    
    M.add( Ctor1<SGOfNGisNormalProblem,SMSubgroup>(),
	   Text("Is") + Name(1) + "normal in" + Name( Parent(1) ) + "?"
	   );

    /*    M.addDisabled(
	   Text("Is") + Name(1) + "a free factor of" + Name( Parent(1) ) + "?"
	   );
	   */
    M.separator();

    M.add( Ctor1<SGOfNGhirschNumberProblem,SMSubgroup>(),
	   Text("Compute the Hirsch length of") + Name(1)
	   );
        
    M.add( Ctor1<SGOfNGindexProblem,SMSubgroup>(),
	   Text("Compute the index of") + Name(1) + "in" + Name( Parent(1) )
	   );

    M.separator();
    
    M.add( Ctor1<SGOfNGcomputeBasisProblem,SMSubgroup>(),
	   Text("Compute a basis for") + Name(1)
	   );

    M.add( Ctor1<SGOfNGbuildPresentationProblem,SMSubgroup>(),
	   Text("Find a presentation of") + Name(1)
	  );

    M.add( Ctor1<SGOfNGnormalClosureProblem,SMSubgroup>(),
	   Text("Find the normal closure of") + Name(1) +
	   Text("in") + Name( Parent(1) ) + "(long procedure)"
	   );
	   
    M.add( Ctor1<SGOfNGnormalClosureGensProblem,SMSubgroup>(),
	   Text("Find the normal closure of") + Name(1) +
	   Text("in") + Name( Parent(1) )
	   );

    // Enumerators
    M.startItemGroup( CheckinType( Parent( 1 ) ) == SMFPGroup::FP ||
		      CheckinType( Parent( 1 ) ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( Parent( 1 ) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION 
		      ); 
   
    M.separator();
    M.add( Ctor1<SGRelatorEnumerator,SMSubgroup>(),
	   Text("Enumerate relators of ") + Name( 1 )
	   );
    M.done();
  }
  
  {
    Menu1<SMSetOfWords> M( Menu::TOOLS );

    
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE
		      );

    M.add( Ctor1<FreeGeneralIsPartOfBasisProblem,SMSetOfWords>(),
	   Text("Is") + Name(1) + "part of a basis of" +
	   Name( Parent(1) ) + "?"
	   );
    
    M.done();
  }

  {
    Menu1<SMVectorOfWords> M( Menu::TOOLS );

    
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE
		      );
    /*
    M.add( Ctor1<SGOfFreeWhiteheadReduction,SMVectorOfWords>(),
	   Text("Find Whitehead reduction of") + Name(1) 
	   );
    */  
    M.add( Ctor1<ACConjectureProblem,SMVectorOfWords>(),
	   Text("Find Andrews-Curtis reduction of") + Name(1)
	   );

    M.add( Ctor1<FindWhiteheadMinimalProblem,SMVectorOfWords>(),
	   Text("Find Whitehead reduction of") + Name(1)+"(genetic)"
	   );

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FP ||
		      CheckinType( Parent(1) ) == SMFPGroup::FREE
		      );
    
    M.add( Ctor1<FPNewPresentationProblem,SMVectorOfWords>(),
	   Text("Compute a presentation for") + Name( Parent(1) ) + Text("on new generators given by") + Name(1)
	   );
  
    M.done();
  }

  {
    Menu1<SMMap> M( Menu::TOOLS );


    M.startItemGroup( CheckinType( Domain(1) ) == SMFPGroup::FREE &&
		      CheckinType( Range(1) ) == SMFPGroup::FREE
		      );
    
    M.add( Ctor1<ExtendToHomProblem,SMMap>(),
	   Text("Extend") + Name( 1 ) + "to a homomorphism"
	   );

    

    M.startItemGroup( (CheckinType( Domain(1) ) != SMFPGroup::FREE ||
		      CheckinType( Range(1) ) != SMFPGroup::FREE ) 
		      );
    
    M.add( Ctor1<ExtendToHomProblem,SMMap>(),
	   Text("Does") + Name( 1 ) + "extend to a homomorphism ?"
	   );
	 
	 
/*
	 M.startItemGroup( ( Domain(1) == Range(1) ) &&
			   ( CheckinType( Domain(1) ) == SMFPGroup::FREE ||
			     IsHomo( 1 ) )
			   );
	 
	 M.add( ReadPowerOfMapItem(),
		Text("Compute a power of") + Name(1),
		DefineInt("What power?", 2)
		);
*/	 
/*
	 M.startItemGroup( Domain(1) == Range(1) &&
			   CheckinType( Domain(1) ) == SMFPGroup::FREE
			   );

	 M.add( Ctor1<EndoOnFreeIsAut,SMMap>(),
		Text("Is") + Name(1) + "an automorphism of"
		+ Name( Domain(1) ) + "?"
		);

	 M.add( Ctor1<EndoOnFreeIsInner,SMMap>(),
		Text("Is") + Name(1) + "an inner automorphism of"
		+ Name( Domain(1) ) + "?"
		);
	 
	 M.startItemGroup( IsAuto( 1 ) &&
			   CheckinType( Domain(1) ) == SMFPGroup::FREE
			   );


         M.add( Ctor1<InverseAuto,SMMap>(),
	 Text("Compute the inverse of") + Name( 1 )
	 );
	 
	 M.separator();
	 
	 M.add( Ctor1<ExtendFreeByAut,SMMap>(),
	 Text("Extend") + Name( Domain(1) ) + "by" + Name(1)
	 );
*/	 

    M.done();
  }

  {
    Menu1<SMHomomorphism> M( Menu::TOOLS );


    M.startItemGroup( );


  

    M.startItemGroup( CheckinType( Domain(1) ) != SMFPGroup::ABELIAN 
		      && CheckinType( Domain(1) ) != SMFPGroup::FREE
		      );
 
    M.addDisabled( Text("Is") + Name( 1 ) + "a monomorphism ?"
		   );
    M.startItemGroup( CheckinType( Domain(1) ) != SMFPGroup::ABELIAN &&
		      CheckinType( Domain(1) ) != SMFPGroup::NILPOTENT &&
		      CheckinType( Domain(1) ) != SMFPGroup::FREE_NILPOTENT 
		      );
    M.addDisabled( Text("Is") + Name( 1 ) + "an epimorphism ?"
		   );

    M.startItemGroup( CheckinType( Domain(1) ) == SMFPGroup::ABELIAN );

    M.add( Ctor1<AbelianHomIsMono,SMHomomorphism>(),
	   Text("Is") + Name(1) + "a monomorphism ?"
	   );
    M.startItemGroup( CheckinType( Domain(1) ) == SMFPGroup::ABELIAN ||
		      CheckinType( Domain(1) ) == SMFPGroup::NILPOTENT ||
		      CheckinType( Domain(1) ) == SMFPGroup::FREE_NILPOTENT 
		      );

    M.add( Ctor1<AbelianHomIsEpi,SMHomomorphism>(),
	   Text("Is") + Name(1) + "an epimorphism ?"
	   );

    M.add( Ctor1<AbelianHomIsAuto,SMHomomorphism>(),
	   Text("Is") + Name(1) + "an automorphism ?"
	   );

    M.startItemGroup( CheckinType( Domain(1) ) == SMFPGroup::FREE );

    M.add( Ctor1<EndoOnFreeIsMono,SMHomomorphism>(),
	   Text("Is") + Name( 1 ) + "a monomorphism ?"
	   );

    M.add( Ctor1<EndoOnFreeIsEpi,SMHomomorphism>(),
	   Text("Is") + Name( 1 ) + "an epimorphism ?"
	   );

    M.add( Ctor1<EndoOnFreeIsAut,SMHomomorphism>(),
	   Text("Is") + Name(1) + "an automorphism ?"
	   );

    
    M.startItemGroup( CheckinType( Domain(1) ) != SMFPGroup::FREE &&
		      CheckinType( Domain(1) ) != SMFPGroup::ABELIAN &&
		      CheckinType( Domain(1) ) != SMFPGroup::NILPOTENT &&
		      CheckinType( Domain(1) ) != SMFPGroup::FREE_NILPOTENT 
		      );
	 
    M.addDisabled( Text("Is") + Name( 1 ) + "an automorphism ?"
		   );

    M.startItemGroup( IsAuto(1) &&
		       CheckinType( Domain(1) ) == SMFPGroup::ABELIAN 
		       );
    M.separator();

    M.add( Ctor1<AbelianOrderOfAuto,SMHomomorphism>(),
	   Text("Compute the order of ") + Name(1) 
	   );
    
    M.add( Ctor1<AbelianInverseAuto,SMHomomorphism>(),
	   Text("Find the inverse of ") + Name(1) 
	   );

    M.add( Ctor1<AbelianFixedPointsOfAutoProblem,SMHomomorphism>(),
	   Text("Compute the fixed points of ") + Name(1) 
	   );

    M.startItemGroup( IsAuto(1) &&
		       CheckinType( Domain(1) ) == SMFPGroup::FREE_NILPOTENT 
		       );
    M.separator();

    M.add( Ctor1<AutoInFreeIsFinite,SMHomomorphism>(),
	   Text("Is") + Name(1) + "of finite order?"
	   );
      
    M.add( Ctor1<FNGAutoIsIAAut,SMHomomorphism>(),
	   Text("Is") + Name(1) + "an IA-automorphism ?"
	   );
	
    M.add( Ctor1<NGInverseAuto,SMHomomorphism>(),
	   Text("Find the inverse of ") + Name(1) 
	   );
	
    M.startItemGroup( IsAuto(1) &&
		      CheckinType( Domain(1) ) == SMFPGroup::NILPOTENT 
		      );
    M.separator();
    
    M.add( Ctor1<NGAutoIsIAAut,SMHomomorphism>(),
	   Text("Is") + Name(1) + "an IA-automorphism ?"
	   );

    M.startItemGroup( IsAuto(1) &&
		      CheckinType( Domain(1) ) == SMFPGroup::FREE 
		      );
    M.separator();
    
    M.add( Ctor1<AutoInFreeIsFinite,SMHomomorphism>(),
	   Text("Is") + Name(1) + "of finite order?"
	   );   

    M.add( Ctor1<EndoOnFreeIsIAAut,SMHomomorphism>(),
	   Text("Is") + Name(1) + "an IA-automorphism ?"
	   );

 
    M.add( Ctor1<EndoOnFreeIsInner,SMHomomorphism>(),
	   Text("Is") + Name(1) + "an inner automorphism ?"
	   );

    M.add( Ctor1<InverseAuto,SMHomomorphism>(),
	   Text("Compute the inverse of") + Name( 1 )
	   );

    M.separator();

    M.add( Ctor1<ExtendFreeByAut,SMHomomorphism>(),
	   Text("Extend") + Name( Domain(1) ) + "by" + Name(1)
	   );

    M.add( Ctor1<AutoWhiteheadDecomposition,SMHomomorphism>(),
	   Text("Find Whitehead decomposition of") + Name(1)
	   );

	 	 
    M.startItemGroup( !IsAuto(1) ||
		      (CheckinType( Domain(1) ) != SMFPGroup::FREE &&
		       CheckinType( Domain(1) ) != SMFPGroup::FREE_NILPOTENT &&
		       CheckinType( Domain(1) ) != SMFPGroup::NILPOTENT &&
		       CheckinType( Domain(1) ) != SMFPGroup::ABELIAN)
		       );

    M.addDisabled( Text("Is") + Name( 1 ) + "an IA-automorphism ?"
		   );
   M.startItemGroup( !IsAuto(1) ||
		     CheckinType( Domain(1) ) != SMFPGroup::FREE );

    M.addDisabled( Text("Is") + Name( 1 ) + "an inner automorphism ?"
		   );

    M.done();
  }

  {
    Menu1<SMHomomorphism2> M( Menu::TOOLS );

	 

    M.startItemGroup( );

    M.startItemGroup( CheckinType( Domain(1) ) != SMFPGroup::ABELIAN );

    M.addDisabled( Text("Is") + Name( 1 ) + "a monomorphism ?"
		   );
    M.startItemGroup( CheckinType( Domain(1) ) != SMFPGroup::ABELIAN &&
		      CheckinType( Domain(1) ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( Domain(1) ) != SMFPGroup::NILPOTENT 
		      );
    
    M.addDisabled( Text("Is") + Name( 1 ) + "an epimorphism ?"
		   );
    
    M.startItemGroup( CheckinType( Domain(1) ) != SMFPGroup::ABELIAN );

    M.addDisabled( Text("Is") + Name( 1 ) + "an isomorphism ?"
		   );

    M.startItemGroup( CheckinType( Domain(1) ) == SMFPGroup::ABELIAN );

    M.add( Ctor1<AbelianHomIsMono,SMHomomorphism2>(),
	   Text("Is") + Name(1) + "a monomorphism ?"
	   );
	 
    M.add( Ctor1<AbelianHomIsEpi,SMHomomorphism2>(),
	   Text("Is") + Name(1) + "an epimorphism ?"
	   );

    M.add( Ctor1<AbelianHomIsIso,SMHomomorphism2>(),
	   Text("Is") + Name(1) + "an isomorphism ?"
	   );
    M.startItemGroup( CheckinType( Domain(1) ) == SMFPGroup::NILPOTENT ||
		      CheckinType( Domain(1) ) == SMFPGroup::FREE_NILPOTENT 
		      );

    M.add( Ctor1<AbelianHomIsEpi,SMHomomorphism2>(),
	   Text("Is") + Name(1) + "an epimorphism ?"
	   );

    M.startItemGroup( IsAuto( 1 ) &&
		      CheckinType( Domain(1) ) == SMFPGroup::FREE
		      );

    M.add( Ctor1<InverseAuto,SMHomomorphism2>(),
	   Text("Compute the inverse of") + Name( 1 )
	   );
	 
    M.startItemGroup( ( CheckinType( Domain(1) ) == SMFPGroup::FP ) &&
		      ( CheckinType( Range(1) ) == SMFPGroup::FP  ) 
		      );
    
    M.add( Ctor1<FPKernelPresentationProblem,SMHomomorphism2>(),
	   Text("Compute a presentation for the kernel of") + Name( 1 )
	   );
	
    M.separator();
	 
    M.add( Ctor1<ExtendFreeByAut,SMHomomorphism2>(),
	   Text("Extend") + Name( Domain(1) ) + "by" + Name(1)
	   );
	 

	 
    M.done();
  }

  {
    Menu1<SMEquation2> M( Menu::TOOLS );

    M.startItemGroup( CheckinType( Parent( 1 ) ) == SMFPGroup::FREE );

    M.add( Ctor1<GAEquationProblem, SMEquation2>(),
	   Text("Find a solution for") + Name(1)
	   );

    M.startItemGroup( CheckinType( Parent( 1 ) ) == SMFPGroup::FP ||
		      CheckinType( Parent( 1 ) ) == SMFPGroup::ABELIAN );
    
    M.add( Ctor1<EquationInFPProblem , SMEquation2>(),
	   Text("Find all solutions for") + Name(1)
	   );

    M.done();
  }

  {
    Menu1<SMEquation> M( Menu::TOOLS );

    M.startItemGroup();

    M.add( Ctor1<QuadEquationSurfaceForm, SMEquation>(),
	   Text("Find a surface form of") + Name(1)
	   );

	 
    M.add( Ctor1<EquationProblem,SMEquation>(),
	   Text("Solve the equation") + Name(1) + " = 1"
	   );
	 	 
    M.add( Ctor1<QuickEquationProblem,SMEquation>(),
	   Text("Find basic solutions of the equation") + Name(1) + " = 1"
	   );

    /* @dp Debug only menu items.
       M.separator();

       M.add( Ctor1<QEquationInFreeBasicSolutions,SMEquation>(),
       Text("View known basic solutions of ") + Name(1)
       );

       M.add( Ctor1<QEquationInFreeRegStabGenerators,SMEquation>(),
       Text("View known generators of regular stabilizer of") + Name(1)
       );
    */

    M.done();
  } 

  {
    Menu1<SMEqSystem> M( Menu::TOOLS );

    M.startItemGroup();

    M.add( Ctor1<EqSystemInFPProblem , SMEqSystem>(),
	   Text("Find solutions for") + Name(1)
	   );

    M.done();
  }


  {
    Menu2<SMWord,SMWord> M( Menu::TOOLS );



    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ABELIAN
		      );
    
    M.add( Ctor2<ProductInAbelianForm, SMWord, SMWord>(),
	   Text("Compute the product") + Name(1) + Name(2)
	   + Text(", in abelian form")
	   );

    M.add( Ctor2<ProductInAbelianForm, SMWord, SMWord>(true),
	   Text("Compute the product") + Name(2) + Name(1)
	   + Text(", in abelian form")
	   );



    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) != SMFPGroup::ABELIAN
		      );
    
    M.add( Ctor2<FormalProductOfWords,SMWord,SMWord>(),
	   Text("Compute the product") + Name(1) + " * " + Name(2)
	   );
    
    M.add( Ctor2<FormalProductOfWords,SMWord,SMWord>(true),
	   Text("Compute the product") + Name(2) + " * " + Name(1)
	   );
 
    M.add( Ctor2<ConjugateOfWord,SMWord,SMWord>(),
	   Text("Compute the conjugate of") + Name(1) + Text("by") + Name(2)
	   );
    
    M.add( Ctor2<ConjugateOfWord,SMWord,SMWord>(true),
	   Text("Compute the conjugate of") + Name(2) + Text("by") + Name(1)
	   );
    
    M.add( Ctor2<CommutatorOfWords,SMWord,SMWord>(),
	   Text("Compute the commutator of") + Name(1) + Text("and") + Name(2)
	   );

    M.add( Ctor2<CommutatorOfWords,SMWord,SMWord>(true),
	   Text("Compute the commutator of") + Name(2) + Text("and") + Name(1)
	   );
    
    M.startItemGroup();
 
    M.separator();

    
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ABELIAN
		      );
 
    M.add( Ctor2<AbelianEqualityProblem, SMWord, SMWord>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );

    M.add( Ctor2<IsAbelianWordPowerOfSecond,SMWord,SMWord>(),
		Text("Is") + Name(1) + Text("a power of")
		   + Name(2) + Text("?")
		);

    M.add( Ctor2<IsAbelianWordPowerOfSecond,SMWord,SMWord>(true),
        	Text("Is") + Name(2) + Text("a power of")
		   + Name(1) + Text("?")
		   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::FREE
		      );
    
    M.add( Ctor2<WordsAreEqual,SMWord,SMWord>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );

   
    M.add( Ctor2<ConjugacyProblemInFree,SMWord,SMWord>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate in"
	   + Name( Parent(1) ) + "?"
	   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::FREE_NILPOTENT
		      );
  
    M.add( Ctor2<AreEltsEqual, SMWord, SMWord>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
    /* 
       M.addDisabled( Text("Are") + Name(1) + Text("and") + Name(2)
       + Text("conjugate in") + Name( Parent( 1 ) ) + Text("?")
       );
		   */
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      ( CheckinType( Parent(1) ) == SMFPGroup::AP_FREE ||
			CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
			)
		      );
    
    M.add( Ctor2<APOfFreeAreEqual,SMWord,SMWord>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::HNN_FREE );
    
    M.add( Ctor2<HNNofFreeGroup_AreEqual,SMWord,SMWord>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      (CheckinType( Parent(1) ) == SMFPGroup::FP ||
		       CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT
		       )
		      );
    
    M.add( Ctor2<AreEltsEqual,SMWord,SMWord>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );


    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT
		      );
    
    M.addDisabled( Text("Are") + Name(1) + Text("and") + Name(2)
		   + Text("conjugate in") + Name( Parent( 1 ) ) + Text("?")
		   );


    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );
    
    M.add( Ctor2<ORWithTorsionAreEltsEqual,SMWord,SMWord>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
    
    M.add( Ctor2<ORWithTorsionConjugacyProblem,SMWord,SMWord>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate in"
	   + Name( Parent(1) ) + "?"
	   );

    //@db & @au: temporary; to be included in the general CP problem
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR ||
		      CheckinType( Parent(1) ) == 
		      SMFPGroup::ONE_RELATOR_WITH_TORSION 
		      );
    
    M.add( Ctor2<GAConjugacyForORGroupProblem,SMWord,SMWord>(),
 	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate in OR group "
 	   + Name( Parent(1) ) + "?"
 	   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE &&
		      CheckinType( Parent(1) ) != SMFPGroup::ABELIAN &&
		      CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::AP_FREE_CYCLIC &&
		      CheckinType( Parent(1) ) != SMFPGroup::ONE_RELATOR_WITH_TORSION &&
		      CheckinType( Parent(1) ) != SMFPGroup::ONE_RELATOR &&
		      CheckinType( Parent(1) ) != SMFPGroup::HNN_FREE &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE
		      );
    
    M.add( Ctor2<ConjugacyProblem,SMWord,SMWord>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate in"
	   + Name( Parent(1) ) + "?"
	   );



    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::AP_FREE_CYCLIC
		      );
    
    M.add( Ctor2<APOfFreeCyclic_ConjugacyProblem,SMWord,SMWord>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate in"
	   + Name( Parent(1) ) + "?"
	   );
    
 
    M.add( Ctor2<APOfFreeCyclic_IsEltAProperPowerOfSecond,SMWord,SMWord>(),
	   Text("Is") + Name(1) + Text("a proper power of")
	   + Name(2) + Text("?")
	   );
    
    M.add( Ctor2<APOfFreeCyclic_IsEltAProperPowerOfSecond,SMWord,SMWord>(true),
	   Text("Is") + Name(2) + Text("a proper power of")
	   + Name(1) + Text("?")
	   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::HNN_FREE
		      );
    
    M.add( Ctor2<HNNofFreeGroup_ConjugacyProblem,SMWord,SMWord>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate in"
	   + Name( Parent(1) ) + "?"
	   );
    
 
    M.add( Ctor2<HNNofFreeGroup_IsProperPowerOfSecond,SMWord,SMWord>(),
	   Text("Is") + Name(1) + Text("a proper power of")
	   + Name(2) + Text("?")
	   );
    
    M.add( Ctor2<HNNofFreeGroup_IsProperPowerOfSecond,SMWord,SMWord>(true),
	   Text("Is") + Name(2) + Text("a proper power of")
	   + Name(1) + Text("?")
	   );

   
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE &&
		      CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( Parent(1) ) != SMFPGroup::AP_FREE_CYCLIC &&
		      CheckinType( Parent(1) ) != SMFPGroup::ABELIAN
		      );
    
    M.addDisabled( Text("Is") + Name(1) + Text("a proper power of")
		   + Name(2) + Text("?")
		   );
    
    M.addDisabled( Text("Is") + Name(2) + Text("a proper power of")
		   + Name(1) + Text("?")
		   );


    M.done();
  }
  
  {
    Menu2<SMHomomorphism,SMHomomorphism> M( Menu::TOOLS );
    
    
    
    M.startItemGroup( Range( 1 ) == Domain( 2 ) );
    
    M.add( Ctor2<ComposeMaps,SMHomomorphism,SMHomomorphism>(),
	   Text("Form the composition") + Name(2) + Text(Name(1))
	   );
    
    M.startItemGroup( Range( 2 ) == Domain( 1 ) );
    
    M.add( Ctor2<ComposeMaps,SMHomomorphism,SMHomomorphism>(true),
	   Text("Form the composition") + Name(1) + Text(Name(2))
	   );
    
    
    
    M.startItemGroup( Domain( 1 ) == Domain( 2 ) &&
		      CheckinType( Domain(1) ) != SMFPGroup::FREE );
    
    M.addDisabled( Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
		   );
    
    
    M.startItemGroup( Domain( 1 ) == Domain( 2 ) &&
		      CheckinType( Domain(1) ) == SMFPGroup::FREE );
    
    M.add( Ctor2<FreeAreHomsEqual,SMHomomorphism,SMHomomorphism>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
    
    M.done();
  }
  
  {
    Menu2<SMHomomorphism2,SMHomomorphism2> M( Menu::TOOLS );
    
    
    
    M.startItemGroup( Range( 1 ) == Domain( 2 ) );
    
    M.add( Ctor2<ComposeMaps,SMHomomorphism2,SMHomomorphism2>(),
	   Text("Form the composition") + Name(2) + Text(Name(1))
	   );
    
    
    
    M.startItemGroup( Range( 2 ) == Domain( 1 ) );
    
    M.add( Ctor2<ComposeMaps,SMHomomorphism2,SMHomomorphism2>(true),
	   Text("Form the composition") + Name(1) + Text(Name(2))
	   );

    
    
    M.startItemGroup( Domain(1) == Domain(2) &&
		      Range(1) == Range(2) &&
		      CheckinType( Domain(1) ) != SMFPGroup::FREE
		      );
	 
    M.addDisabled( Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
		   );
    

	 
    M.startItemGroup( Domain(1) == Domain(2) &&
		      Range(1) == Range(2) &&
		      CheckinType( Domain(1) ) == SMFPGroup::FREE
		      );
	 
    M.add( Ctor2<FreeAreHomsEqual,SMHomomorphism2,SMHomomorphism2>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );

	 
    
    M.done();
  }

  {
    Menu2<SMHomomorphism,SMHomomorphism2> M( Menu::TOOLS );
    
    M.startItemGroup( Range( 1 ) == Domain( 2 ) );
	 
    M.add( Ctor2<ComposeMaps,SMHomomorphism,SMHomomorphism2>(),
	   Text("Form the composition") + Name(2) + Text(Name(1))
	   );
	 
    M.startItemGroup( Range( 2 ) == Domain( 1 ) );
	 
    M.add( Ctor2<ComposeMaps,SMHomomorphism,SMHomomorphism2>(true),
	   Text("Form the composition") + Name(1) + Text(Name(2))
	   );
    
    M.done();
  }

  {
    Menu2<SMHomomorphism, SMWord> M( Menu::TOOLS );

    M.startItemGroup( Parent( 2 ) == Domain( 1 ) );
	 
    M.add( Ctor2<ImageUnderMap,SMHomomorphism,SMWord>(),
	   Text("Compute the image of") + Name(2) + "under" + Name(1)
	   );
	 
    M.done();
  }

  {
    Menu2<SMHomomorphism2, SMWord> M( Menu::TOOLS );

    M.startItemGroup( Parent( 2 ) == Domain( 1 ) );
	 
    M.add( Ctor2<ImageUnderMap,SMHomomorphism2,SMWord>(),
	   Text("Compute the image of") + Name(2) + "under" + Name(1)
	   );
	 
    M.done();
  }
  
  {
    Menu2<SMHomomorphism, SMSubgroup> M( Menu::TOOLS );

    M.startItemGroup( Parent( 2 ) == Domain( 1 ) );
	 
    M.add( Ctor2<SGImageUnderMap,SMHomomorphism,SMSubgroup>(),
	   Text("Compute the image of") + Name(2) + "under" + Name(1)
	   );
	 
    M.done();
  }

  {
    Menu2<SMHomomorphism2, SMSubgroup> M( Menu::TOOLS );

    M.startItemGroup( Parent( 2 ) == Domain( 1 ) );
	 
    M.add( Ctor2<SGImageUnderMap,SMHomomorphism2,SMSubgroup>(),
	   Text("Compute the image of") + Name(2) + "under" + Name(1)
	   );
	 
    M.done();
  }

  {
    Menu2<SMSubgroup,SMWord> M( Menu::TOOLS );


    M.startItemGroup( Parent( 1 ) == Parent( 2 )
		      && CheckinType( Parent(1) ) != SMFPGroup::FREE
		      && CheckinType( Parent(1) ) != SMFPGroup::ABELIAN
		      && CheckinType( Parent(1) ) != SMFPGroup::NILPOTENT
		      && CheckinType( Parent(1) ) != SMFPGroup::FREE_NILPOTENT
		      );

    M.add( Ctor2<SubgroupContainmentProblem,SMSubgroup,SMWord>(),
	   Text("Determine whether") + Name(2) + "lies in" + Name(1)
	   );
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::FP
		      );
    
    M.add( Ctor2<WordRepresentativeProblem, SMSubgroup,SMWord>(),
	   Text("Find the Schreier representative of ") + Name(2) +
	   " modulo " + Name( 1 )
	   );	 

    M.add( Ctor2<SGRewriteWordProblem,SMSubgroup,SMWord>(),
	   Text("Rewrite") + Name(2) + " in terms of Schreier generators of " + Name( 1 )
	   );	 
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ABELIAN
		      );
    
    M.add( Ctor2<WordInSGOfAbelian, SMSubgroup, SMWord>(),
	   Text("Is") + Name(2) + "in" + Name(1) + "?"
	   );
    
    M.add( Ctor2<AbelianEltPowerSubgr,SMSubgroup,SMWord>(),
	   Text("Compute the order of") + Name(2) + "modulo" + Name(1)
	   );


    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT
		      );
    
    M.add( Ctor2<SGOfNGWordContainProblem,SMSubgroup,SMWord>(),
	   Text("Determine whether") + Name(2)
	   + Text("lies in") + Name(1)
	   );
    M.add( Ctor2<SGOfNGDecomposeWordProblem,SMSubgroup,SMWord>(),
	   Text("Decompose") + Name(2) +"in terms of a basis of "
	   + Name(1)
	   );
	   
    M.addDisabled( Text("Is a power of") + Name(2) + "in" + Name(1) + "?" 
		   );


    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::FREE
		      );
    
    M.add( Ctor2<WordInSGOfFree,SMSubgroup,SMWord>(),
	   Text("Does") + Name(2) + "represent an element of"
	   + Name(1) + "?"
	   );
    
    M.add( Ctor2<PowerOfWordInSGOfFree,SMSubgroup,SMWord>(),
	   Text("Does a power of") + Name(2) + "represent an element of"
	   + Name(1) + "?"
	   );
    
    M.add( Ctor2<ConjugateOfWordInSGOfFree,SMSubgroup,SMWord>(),
	   Text("Does a conjugate of") + Name(2)
	   + "represent an element of"
	   + Name(1) + "?"
	   );
    
    M.separator();
    
    M.add( Ctor2<WordInNielsenBasisSGOfFree,SMSubgroup,SMWord>(),
	   Text("Find the canonical decomposition of") + Name(2)
	   + "in the Nielsen basis for" + Name(1)
	   );

    M.add( Ctor2<SchreierRepOfWordInSGOfFree,SMSubgroup,SMWord>(),
	   Text("Compute the right Schreier representative of") + Name(2)
	   + "mod" + Name(1)
	   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::FREE_NILPOTENT
		      );
    
    M.add( Ctor2<SGOfNGWordContainProblem,SMSubgroup,SMWord>(),
	   Text("Determine whether") + Name(2)
	   + Text("lies in") + Name(1)
	   );

    M.add( Ctor2<SGOfNGDecomposeWordProblem,SMSubgroup,SMWord>(),
	   Text("Decompose") + Name(2) +"in terms of a basis of "
	   + Name(1)
	   );
	   
    M.addDisabled(
	   Text("Does a power of") + Name(2) + "represent an element of"
	   + Name(1) + "?"
	   );
    
    M.addDisabled(
	   Text("Does a conjugate of") + Name(2)
	   + "represent an element of"
	   + Name(1) + "?"
	   );


    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR
		      );
    
    M.add( Ctor2<ORExtendedWordProblem,SMSubgroup,SMWord>(),
	   Text("Does") + Name(2) + "represent an element of Magnus subgroup"
	   + Name(1) + "?"
	   );
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
		      );
    
    M.add( Ctor2<ORWithTorsionExtendedWordProblem,SMSubgroup,SMWord>(),
	   Text("Does") + Name(2) + "represent an element of Magnus subgroup"
	   + Name(1) + "?"
	   );
    
    M.done();
  }
  
  {
    Menu2<SMSubgroup,SMSubgroup> M( Menu::TOOLS );
	 


    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::ABELIAN
		      );
	 
    M.add( Ctor2<AbelianSGContainmentProblem,SMSubgroup,SMSubgroup>(),
	   Text("Does") + Name(1) + "contain" + Name(2) + "?"
	   );

    M.add( Ctor2<AbelianSGContainmentProblem,SMSubgroup,SMSubgroup>(true),
	   Text("Does") + Name(2) + "contain" + Name(1) + "?"
	   );
	 
    M.add( Ctor2<AbelianIsIsomorphicSG,SMSubgroup,SMSubgroup>(),
	   Text("Is ") + Name(1) + " isomorphic to " + Name(2) + "?"
	   );
    
    M.add( Ctor2<AbelianSGEqualityProblem,SMSubgroup,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
    
    M.separator();

    M.add( Ctor2<AbelianSGJoin,SMSubgroup,SMSubgroup>(),
	   Text("Compute the join of") + Name(1) + "and" + Name(2)
	   );
    
    M.add( Ctor2<AbelianSGIntersectionProblem,SMSubgroup,SMSubgroup>(),
	   Text("Compute the intersection of") + Name(1)
	   + "and" + Name(2)
	   );

   M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::FREE_NILPOTENT
		      );
	 
   M.add( Ctor2<SGOfNGcontainSubgroupProblem,SMSubgroup,SMSubgroup>(),
	   Text("Does") + Name(1) + "contain" + Name(2) + "?"
	   );

    M.add( Ctor2<SGOfNGcontainSubgroupProblem,SMSubgroup,SMSubgroup>( true ),
	   Text("Does") + Name(2) + "contain" + Name(1) + "?"
	   );

    M.add( Ctor2<SGOfNGequalSubgroupProblem,SMSubgroup, SMSubgroup>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
	  
    M.addDisabled(
	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate ?"
	   );
	 
    M.separator();

    M.add( Ctor2<SGOfNGjoinSubgroupProblem,SMSubgroup, SMSubgroup>(),
	   Text("Compute the join of") + Name(1) + "and" + Name(2)
	   );
    
    M.addDisabled(
	   Text("Compute the intersection of") + Name(1) + "and" + Name(2)
	   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::NILPOTENT
		      );
	 
    M.add( Ctor2<SGOfNGcontainSubgroupProblem,SMSubgroup,SMSubgroup>(),
	   Text("Does") + Name(1) + "contain" + Name(2) + "?"
	   );

    M.add( Ctor2<SGOfNGcontainSubgroupProblem,SMSubgroup,SMSubgroup>( true ),
	   Text("Does") + Name(2) + "contain" + Name(1) + "?"
	   );

    M.add( Ctor2<SGOfNGequalSubgroupProblem,SMSubgroup, SMSubgroup>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
	   
    M.separator();

    M.add( Ctor2<SGOfNGjoinSubgroupProblem,SMSubgroup, SMSubgroup>(),
	   Text("Compute the join of") + Name(1) + "and" + Name(2)
	   );

    M.startItemGroup( Parent( 1 ) == Parent( 2 ) &&
		      CheckinType( Parent(1) ) == SMFPGroup::FREE
		      );
	 
    M.add( Ctor2<SGOfFreeContainment,SMSubgroup,SMSubgroup>(),
	   Text("Does") + Name(1) + "contain" + Name(2) + "?"
	   );

    M.add( Ctor2<SGOfFreeContainment,SMSubgroup,SMSubgroup>(true),
	   Text("Does") + Name(2) + "contain" + Name(1) + "?"
	   );

    M.add( Ctor2<SGOfFreeAreEqual,SMSubgroup,SMSubgroup>(),
	   Text("Is") + Name(1) + Text("=") + Name(2) + Text("?")
	   );
 
    M.add( Ctor2<SGOfFreeContainsConjugate,SMSubgroup,SMSubgroup>(),
	   Text("Does") + Name(1) + "contain a conjugate of" +
	   Name(2) + "?"
	   );
	 
    M.add( Ctor2<SGOfFreeContainsConjugate,SMSubgroup,SMSubgroup>(true),
	   Text("Does") + Name(2) + "contain a conjugate of"
	   + Name(1) + "?"
	   );

    M.add( Ctor2<SGOfFreeConjugateTo,SMSubgroup,SMSubgroup>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "conjugate ?"
	   );
	 
    M.separator();

    M.add( Ctor2<SGOfFreeJoin,SMSubgroup,SMSubgroup>(),
	   Text("Compute the join of") + Name(1) + "and" + Name(2)
	   );

    M.add( Ctor2<SGOfFreeIntersection,SMSubgroup,SMSubgroup>(),
	   Text("Compute the intersection of") + Name(1) + "and" + Name(2)
	   );


	 
    M.done();
  }

  {
    Menu2<SMFPGroup,SMFPGroup> M( Menu::TOOLS );

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN &&
		      CheckinType( 2 ) == SMFPGroup::ABELIAN
		      );

    M.add( Ctor2<AbelianIsomProblem,SMFPGroup,SMFPGroup>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "isomorphic ?"
	   );
   
    M.startItemGroup( ( CheckinType( 1 ) == SMFPGroup::NILPOTENT &&
			CheckinType( 2 ) == SMFPGroup::NILPOTENT ) ||
		      ( CheckinType( 1 ) == SMFPGroup::FP &&
			CheckinType( 2 ) == SMFPGroup::FP )
		      );
    
    M.add( Ctor2<NGIsomorphismProblem,SMFPGroup,SMFPGroup>(),
	   Text("Are") + Name(1) + "and" + Name(2) + "isomorphic ?"
	   );

    M.startItemGroup( ( CheckinType( 1 ) == SMFPGroup::FP ||
			CheckinType( 1 ) == SMFPGroup::FREE ) &&
		      ( CheckinType( 2 ) == SMFPGroup::FP ||
			CheckinType( 2 ) == SMFPGroup::FREE )
		      );
    
    M.add( Ctor2<TotalHomEnumeratorProblem,SMFPGroup,SMFPGroup>(),
	   Text("Totally enumerate homomorphisms from ") + Name(1) +
	   "to" + Name(2)
	   );
    
    M.add( Ctor2<TotalHomEnumeratorProblem,SMFPGroup,SMFPGroup>(true),
	   Text("Totally enumerate homomorphisms from ") + Name(2) +
	   "to" + Name(1)
	   );
    
    M.add( Ctor2<RandHomEnumeratorProblem,SMFPGroup,SMFPGroup>(),
	   Text("Randomly enumerate homomorphisms from ") + Name(1) +
	   "to" + Name(2)
	   );
    
    M.add( Ctor2<RandHomEnumeratorProblem,SMFPGroup,SMFPGroup>(true),
	   Text("Randomly enumerate homomorphisms from ") + Name(2) +
	   "to" + Name(1)
	   );

    M.done();
  }


  {
    Menu1< SMList<Word> > M( Menu::TOOLS );
    
    M.startItemGroup( );
    
    M.add( Ctor1<WordsOfLength, SMList<Word> >(),
	   Text("Extract words of a given length from ") + Name(1)
	   );	 
   
    M.add( Ctor1<SMListExtractTrivialWords, SMList<Word> >(),
	   Text("Extract trivial words from ") + Name(1)
	   );	  

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE );
    
    M.add( Ctor1<SMListExtractProperPowerInFree, SMList<Word> >(),
	   Text("Extract proper powers from ") + Name(1)
	   );	  
  
    M.add( Ctor1<SMListExtractCommutatorsInFree, SMList<Word> >(),
	   Text("Extract commutators from ") + Name(1)
	   );	  

    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FP );
    
    M.add( Ctor1<SMListExtractCentralWords, SMList<Word> >(),
	   Text("Extract central words from ") + Name(1)
	   );	    

    M.done();
  }

  {
    Menu1< SMList<Subgroup> > M( Menu::TOOLS );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE ||
		      CheckinType( Parent(1) ) == SMFPGroup::FP );
    
    M.add( Ctor1<SGListExtractOfIndex, SMList<Subgroup> >(),
	   Text("Extract subgroups of a given index from ") + Name(1)
	   );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE );
    
    M.add( Ctor1<SGListExtractNormal, SMList<Subgroup> >(),
	   Text("Extract normal subgroups from ") + Name(1)
	   );	 
    
    M.add( Ctor1<SGListExtractMalnormal, SMList<Subgroup> >(),
	   Text("Extract malnormal subgroups from ") + Name(1)
	   );	 
    
    M.add( Ctor1<SGListExtractOfRank, SMList<Subgroup> >(),
	   Text("Extract subgroups of a given rank from ") + Name(1)
	   );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FP );
    
    M.add( Ctor1<SMListExtractTrivialSubgroups, SMList<Subgroup> >(),
	   Text("Extract trivial subgroups from ") + Name(1)
	   );	  

     M.add( Ctor1<SMListExtractAbelianSubgroups, SMList<Subgroup> >(),
	   Text("Extract abelian subgroups from ") + Name(1)
	   );	    

     M.add( Ctor1<SMListExtractCentralSubgroups, SMList<Subgroup> >(),
	    Text("Extract central subgroups from ") + Name(1)
	    );	    
     
     M.done();
  }

 {
    Menu1< SMList<Map> > M( Menu::TOOLS );
    
    M.startItemGroup( CheckinType( Parent(1) ) == SMFPGroup::FREE );
    
    M.add( Ctor1<MapListExtractIAauto, SMList<Map> >(),
	   Text("Extract IA-automorphisms from ") + Name(1)
	   );
    
   
    M.add( Ctor1<MapListExtractInner, SMList<Map> >(),
	   Text("Extract inner automorphisms from ") + Name(1)
	   );

    M.done();
  }

  {
    Menu2< SMList<Word>, SMList<Word>  > M( Menu::TOOLS );
    
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) );
    
    M.add( Ctor2<SMListJoin<Word>, SMList<Word>, SMList<Word> >(),
	   Text("Compute the join of ") + Name(1) + Text(" and ") + Name(2)
	   );	 
    
    M.done();
  }

 {
    Menu2< SMList<Subgroup>, SMList<Subgroup>  > M( Menu::TOOLS );
    
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) );
    
    M.add( Ctor2<SMListJoin<Subgroup>, SMList<Subgroup>, SMList<Subgroup> >(),
	   Text("Compute the join of ") + Name(1) + Text(" and ") + Name(2)
	   );	 

    M.done();
  }

  {
    Menu2< SMList<Map>, SMList<Map>  > M( Menu::TOOLS );
    
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) );
    
    M.add( Ctor2<SMListJoin<Map>, SMList<Map>, SMList<Map> >(),
	   Text("Compute the join of ") + Name(1) + Text(" and ") + Name(2)
	   );	 
    
    M.done();
  }
 
 {
   Menu2<SMList<Word>,SMWord> M( Menu::TOOLS );
    
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) );
    
    M.add( Ctor2<IsWordInList, SMList<Word>,SMWord>(),
	   Text("Determine whether") + Name(2)
	   + Text("lies in") + Name(1)
	   );	 
    
    M.done();
  }
 {
    Menu2<SMList<Subgroup>,SMSubgroup> M( Menu::TOOLS );
    
    
    M.startItemGroup( Parent( 1 ) == Parent( 2 ) );
    
    M.add( Ctor2<IsSubgroupInList, SMList<Subgroup>,SMSubgroup>(),
	   Text("Determine whether") + Name(2)
	   + Text("lies in") + Name(1)
	   );	 
    
    M.done();
  }
 {
    Menu2<SMList<Map>,SMMap> M( Menu::TOOLS );
    
    
    M.startItemGroup(  Domain(2) == Parent( 1 ) );
    
    M.add( Ctor2<IsMapInList, SMList<Map>,SMMap>(),
	   Text("Determine whether") + Name(2)
	   + Text("lies in") + Name(1)
	   );	 
    
    M.done();
  }
 {
    Menu2<SMList<Map>,SMHomomorphism> M( Menu::TOOLS );
    
    
     M.startItemGroup(  Domain(2) == Parent( 1 ) );
    
    M.add( Ctor2<IsMapInList, SMList<Map>,SMHomomorphism>(),
	   Text("Determine whether") + Name(2)
	   + Text("lies in") + Name(1)
	   );	 
    
    M.done();
  }

}


// ----------------- ObjectSmith::outputMakeMenuDefns ---------------------- //


void ObjectSmith::outputMakeMenuDefns(ostream& ostr)
{
  {
    Menu1<SMFPGroup> M( Menu::MAKE );
    


    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::ABELIAN );
    
    M.add( Ctor1<MakeCyclicDecomposition, SMFPGroup>( ),
	   Text("Canonical presentation of") + Name(1)
	   );


    
    M.startItemGroup();
    
    M.add( ReadMakeQuotientItem(),
	   Text("Quotient of") + Name(1),
	   DefineSetOfRelators()
	   );



    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::ABELIAN );

    M.add( Ctor1<MakeAbelianQuotient, SMFPGroup>(),
	   Text("Abelian Quotient of") + Name(1)
	   );



    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::ABELIAN
		      );
    
    M.add( ReadMakeNilpotentQuotientItem(),
	   Text("Nilpotent Quotient of") + Name(1),
	   DefineInt("Enter the nilpotency class: ", 1)
	   );


    
    M.startItemGroup();

    M.separator();

    /*@db
    M.addDisabled( Text("Another Presentation for") + Name(1)
		   );
    */

    M.add( Ctor1<TTProblem, SMFPGroup>(),
	   Text("Another Presentation of") + Name(1)
	   );

    M.add( Ctor1<MakeRipsConstruction, SMFPGroup>(),
	   Text("Rips construction of") + Name(1)
	   );
 

    M.done();
  }

  {
    Menu4<SMFPGroup, SMFPGroup, SMSubgroup, SMSubgroup> M( Menu::MAKE );



    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE &&
		      CheckinType( 2 ) == SMFPGroup::FREE &&
		      ( Parent(3) == Oid(1) || Parent(3) == Oid(2) ) &&
		      ( Parent(4) == Oid(1) || Parent(4) == Oid(2) ) &&
		      Parent(3) != Parent(4)
		      );

    M.add( Ctor4<MakeAPOfFree, SMFPGroup, SMFPGroup,
	   SMSubgroup, SMSubgroup> (),
	   Text("Amalgamated Product")
	   );

    
    
    M.done();
  }

  { 
    Menu3<SMFPGroup, SMSubgroup, SMSubgroup> M( Menu::MAKE );

    M.startItemGroup( CheckinType( 1 ) == SMFPGroup::FREE
		      && Parent(2) == Oid(1) && Parent(3) == Oid(1) 
		      );

    M.add( Ctor3<MakeHNNExtOfFreeGroup,SMFPGroup,SMSubgroup,SMSubgroup>(), 
	   Text("HNN-extension")
	   );

    M.done();
  }

  {
    Menu2<SMFPGroup, SMFPGroup> M( Menu::MAKE );
    
    M.startItemGroup( CheckinType( 1 ) != SMFPGroup::NILPOTENT &&
		      CheckinType( 2 ) != SMFPGroup::NILPOTENT &&
		      CheckinType( 1 ) != SMFPGroup::FREE_NILPOTENT &&
		      CheckinType( 2 ) != SMFPGroup::FREE_NILPOTENT
		      );

    M.add( Ctor2<MakeFreeProduct,SMFPGroup,SMFPGroup>(), 
	   Text("Make free product ")+Name(1)+Text("*")+Name(2)
	   );
    
    M.add( Ctor2<MakeDirectProduct,SMFPGroup,SMFPGroup>(), 
	   Text("Make direct product")+Name(1)+Text("X")+Name(2)
	   );
    
    M.done();
    
  }

  {
    Menu1< EnumeratorProblem< Word > > M( Menu::MAKE );
    
    M.startItemGroup( );
    ostrstream o;
    o << "Make list of words from \\\"" 
      << Name(1) 
      << "\\\"" << ends;
  
    M.add( Ctor1<MakeSMListOf<Word>,EnumeratorProblem< Word > >(), 
	   Text( o.str() )
	   );
    
    M.done();
    
  }
  {
    Menu1< EnumeratorProblem< Subgroup > > M( Menu::MAKE );
    
    M.startItemGroup( );
    
    ostrstream o;
    o << "Make list of subgroups from \\\"" 
      << Name(1) 
      << "\\\"" << ends;
    M.add( Ctor1<MakeSMListOf<Subgroup>,EnumeratorProblem< Subgroup > >(), 
	   Text(o.str())
	   );
    
    M.done();
    
  }
  {
    Menu1< EnumeratorProblem< Map > > M( Menu::MAKE );

    M.startItemGroup( );
    
    ostrstream o;
    o << "Make list of maps from \\\"" 
      << Name(1) 
      << "\\\"" << ends;
    M.add( Ctor1<MakeSMListOf<Map>,EnumeratorProblem< Map > >(), 
	   Text(o.str())
	   );
    
    M.done();
    
  }
  /* @db buggy !
  {
    Menu2<SMFPGroup, SMSubgroup> M( Menu::MAKE );
    
    M.startItemGroup( ( CheckinType( 1 ) == SMFPGroup::FREE
			|| CheckinType( 1 ) == SMFPGroup::FP
			|| CheckinType( 1 ) == SMFPGroup::ABELIAN 
			|| CheckinType( 1 ) == SMFPGroup::AP_FREE
			|| CheckinType( 1 ) == SMFPGroup::AP_FREE_CYCLIC
			|| CheckinType( 1 ) == SMFPGroup::SMALL_CANCELLATION
			|| CheckinType( 1 ) == SMFPGroup::ONE_RELATOR 
			|| CheckinType( 1 ) == SMFPGroup::ONE_RELATOR_WITH_TORSION
			|| CheckinType( 1 ) == SMFPGroup::HNN_FREE
		      )
		      && Parent(2) == Oid(1) );

    M.add( Ctor2<MakeFactorGroup,SMFPGroup,SMSubgroup>(), 
	   Text("Make a factor group ")+Name(1)+Text("/")+Name(2)
	   );

    M.done();
    
  }
  */
}


// --------------- ObjectSmith::outputTestingMenuDefns -------------------- //


void ObjectSmith::outputTestingMenuDefns(ostream& ostr)
{
  {
    Menu0 M( Menu::TESTING );

    M.startItemGroup( );
    
    M.addDisabled( "Nothing" );

    M.done();
  }
}

