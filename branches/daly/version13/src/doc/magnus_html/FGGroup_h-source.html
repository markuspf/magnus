<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/Group/include/FGGroup.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/Group/include/FGGroup.h</h1><a href="FGGroup_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> *   $Id: FGGroup.h,v 1.4 1996/11/15 22:13:00 alex Exp $</font>
00003 <font class="comment"> */</font>
00004 
00005 <font class="comment">// Copyright (C) 1994 The New York Group Theory Cooperative</font>
00006 <font class="comment">// See magnus/doc/COPYRIGHT for the full notice.</font>
00007 
00008 <font class="comment">// Contents: Definition of the FGGroup class.</font>
00009 <font class="comment">//</font>
00010 <font class="comment">// Principal Authors: Stephane Collart, Roger Needham</font>
00011 <font class="comment">//</font>
00012 <font class="comment">// Status: in progress</font>
00013 <font class="comment">//</font>
00014 <font class="comment">// Revision History:</font>
00015 <font class="comment">//</font>
00016 <font class="comment">// Special Notes:</font>
00017 <font class="comment">//</font>
00018 <font class="comment">// Questions:</font>
00019 <font class="comment">//</font>
00020 <font class="comment">// * methods which may enhance a group, such as wordProblem(), are const,</font>
00021 <font class="comment">//   to permit application to const objects;</font>
00022 <font class="comment">//</font>
00023 <font class="comment">// 07/96 Alexey M. implemented IPC tools</font>
00024 
00025 <font class="preprocessor">#ifndef _FINITELY_GENERATED_GROUP_H_</font>
00026 <font class="preprocessor"></font><font class="preprocessor">#define _FINITELY_GENERATED_GROUP_H_</font>
00027 <font class="preprocessor"></font>
00028 
00029 <font class="preprocessor">#include "<a class="code" href="DerivedObjectOf_h.html">DerivedObjectOf.h</a>"</font>
00030 <font class="preprocessor">#include "<a class="code" href="Group_h.html">Group.h</a>"</font>
00031 <font class="preprocessor">#include "<a class="code" href="FGGroupRep_h.html">FGGroupRep.h</a>"</font>
00032 
00033 
00034 <font class="keyword">class </font><a class="code" href="class_Subgroup.html">Subgroup</a>; <font class="comment">// Doesn't exist yet.</font>
00035 
00036 
<a name="l00037"></a><a class="code" href="class_FGGroup.html">00037</a> <font class="keyword">class </font><a class="code" href="class_FGGroup.html">FGGroup</a> : <font class="keyword">public</font> <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;Group,FGGroupRep&gt; {
00038   
00039 <font class="keyword">public</font>:
00040   <font class="comment"></font>
00041 <font class="comment">  ///////////////////////////////////////////////////////</font>
00042 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00043   <font class="comment">//  Constructors                                     //</font>
00044   <font class="comment">//                                                   //</font><font class="comment"></font>
00045 <font class="comment">  ///////////////////////////////////////////////////////</font>
00046 <font class="comment"></font>
00047   <font class="comment">// No default constructor for pseudo-abstract class.</font>
00048   <font class="comment">// Copy constructor, operator=, and destructor supplied by compiler.</font>
00049 
<a name="l00050"></a><a class="code" href="class_FGGroup.html#a0">00050</a>   <a class="code" href="class_FGGroup.html#a0">FGGroup</a>( <font class="keyword">const</font> <a class="code" href="class_Group.html">Group</a>&amp; g ) : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Group.html">Group</a>,<a class="code" href="struct_FGGroupRep.html">FGGroupRep</a>&gt;( g ) { }
00051   <font class="comment">// cast constructor: to cast an arbitrary group as an FG group</font>
00052   <font class="comment">// NB. This rewraps the unchanged representation, hence is in general</font>
00053   <font class="comment">// only useful for casting a group known to be an actual FG group.</font>
00054   <font class="comment"></font>
00055 <font class="comment">  ///////////////////////////////////////////////////////</font>
00056 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00057   <font class="comment">//  Accessors                                        //</font>
00058   <font class="comment">//                                                   //</font><font class="comment"></font>
00059 <font class="comment">  ///////////////////////////////////////////////////////</font>
00060 <font class="comment"></font>
<a name="l00061"></a><a class="code" href="class_FGGroup.html#d0">00061</a>   <font class="keyword">static</font> <a class="code" href="class_Type.html">Type</a> <a class="code" href="class_FGGroup.html#d0">type</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="struct_FGGroupRep.html#d0">FGGroupRep::type</a>(); }
00062   <font class="comment">// dominates Group::type();</font>
00063 
00064   <font class="comment">// Inherited from Group:</font>
00065   <font class="comment">//  Type actualType() const; // pseudo-virtual</font>
00066 
<a name="l00067"></a><a class="code" href="class_FGGroup.html#a1">00067</a>   <font class="keywordtype">int</font> <a class="code" href="class_FGGroup.html#a1">numberOfGenerators</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;theNumberOfGenerators; }
00068   
00069   <a class="code" href="class_Chars.html">Chars</a> <a class="code" href="class_FGGroup.html#a2">nameOfGenerator</a>(<font class="keywordtype">int</font> i) <font class="keyword">const</font>;
00070   <font class="comment">// Returns print name of (i + 1)th generator. Zero-based indexing.</font>
00071   <font class="comment">// No negative i's; does not return print names of formal inverses.</font>
00072   <font class="comment">// @rn Take a Generator instead?</font>
00073 
00074   <a class="code" href="class_Chars.html">Chars</a> <a class="code" href="class_FGGroup.html#a2">nameOfGenerator</a>(<a class="code" href="class_Generator.html">Generator</a> g) <font class="keyword">const</font>; <font class="comment">//@rn</font>
00075 
<a name="l00076"></a><a class="code" href="class_FGGroup.html#a4">00076</a>   <a class="code" href="class_VectorOf.html">VectorOf&lt;Chars&gt;</a> <a class="code" href="class_FGGroup.html#a4">namesOfGenerators</a>( )<font class="keyword"> const </font>{
00077          <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;theNamesOfGenerators;
00078   }
00079   <font class="comment">// Returns vector of print names of all generators, in the order of</font>
00080   <font class="comment">// their ordinals.</font>
00081 <font class="comment"></font>
00082 <font class="comment">  ///////////////////////////////////////////////////////</font>
00083 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00084   <font class="comment">//  Group structure methods                          //</font>
00085   <font class="comment">//                                                   //</font><font class="comment"></font>
00086 <font class="comment">  ///////////////////////////////////////////////////////</font>
00087 <font class="comment"></font>
00088   <font class="comment">// Inherited from Group:</font>
00089   <font class="comment">// int order( ) const; // pseudo-virtual</font>
00090   <font class="comment">// Trichotomy isTrivial( ) const; // pseudo-virtual</font>
00091   <font class="comment">// Trichotomy isFinite( ) const; // pseudo-virtual</font>
00092   <font class="comment">// Trichotomy isInfinite( ) const; // pseudo-virtual</font>
00093   <font class="comment">// Trichotomy isAbelian( ) const; // pseudo-virtual</font>
00094 <font class="comment"></font>
00095 <font class="comment">  ///////////////////////////////////////////////////////</font>
00096 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00097   <font class="comment">//  Methods which deal with group elements           //</font>
00098   <font class="comment">//                                                   //</font><font class="comment"></font>
00099 <font class="comment">  ///////////////////////////////////////////////////////</font>
00100 <font class="comment"></font>
00101   <font class="comment">// Inherited from Group:</font>
00102   <font class="comment">// Elt makeIdentity( ) const; // pseudo-virtual</font>
00103   <font class="comment">// Bool isSyntacticIdentity(const Elt&amp; e) const; // pseudo-virtual</font>
00104   <font class="comment">// Trichotomy isTrivialElt( const Elt&amp; e ) const; // pseudo-virtual</font>
00105   <font class="comment">// Trichotomy areEqual(const Elt&amp; e1, const Elt&amp; e2) const; // pseudo-virtual</font>
00106   <font class="comment">// Elt firstElt( ) const; // pseudo-virtual</font>
00107   <font class="comment">// Elt nextElt(const Elt&amp; e) const; // pseudo-virtual</font>
00108   <font class="comment">// Elt multiply(const Elt&amp; e1, const Elt&amp; e2) const; // pseudo-virtual</font>
00109   <font class="comment">// Elt inverseOf(const Elt&amp; e) const; // pseudo-virtual</font>
00110   <font class="comment">// Elt raiseToPower(const Elt&amp; e, int n) const; // pseudo-virtual</font>
00111   <font class="comment">// Elt conjugateBy(const Elt&amp; e1, const Elt&amp; e2) const; // pseudo-virtual</font>
00112   <font class="comment">// Elt commutator(const Elt&amp; e1, const Elt&amp; e2) const; // pseudo-virtual</font>
00113   
<a name="l00114"></a><a class="code" href="class_FGGroup.html#a5">00114</a>   <a class="code" href="class_Elt.html">Elt</a> <a class="code" href="class_FGGroup.html#a5">eval</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;eval(w); }
00115   <font class="comment">// Takes a word and evaluates it as a formal word in the generators</font>
00116   <font class="comment">// of the group. Returns a (possibly canonic) representative of the</font>
00117   <font class="comment">// element. This method is pseudo-virtual.</font>
00118 
<a name="l00119"></a><a class="code" href="class_FGGroup.html#a6">00119</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="class_FGGroup.html#a6">wordProblem</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> const </font>{
00120          <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b1">enhance</a>()-&gt;wordProblem(w);
00121   }
00122   <font class="comment">// Returns YES if w represents the identity, NO if not, and</font>
00123   <font class="comment">// DONTKNOW if no answer can be determined.</font>
00124 
<a name="l00125"></a><a class="code" href="class_FGGroup.html#a7">00125</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="AP-fixups_h.html#a11">conjugacyProblem</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; v )<font class="keyword"> const </font>{
00126          <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b1">enhance</a>()-&gt;conjugacyProblem(u, v);
00127   }
00128   <font class="comment">// Returns YES if u and v represent conjugate elements, NO if not, and</font>
00129   <font class="comment">// DONTKNOW if no answer can be determined.</font>
00130 <font class="comment"></font>
00131 <font class="comment">  ///////////////////////////////////////////////////////</font>
00132 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00133   <font class="comment">//  Methods which deal with sets of group elements   //</font>
00134   <font class="comment">//                                                   //</font><font class="comment"></font>
00135 <font class="comment">  ///////////////////////////////////////////////////////</font>
00136 <font class="comment"></font>
00137   <font class="comment">// Inherited from Group:</font>
00138   <font class="comment">// SetOf&lt;Elt&gt; setMultiply(const SetOf&lt;Elt&gt;&amp; S1, const SetOf&lt;Elt&gt;&amp; S2) const;</font>
00139   <font class="comment">// SetOf&lt;Elt&gt; setMultiply(const Elt&amp; e, const SetOf&lt;Elt&gt;&amp; S) const;</font>
00140   <font class="comment">// SetOf&lt;Elt&gt; setMultiply(const SetOf&lt;Elt&gt;&amp; S, const Elt&amp; e) const;</font>
00141   <font class="comment">// SetOf&lt;Elt&gt; conjugateBy(const SetOf&lt;Elt&gt;&amp; S1, const SetOf&lt;Elt&gt;&amp; S2) const;</font>
00142   <font class="comment">// SetOf&lt;Elt&gt; conjugateBy(const Elt&amp; e, const SetOf&lt;Elt&gt;&amp; S) const;</font>
00143   <font class="comment">// SetOf&lt;Elt&gt; conjugateBy(const SetOf&lt;Elt&gt;&amp; S, const Elt&amp; e) const;</font>
00144   <font class="comment">// void closeUnderInverses(SetOf&lt;Elt&gt;&amp; S) const;</font>
00145 
00146   <font class="keywordtype">void</font> <a class="code" href="Word_h.html#a3">closeUnderCyclicPermutations</a>(<a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; S) <font class="keyword">const</font>;
00147   <font class="comment">// Alters S so that if w is in S, then any cyclic permutation of w is too.</font>
00148 <font class="comment"></font>
00149 <font class="comment">  ///////////////////////////////////////////////////////</font>
00150 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00151   <font class="comment">//  I/O                                              //</font>
00152   <font class="comment">//                                                   //</font><font class="comment"></font>
00153 <font class="comment">  ///////////////////////////////////////////////////////</font>
00154 <font class="comment"></font>
00155   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_FGGroup.html#a9">readWord</a>(istream&amp; istr, <a class="code" href="class_Chars.html">Chars</a>&amp; errMesg) <font class="keyword">const</font>;
00156   <font class="comment">// Tries to parse and return a Word from istr. At present, the word</font>
00157   <font class="comment">// in istr must end in ',', so the parser knows when to stop.</font>
00158   <font class="comment">// If there is a parse error, a message is returned in errMesg,</font>
00159   <font class="comment">// and the empty Word is returned.</font>
00160 
00161   <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a> <a class="code" href="class_FGGroup.html#a10">readSetOfWords</a>(istream&amp; istr, <a class="code" href="class_Chars.html">Chars</a>&amp; errMesg) <font class="keyword">const</font>;
00162   <font class="comment">// Tries to parse and return a set of Words, delimited by '{', '}' and</font>
00163   <font class="comment">// comma-separated, from istr.</font>
00164   <font class="comment">// If there is a parse error, a message is returned in errMesg,</font>
00165   <font class="comment">// and the empty set is returned.</font>
00166 
00167   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> <a class="code" href="class_FGGroup.html#a11">readVectorOfWords</a>(istream&amp; istr, <a class="code" href="class_Chars.html">Chars</a>&amp; errMesg) <font class="keyword">const</font>;
00168   <font class="comment">// Tries to parse and return a set of Words, delimited by '{', '}' and</font>
00169   <font class="comment">// comma-separated, from istr.</font>
00170   <font class="comment">// If there is a parse error, a message is returned in errMesg,</font>
00171   <font class="comment">// and the empty set is returned.</font>
00172 
<a name="l00173"></a><a class="code" href="class_FGGroup.html#a12">00173</a>   <font class="keywordtype">void</font> <a class="code" href="class_FGGroup.html#a12">printGenerator</a>( ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; g )<font class="keyword"> const </font>{
00174          <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;printGenerator( ostr, ord(g) );
00175   }
00176   <font class="comment">// Outputs the print name of g on ostr, followed by "^-1" if ord(g) &lt; 0.</font>
00177 
<a name="l00178"></a><a class="code" href="class_FGGroup.html#a13">00178</a>   <font class="keywordtype">void</font> <a class="code" href="class_FGGroup.html#a13">printGenerators</a>( ostream&amp; ostr )<font class="keyword"> const </font>{
00179          <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;printGenerators( ostr );
00180   }
00181   <font class="comment">// Calls printGenerator for each generator of this group, separating</font>
00182   <font class="comment">// them with commas.</font>
00183 
<a name="l00184"></a><a class="code" href="class_FGGroup.html#a14">00184</a>   <font class="keywordtype">void</font> <a class="code" href="class_FGGroup.html#a14">printWord</a>( ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> const </font>{
00185          <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;printWord( ostr, w );
00186   }
00187   <font class="comment">// Outputs w to ostr, in a form that can input by readWord.</font>
00188 
<a name="l00189"></a><a class="code" href="class_FGGroup.html#a15">00189</a>   <font class="keywordtype">void</font> <a class="code" href="class_FGGroup.html#a15">printSetOfWords</a>( ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; S )<font class="keyword"> const </font>{
00190          <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;printSetOfWords( ostr, S );
00191   }
00192   <font class="comment">// Outputs S to ostr, in a form that can input by readWord.</font>
00193 
<a name="l00194"></a><a class="code" href="class_FGGroup.html#a16">00194</a>   <font class="keywordtype">void</font> <a class="code" href="class_FGGroup.html#a16">printVectorOfWords</a>( ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; V,
00195             <font class="keywordtype">char</font>* leftBracket = <font class="stringliteral">"{"</font>, <font class="keywordtype">char</font>* rightBracket = <font class="stringliteral">"}"</font> )<font class="keyword"> const </font>
00196 <font class="keyword">  </font>{
00197     <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;printVectorOfWords( ostr, V, leftBracket, rightBracket );
00198   }
00199   <font class="comment">// Outputs V to ostr, in a form that can input by readWord.</font>
00200 
00201 
00202 <font class="comment"></font>
00203 <font class="comment">  ///////////////////////////////////////////////////////</font>
00204 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00205   <font class="comment">//  Methods which deal with subgroups                //</font>
00206   <font class="comment">//                                                   //</font><font class="comment"></font>
00207 <font class="comment">  ///////////////////////////////////////////////////////</font>
00208 <font class="comment"></font>
00209   
00210   <a class="code" href="class_Subgroup.html">Subgroup</a> <a class="code" href="class_FGGroup.html#a17">randomSubgroup</a>( ) <font class="keyword">const</font>; <font class="comment">// @stc this has to be set up with</font>
00211                               <font class="comment">// handles to manipulate distributions</font>
00212 
00213 
00214  <font class="comment"></font>
00215 <font class="comment">  ///////////////////////////////////////////////////////</font>
00216 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00217   <font class="comment">//  Representation access methods                    //</font>
00218   <font class="comment">//                                                   //</font><font class="comment"></font>
00219 <font class="comment">  ///////////////////////////////////////////////////////</font>
00220 <font class="comment"></font><font class="comment"></font>
00221 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00222 <font class="comment"></font>  //                                                                     //
00223   <font class="comment">// IPC tools:                                                          //</font>
00224   <font class="comment">//                                                                     //</font><font class="comment"></font>
00225 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00226 <font class="comment"></font>  // operators inhereted from Group  
00227 
00228  
00229 <font class="comment">/* @rn inherited</font>
00230 <font class="comment">private:</font>
00231 <font class="comment"> </font>
00232 <font class="comment">  typedef FGGroupRep ThisRep;</font>
00233 <font class="comment">  typedef Group Base;</font>
00234 <font class="comment"> </font>
00235 <font class="comment">  // Shadow representation accessors to get representations of the</font>
00236 <font class="comment">  // right type in the members of this class:</font>
00237 <font class="comment"> </font>
00238 <font class="comment">  const FGGroupRep* look( ) const {</font>
00239 <font class="comment">    return (const ThisRep*)DerivedObjectOf&lt;Group,FGGroupRep&gt;::look();</font>
00240 <font class="comment">  }</font>
00241 <font class="comment">  FGGroupRep* enhance( ) const {</font>
00242 <font class="comment">         return (ThisRep*)DerivedObjectOf&lt;Group,FGGroupRep&gt;::enhance();</font>
00243 <font class="comment">  }</font>
00244 <font class="comment">  FGGroupRep* change( ) {</font>
00245 <font class="comment">         return (ThisRep*)DerivedObjectOf&lt;Group,FGGroupRep&gt;::change();</font>
00246 <font class="comment">  }</font>
00247 <font class="comment">*/</font>
00248  
00249 <font class="keyword">protected</font>:
00250 
00251   <font class="comment">// Special wrapping constructor to wrap new representations (returned</font>
00252   <font class="comment">// by eg. delegated methods) and for base initialisation by derived</font>
00253   <font class="comment">// classes:</font>
00254  
<a name="l00255"></a><a class="code" href="class_FGGroup.html#b0">00255</a>   <a class="code" href="class_FGGroup.html#a0">FGGroup</a>( <a class="code" href="struct_FGGroupRep.html">FGGroupRep</a>* newrep ) : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Group.html">Group</a>,<a class="code" href="struct_FGGroupRep.html">FGGroupRep</a>&gt;(newrep) { }
00256  <font class="comment"></font>
00257 <font class="comment">  ///////////////////////////////////////////////////////</font>
00258 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00259   <font class="comment">//  Debugging stuff                                  //</font>
00260   <font class="comment">//                                                   //</font><font class="comment"></font>
00261 <font class="comment">  ///////////////////////////////////////////////////////</font>
00262 <font class="comment"></font> 
00263 <font class="preprocessor">#ifdef DEBUG</font>
00264 <font class="preprocessor"></font>
00265   <font class="comment">// Inherited from Group:</font>
00266   <font class="comment">// bool consistent( ) const;</font>
00267 
00268 <font class="preprocessor">#endif</font>
00269 <font class="preprocessor"></font>
00270 };
00271 
00272 <font class="preprocessor">#endif</font>
</font></pre></div><hr><address><small>Generated at Tue Jun 19 09:49:36 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
