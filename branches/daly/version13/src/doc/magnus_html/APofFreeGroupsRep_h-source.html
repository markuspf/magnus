<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/AProducts/include/APofFreeGroupsRep.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/AProducts/include/APofFreeGroupsRep.h</h1><a href="APofFreeGroupsRep_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">//</font>
00002 <font class="comment">// $Id: APofFreeGroupsRep.h,v 1.4 1998/01/06 20:03:57 bormotov Exp $</font>
00003 <font class="comment">//</font>
00004 
00005 <font class="comment">// Copyright (C) 1996 The New York Group Theory Cooperative</font>
00006 <font class="comment">// See magnus/doc/COPYRIGHT for the full notice.</font>
00007 
00008 <font class="comment">// Contents: Definition of the AmalgProductOfFreeGroupsRep class.</font>
00009 <font class="comment">//           The name is abbreviated to fit in a library.</font>
00010 <font class="comment">//</font>
00011 <font class="comment">// Principal Authors: Eugene Paderin, Dmitry Pechkin</font>
00012 <font class="comment">//</font>
00013 <font class="comment">// Status: draft</font>
00014 <font class="comment">//</font>
00015 <font class="comment">// Revision History:</font>
00016 <font class="comment">//</font>
00017 <font class="comment">// Discussion:</font>
00018 <font class="comment">//</font>
00019 <font class="comment">// Bugs:</font>
00020 <font class="comment">//</font>
00021 <font class="comment">//</font>
00022 <font class="comment">// Special Notes:</font>
00023 <font class="comment">//</font>
00024 <font class="comment">//</font>
00025 
00026 <font class="preprocessor">#ifndef _AMPRODUCT_FREE_GROUPS_REP_H_</font>
00027 <font class="preprocessor"></font><font class="preprocessor">#define _AMPRODUCT_FREE_GROUPS_REP_H_</font>
00028 <font class="preprocessor"></font>
00029 <font class="preprocessor">#include "<a class="code" href="FPGroupRep_h.html">FPGroupRep.h</a>"</font>
00030 <font class="preprocessor">#include "<a class="code" href="FreeGroup_h.html">FreeGroup.h</a>"</font>
00031 <font class="preprocessor">#include "<a class="code" href="VectorPtr_h.html">VectorPtr.h</a>"</font>
00032 <font class="preprocessor">#include "<a class="code" href="SGofFreeGroup_h.html">SGofFreeGroup.h</a>"</font>
00033 <font class="preprocessor">#include "<a class="code" href="AP-fixups_h.html">AP-fixups.h</a>"</font>
00034 <font class="preprocessor">#include "<a class="code" href="Automorphism_h.html">Automorphism.h</a>"</font>
00035 
<a name="l00036"></a><a class="code" href="APofFreeGroupsRep_h.html#a4">00036</a> <font class="keyword">enum</font> NumberOfFactor { LEFT_FACTOR = 0, RIGHT_FACTOR = 1, PRODUCT, INTERSECTION };
00037 <font class="comment">// This value indicates word membership. LEFT_FACTOR or RIGHT_FACTOR</font>
00038 <font class="comment">// mean that the word consists entirely of generators of one factor,</font>
00039 <font class="comment">// INTERSECTION means that the word belongs to the amalgamated subgroup</font>
00040 <font class="comment">// and thus can be written in generators of any factor, and PRODUCT means</font>
00041 <font class="comment">// the other cases.</font>
00042 
00043 <font class="comment">//-------------------- LocalWord -------------------------------------</font>
00044 
00045 <font class="comment">// A helper class: the word written in generators of one factor,</font>
00046 <font class="comment">// together with the factor number.</font>
00047 <font class="comment">//</font>
00048 <font class="comment">// To understand the concept of local and global words, see comments in</font>
00049 <font class="comment">// AmalgProductOfFreeGroups.h header.</font>
00050 
<a name="l00051"></a><a class="code" href="struct_LocalWord.html">00051</a> <font class="keyword">struct </font><a class="code" href="struct_LocalWord.html">LocalWord</a>
00052 {
00053   <font class="comment">// methods</font>
00054 
<a name="l00055"></a><a class="code" href="struct_LocalWord.html#a0">00055</a>   <a class="code" href="struct_LocalWord.html#a0">LocalWord</a>() : theWord(), theFactor(INTERSECTION) {}
00056 
<a name="l00057"></a><a class="code" href="struct_LocalWord.html#a1">00057</a>   <a class="code" href="struct_LocalWord.html#a0">LocalWord</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <font class="keyword">const</font> NumberOfFactor&amp; fac) : theWord(w),
00058   theFactor(fac) {}
00059 
00060   <font class="comment">// copy constructor, operator= and destructor supplied by compiler</font>
00061 
<a name="l00062"></a><a class="code" href="struct_LocalWord.html#a2">00062</a>   <a class="code" href="struct_LocalWord.html#a2">operator Word</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> theWord; }
00063 
00064   <font class="keyword">friend</font> <a class="code" href="struct_LocalWord.html">LocalWord</a> <a class="code" href="struct_LocalWord.html#l0">operator * </a>(<font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w1, <font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w2);
00065 
<a name="l00066"></a><a class="code" href="struct_LocalWord.html#a3">00066</a>   <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; <a class="code" href="struct_LocalWord.html#a3">operator *= </a>(<font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w)<font class="keyword"> </font>{
00067     <font class="keywordflow">return</font> *<font class="keyword">this</font> = *<font class="keyword">this</font> * w;
00068   }
00069 
<a name="l00070"></a><a class="code" href="struct_LocalWord.html#a4">00070</a>   <a class="code" href="struct_LocalWord.html">LocalWord</a> <a class="code" href="struct_LocalWord.html#a4">inverse</a>()<font class="keyword"> const </font>{
00071     <font class="keywordflow">return</font> <a class="code" href="struct_LocalWord.html#a0">LocalWord</a>(theWord.<a class="code" href="class_Word.html#a30">inverse</a>(), theFactor);
00072   }
00073 
<a name="l00074"></a><a class="code" href="struct_LocalWord.html#a5">00074</a>   <a class="code" href="struct_LocalWord.html">LocalWord</a> <a class="code" href="struct_LocalWord.html#a5">freelyReduce</a>()<font class="keyword"> const </font>{
00075     <font class="keywordflow">return</font> <a class="code" href="struct_LocalWord.html#a0">LocalWord</a>(theWord.<a class="code" href="class_Word.html#a27">freelyReduce</a>(), theFactor);
00076   }
00077 
00078   <font class="comment">// data members</font>
00079 
<a name="l00080"></a><a class="code" href="struct_LocalWord.html#m0">00080</a>   <a class="code" href="class_Word.html">Word</a> theWord;
<a name="l00081"></a><a class="code" href="struct_LocalWord.html#m1">00081</a>   NumberOfFactor theFactor;
00082 };
00083 
00084 
00085 <font class="comment">//---------------- Class AmalgProductOfFreeGroupsRep ------------------</font>
00086 
<a name="l00087"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">00087</a> <font class="keyword">struct </font><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a> : <a class="code" href="struct_FPGroupRep.html">FPGroupRep</a> {
00088 
00089 <font class="comment">// Constructors:</font>
00090 
00091   <font class="comment">// Copy constructor and operator= provided by compiler (do deep copy).</font>
00092 
00093   <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a0">AmalgProductOfFreeGroupsRep</a>(<font class="keyword">const</font> <a class="code" href="class_FreeGroup.html">FreeGroup</a>&amp; g1, <font class="keyword">const</font> <a class="code" href="class_FreeGroup.html">FreeGroup</a>&amp; g2,
00094                               <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gen1, <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gen2 );
00095 
00096   <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a0">AmalgProductOfFreeGroupsRep</a>(<font class="keyword">const</font> <a class="code" href="class_SGofFreeGroup.html">SGofFreeGroup</a>&amp; sg1,
00097                               <font class="keyword">const</font> <a class="code" href="class_SGofFreeGroup.html">SGofFreeGroup</a>&amp; sg2);
00098 
00099   <font class="comment">// Destructor provided by compiler</font>
00100 
00101 <font class="comment">// Accessors / Manipulators:</font>
00102 
00103   <font class="comment">// Inherited:</font>
00104   <font class="comment">// virtual SetOf&lt;Word&gt;&amp; setRelators( const SetOf&lt;Word&gt;&amp; r );</font>
00105   <font class="comment">// virtual SetOf&lt;Word&gt;&amp; addRelators( const SetOf&lt;Word&gt;&amp; r );</font>
00106   <font class="comment">// virtual SetOf&lt;Word&gt;&amp; removeRelators( const SetOf&lt;Word&gt;&amp; r );</font>
00107 
00108 <font class="comment">//</font>
00109 <font class="comment">// Representation methods:</font>
00110 <font class="comment">//</font>
00111 
<a name="l00112"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a2">00112</a>   <a class="code" href="struct_PureRep.html">PureRep</a>* <a class="code" href="struct_FPGroupRep.html#a7">clone</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <font class="keyword">new</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a0">AmalgProductOfFreeGroupsRep</a>(*<font class="keyword">this</font>); }
00113   <font class="comment">// overrides FGGroupRep::clone()</font>
00114 
<a name="l00115"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#p0">00115</a>   <font class="keyword">static</font> <font class="keyword">const</font> <a class="code" href="class_Type.html">Type</a> theAmalgProductOfFreeGroupsType;
00116 
<a name="l00117"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#d0">00117</a>   <font class="keyword">static</font> <a class="code" href="class_Type.html">Type</a> <a class="code" href="struct_FPGroupRep.html#d0">type</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> theAmalgProductOfFreeGroupsType; }
00118   <font class="comment">// dominates FPGroupRep::type()</font>
00119 
<a name="l00120"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a3">00120</a>   <a class="code" href="class_Type.html">Type</a> <a class="code" href="struct_FPGroupRep.html#a8">actualType</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="struct_FPGroupRep.html#d0">type</a>(); }
00121   <font class="comment">// overrides FPGroupRep::actualType();</font>
00122 
00123 
00124 <font class="comment">//</font>
00125 <font class="comment">// Methods dealing with the properties of the group:</font>
00126 <font class="comment">//</font>
00127 
00128   <font class="keywordtype">int</font> <a class="code" href="struct_FPGroupRep.html#a9">order</a>( ) <font class="keyword">const</font>;
00129   <font class="comment">// Overrides FPGroupRep::order().</font>
00130 
00131   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FPGroupRep.html#a10">isTrivial</a>( ) <font class="keyword">const</font>;
00132   <font class="comment">// Overrides FPGroupRep::isTrivial().</font>
00133 
00134   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FPGroupRep.html#a11">isFinite</a>( ) <font class="keyword">const</font>;
00135   <font class="comment">// Overrides FPGroupRep::isFinite().</font>
00136 
00137   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FPGroupRep.html#a12">isInfinite</a>( ) <font class="keyword">const</font>;
00138   <font class="comment">// Overrides FPGroupRep::isInfinite().</font>
00139 
00140   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FPGroupRep.html#a13">isAbelian</a>( ) <font class="keyword">const</font>;
00141   <font class="comment">// Overrides FPGroupRep::isAbelian().</font>
00142 
00143   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FPGroupRep.html#a14">isFree</a>( ) <font class="keyword">const</font>;
00144   <font class="comment">// Overrides FPGroupRep::isFree().</font>
00145 
00146   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a10">isHyperbolic</a>() <font class="keyword">const</font>;
00147   <font class="comment">// Determines whether given group is hyperbolic.</font>
00148 
00149 <font class="comment">//</font>
00150 <font class="comment">// I/O:</font>
00151 <font class="comment">//</font>
00152 
00153   <font class="keywordtype">void</font> <a class="code" href="struct_FPGroupRep.html#a16">printOn</a>(ostream&amp;) <font class="keyword">const</font>;
00154   <font class="comment">// Overrides FPGroupRep::printOn().</font>
00155 
00156   <a class="code" href="struct_GroupRep.html">GroupRep</a>* <a class="code" href="struct_FPGroupRep.html#a17">readFrom</a>(istream&amp;, <a class="code" href="class_Chars.html">Chars</a>&amp;) <font class="keyword">const</font>;
00157   <font class="comment">// Overrides FPGroupRep::readFrom().</font>
00158 
00159   <font class="keywordtype">void</font> <a class="code" href="struct_FPGroupRep.html#a18">printRelators</a>(ostream&amp;) <font class="keyword">const</font>;
00160   <font class="comment">// Overrides FPGroupRep::printRelators().</font>
00161 
00162   <font class="keywordtype">void</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a14">printDecomposition</a>(ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; deco) <font class="keyword">const</font>;
00163   <font class="comment">// Prints given vector of words in follow format: words are separated</font>
00164   <font class="comment">// by dot.</font>
00165   
00166 
00167 <font class="comment">//</font>
00168 <font class="comment">// Methods dealing with group elements:</font>
00169 <font class="comment">//</font>
00170 
<a name="l00171"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a15">00171</a>   <a class="code" href="class_Elt.html">Elt</a> <a class="code" href="struct_FPGroupRep.html#a21">eval</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> const </font>{
00172 <font class="preprocessor">#if SAFETY &gt; 0</font>
00173 <font class="preprocessor"></font>    <font class="keywordflow">if</font> ( ord(w.<a class="code" href="class_Word.html#a22">maxOccurringGenerator</a>()) &gt; theNumberOfGenerators )
00174       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"tried to evaluate Word with no interpretation in FreeGroup"</font>);
00175 <font class="preprocessor">#endif</font>
00176 <font class="preprocessor"></font>    <font class="keywordflow">return</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a21">reducedFormOf</a>(w);
00177   }
00178   <font class="comment">// Overrides FGGroupRep::eval().</font>
00179 
00180 
<a name="l00181"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a16">00181</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FPGroupRep.html#a22">wordProblem</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> const </font>{
00182     <font class="keywordflow">return</font> ( <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a21">reducedFormOf</a>(w).<a class="code" href="class_Word.html#a5">length</a>() == 0 ? yes : no );
00183   }
00184   <font class="comment">// Overrides FGGroupRep::wordProblem().</font>
00185 
00186   NumberOfFactor <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a17">factorOfFormalWord</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00187   <font class="comment">// Determines the group the given formal word belongs to.</font>
00188 
00189   NumberOfFactor <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a18">factorOfElement</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00190   <font class="comment">// Same as above, but also checks whether the given element of</font>
00191   <font class="comment">// the product belongs to the amalgamated subgroup.</font>
00192 
00193   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a19">decompose</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00194   <font class="comment">// Decomposes the given word to the product of words d_1 d_2 ....</font>
00195   <font class="comment">// such that every d_i belongs to one of the factors and any</font>
00196   <font class="comment">// two successive words belong to distinct factors.</font>
00197 
00198   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a20">reducedDecomposition</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00199   <font class="comment">// Find the minimal (in the sense of number of components) decomposition</font>
00200   <font class="comment">// of the given word.</font>
00201 
<a name="l00202"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a21">00202</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a21">reducedFormOf</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00203     <font class="keywordflow">return</font> <a class="code" href="AP-fixups_h.html#a14">compose</a>(<a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a20">reducedDecomposition</a>(w));
00204   }
00205   <font class="comment">// As above, but result is presented as a single word.</font>
00206 
00207   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a22">normalDecomposition</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00208   <font class="comment">// Finds the normal decomposition of the given word: this is</font>
00209   <font class="comment">// the reduced decomposition where all components except the</font>
00210   <font class="comment">// first one are some right Schreier representatives.</font>
00211   <font class="comment">//</font>
00212 
<a name="l00213"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a23">00213</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a23">normalFormOf</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00214     <font class="keywordflow">return</font> <a class="code" href="AP-fixups_h.html#a14">compose</a>(<a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a22">normalDecomposition</a>(w));
00215   }
00216   <font class="comment">// As above, but result is presented as a single word.</font>
00217 
<a name="l00218"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a24">00218</a>   <font class="keywordtype">int</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a24">lengthOf</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a19">decompose</a>(w).<a class="code" href="class_VectorOf.html#a11">length</a>(); }
00219   <font class="comment">// Compute the length of word decomposition.</font>
00220 
00221   <font class="keywordtype">int</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a25">numberOfSubstitutions</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w ) <font class="keyword">const</font>;
00222   <font class="comment">// If the given word represents 1 in the group</font>
00223   <font class="comment">// the function computes the number of uses of a relation</font>
00224   <font class="comment">// a = b to deduce that w = 1, i.e. in re-expressing w as </font>
00225   <font class="comment">// a product of conjugates of a * b^-1, computes the number</font>
00226   <font class="comment">// of these conjugates.</font>
00227 
00228   <font class="comment">//</font>
00229   <font class="comment">// Local coding word &lt;--&gt; global coding word conversions.</font>
00230   <font class="comment">//</font>
00231 
<a name="l00232"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a26">00232</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a26">localToGlobal</a>(<font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w)<font class="keyword"> const </font>{
00233     <font class="keywordflow">return</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a26">localToGlobal</a>(w.theWord, w.theFactor);
00234   }
00235   <font class="comment">// Convert local coding word into global coding one.</font>
00236 
00237   <a class="code" href="class_Word.html">Word</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a26">localToGlobal</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; theWord, NumberOfFactor theFactor) <font class="keyword">const</font>;
00238   <font class="comment">// Convert local word presented by word and factor into the global </font>
00239   <font class="comment">// coding one.</font>
00240 
00241   <a class="code" href="struct_LocalWord.html">LocalWord</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a28">globalToLocal</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00242   <font class="comment">// Convert global coding word into local coding one.</font>
00243 
00244 
<a name="l00245"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a29">00245</a>   NumberOfFactor <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a29">factorOfGenerator</a>(<font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; gen)<font class="keyword"> const </font>{
00246     <font class="keywordflow">if</font>( <a class="code" href="global_h.html#a7">abs</a>(ord(gen)) &lt;= numerationShift )
00247       <font class="keywordflow">return</font> LEFT_FACTOR;
00248     <font class="keywordflow">else</font>
00249       <font class="keywordflow">return</font> RIGHT_FACTOR;
00250   }
00251   <font class="comment">// Determine whether gen is a generator of first or second factor.</font>
00252 
00253   <a class="code" href="struct_LocalWord.html">LocalWord</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a30">mapFromSubgroup</a>(<font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w) <font class="keyword">const</font>;
00254   <font class="comment">// w is an element of associated subgroup (written in generators</font>
00255   <font class="comment">// of one factor). The function rewrites it in generators of another</font>
00256   <font class="comment">// factor.</font>
00257 
<a name="l00258"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a31">00258</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a30">mapFromSubgroup</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00259     <a class="code" href="struct_LocalWord.html">LocalWord</a> lw = <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a28">globalToLocal</a>(w);
00260     <font class="keywordflow">return</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a26">localToGlobal</a>( <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a30">mapFromSubgroup</a>(lw) );
00261   }
00262   <font class="comment">// The same as above. There is warning: no checking is done for the word `w'</font>
00263   <font class="comment">// is actually belongs to the associated subgroup or just one of factors.</font>
00264 
00265   <font class="keywordtype">bool</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a32">isElementOfSubgroup</a>(<font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w) <font class="keyword">const</font>;
00266   <font class="comment">// Determines whether the given word is an element of associated subgroup.</font>
00267 
00268   <a class="code" href="struct_LocalWord.html">LocalWord</a> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a33">rightSchreierRepresentativeOf</a>(<font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w) <font class="keyword">const</font>;
00269   <font class="comment">// Finds right Schreier Representative of given word.</font>
00270 
00271   <font class="keywordtype">void</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a34">makeSubgroupMapping</a>(<font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gen1,
00272                            <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gen2);
00273   <font class="comment">// Constructs mapping between associated subgroups.</font>
00274   <font class="comment">// Used *only* by constructors.</font>
00275 
00276   <font class="keywordtype">void</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a35">fixGeneratorsNames</a>();
00277   <font class="comment">// Used *only* by constructors.</font>
00278 
00279   <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="Word_h.html#a1">maximalRoot</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <a class="code" href="class_Word.html">Word</a>&amp; root, <font class="keywordtype">int</font>&amp; power) <font class="keyword">const</font>;
00280   <font class="comment">// Returns maximal root of given word w and maximal power.</font>
00281   <font class="comment">//@dp this method is not implemented yet.</font>
00282 
00283   <font class="keywordtype">bool</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a37">isProperPower</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00284   <font class="comment">// Determines whether w is a proper power.</font>
00285 
00286   <font class="keywordtype">bool</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a38">isProperPowerOfSecond</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <font class="keywordtype">int</font>&amp; power) <font class="keyword">const</font>;
00287   <font class="comment">// Determines whether u is a proper power of w.</font>
00288 
00289   <font class="keywordtype">bool</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a39">commute</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00290   <font class="comment">// Determines whether [u,w] = 1.</font>
00291 
00292   <font class="keywordtype">bool</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a40">isSubgroupTrivial</a>(<font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; subgrp) <font class="keyword">const</font>;
00293   <font class="comment">// Determines whether subgroup generated by vec is trivial.</font>
00294 
00295   <font class="keywordtype">bool</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a41">isSubgroupCyclic</a>(<font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; subgrp) <font class="keyword">const</font>;
00296   <font class="comment">// Determines whether subgroup generated by vec is cyclic.</font>
00297 
00298   <font class="keywordtype">bool</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a42">isSubgroupAbelian</a>(<font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; subgrp) <font class="keyword">const</font>;
00299   <font class="comment">// Determines whether subgroup generated by vec is abelian.</font>
00300 
00301   <font class="keywordtype">void</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a43">cyclicReduction</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <a class="code" href="class_Word.html">Word</a>&amp; result, <a class="code" href="class_Word.html">Word</a>&amp; conjugator) <font class="keyword">const</font>;
00302   <font class="comment">// Finds cyclic reduction of w such that w = result^conjugator.</font>
00303 
00304   <font class="keywordtype">void</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#a44">cyclicDecomposition</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; result, 
00305                            <a class="code" href="class_Word.html">Word</a>&amp; conjugator) <font class="keyword">const</font>;
00306   <font class="comment">// The same as above, but result is represented as vector of components.</font>
00307 
00308   <font class="comment">// Data members:</font>
00309 
00310   <font class="comment">// These four vectors consist of two elements concerning two factors</font>
00311   <font class="comment">// of the product.</font>
<a name="l00312"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#m0">00312</a>   <a class="code" href="class_VectorPtrOf.html">VectorPtrOf&lt;FreeGroup&gt;</a> factor;            <font class="comment">// [2]</font>
<a name="l00313"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#m1">00313</a>   <a class="code" href="class_VectorPtrOf.html">VectorPtrOf&lt;SGofFreeGroup&gt;</a> assocSubgroup; <font class="comment">// [2]</font>
<a name="l00314"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#m2">00314</a>   <a class="code" href="class_VectorPtrOf.html">VectorPtrOf&lt;Map&gt;</a> subgroupMapping;         <font class="comment">// [2]</font>
<a name="l00315"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#m3">00315</a>   <a class="code" href="class_VectorPtrOf.html">VectorPtrOf&lt;Automorphism&gt;</a> nielsenBasisToGensOfSubgroup; <font class="comment">// [2]</font>
<a name="l00316"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#m4">00316</a>   <font class="keywordtype">int</font> rankOfSubgroups;
00317 
<a name="l00318"></a><a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#m5">00318</a>   <font class="keywordtype">int</font> numerationShift; <font class="comment">// shift in global numeration of the second factor</font>
00319   <font class="comment">// subgroupMapping[i] maps i-th factor subgroup into another subgroup</font>
00320   <font class="comment">// the word being mapped is written in Nielsen basis of the subgroup,</font>
00321   <font class="comment">// *not* in generators of the group. The result is written in</font>
00322   <font class="comment">// generators of (the opposite) group.</font>
00323 
00324 };
00325 
00326 <font class="preprocessor">#endif</font>
00327 <font class="preprocessor"></font>
00328 
00329 
</pre></div><hr><address><small>Generated at Tue Jun 19 09:49:33 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
