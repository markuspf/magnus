<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/SessionManager/include/FEData.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/SessionManager/include/FEData.h</h1><a href="FEData_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> *   $Id: FEData.h,v 1.5 1998/02/23 17:17:41 alex Exp $</font>
00003 <font class="comment"> */</font>
00004 
00005 <font class="comment">// Copyright (C) 1995 The New York Group Theory Cooperative</font>
00006 <font class="comment">// See magnus/doc/COPYRIGHT for the full notice.</font>
00007 
00008 <font class="comment">// Contents: Declaration of mixin class FEData</font>
00009 <font class="comment">//</font>
00010 <font class="comment">// Principal Author: Roger Needham</font>
00011 <font class="comment">//</font>
00012 <font class="comment">// Status: in progress</font>
00013 <font class="comment">//</font>
00014 <font class="comment">// Revision History:</font>
00015 <font class="comment">//</font>
00016 
00017 
00018 <font class="preprocessor">#ifndef _FEDATA_H_</font>
00019 <font class="preprocessor"></font><font class="preprocessor">#define _FEDATA_H_</font>
00020 <font class="preprocessor"></font>
00021 
00022 <font class="preprocessor">#include &lt;iostream.h&gt;</font>
00023 <font class="preprocessor">#include "<a class="code" href="Chars_h.html">Chars.h</a>"</font>
00024 <font class="preprocessor">#include "<a class="code" href="OID_h.html">OID.h</a>"</font>
00025 <font class="preprocessor">#include "<a class="code" href="ARCSlotID_h.html">ARCSlotID.h</a>"</font>
00026 
00027 
00028 <font class="comment">//   Introduction:</font>
00029 <font class="comment">//   ------------</font>
00030 <font class="comment">// </font>
00031 <font class="comment">//   The following discussion is addressed to maintainers; users of class</font>
00032 <font class="comment">// FEData may wish to skip to the `Usage' section.</font>
00033 <font class="comment">// </font>
00034 <font class="comment">//   Overview of Requirements:</font>
00035 <font class="comment">//   ------------------------</font>
00036 <font class="comment">// </font>
00037 <font class="comment">//   The Magnus Front End (FE) must be able to reflect the state of the</font>
00038 <font class="comment">// Session Manager (SM). For modularity, the FE should know as little as</font>
00039 <font class="comment">// possible about the SM data it manipulates.</font>
00040 <font class="comment">// </font>
00041 <font class="comment">//   Therefore, we predefine a small number of events, in response to</font>
00042 <font class="comment">// which the FE is to take some action which reflects the SM's state. The</font>
00043 <font class="comment">// SM describes to the FE what to do in each event, via a simple message</font>
00044 <font class="comment">// protocol.  The descriptions may refer to elements of a `blind'</font>
00045 <font class="comment">// database, which is stored by the FE and kept up to date by the SM.</font>
00046 <font class="comment">// </font>
00047 <font class="comment">//   The FE must know nothing about the database except how to store and</font>
00048 <font class="comment">// extract data. Programmers in the SM layer should know nothing about</font>
00049 <font class="comment">// the database except its semantics in a given event.</font>
00050 <font class="comment">// </font>
00051 <font class="comment">//   The classes wrapped in class FEData form the programmer's interface</font>
00052 <font class="comment">// between the SM and the database.</font>
00053 <font class="comment">// </font>
00054 <font class="comment">//   Terminology:</font>
00055 <font class="comment">//   -----------</font>
00056 <font class="comment">// </font>
00057 <font class="comment">//   The database is an associative array, where the keys and data can be</font>
00058 <font class="comment">// arbitrary strings. Exactly what strings are used is, of course,</font>
00059 <font class="comment">// hidden by the FEData classes.</font>
00060 <font class="comment">// </font>
00061 <font class="comment">//   A `Key' may be constant or variable. When constant, it typically</font>
00062 <font class="comment">// consists of an object id supplied by the programmer, and a key</font>
00063 <font class="comment">// descriptor which is hidden from the programmer. When variable, it</font>
00064 <font class="comment">// typically consists of the index of a formal variable supplied by the</font>
00065 <font class="comment">// programmer, and the key descriptor. The latter allows database</font>
00066 <font class="comment">// references to be specified for events in advance, and later evaluated</font>
00067 <font class="comment">// in a context in which the formal variables have values. This is</font>
00068 <font class="comment">// tricky; see the discussion of menus, below.</font>
00069 <font class="comment">// </font>
00070 <font class="comment">//   A `Datum' is the value returned by the database for a given key. It</font>
00071 <font class="comment">// is always constant, and is typically a boolean value, an object id, or</font>
00072 <font class="comment">// a string such as an object's name.  A Datum is represented only</font>
00073 <font class="comment">// conceptually by FEData (i.e., not as a class), since it exists only in</font>
00074 <font class="comment">// the FE. The programmer specifies a Datum via a Key.</font>
00075 <font class="comment">// </font>
00076 <font class="comment">//   An `Expression' is built up from Keys via operators like `==', `&amp;&amp;',</font>
00077 <font class="comment">// and `!'. Thus an Expression may be variable or constant.</font>
00078 <font class="comment">// </font>
00079 <font class="comment">//   A `Name' is an Expression which contains another Expression, where</font>
00080 <font class="comment">// the latter evaluates to an object id.</font>
00081 <font class="comment">// </font>
00082 <font class="comment">//   Events:</font>
00083 <font class="comment">//   ------</font>
00084 <font class="comment">// </font>
00085 <font class="comment">//   These are the events for which the FE must take action which depends</font>
00086 <font class="comment">// on the database:</font>
00087 <font class="comment">// </font>
00088 <font class="comment">//   1) There is new data to be stored.</font>
00089 <font class="comment">// </font>
00090 <font class="comment">//      The SM must supply a constant Key, and a constant Expression</font>
00091 <font class="comment">// (which may be a simple value) to become the Datum. For example, the SM</font>
00092 <font class="comment">// may announce that `the parent group of word &lt;object-id&gt; is</font>
00093 <font class="comment">// &lt;object-id&gt;'.  The `parent group' part is resolved as a key</font>
00094 <font class="comment">// descriptor, the first object id becomes part of the Key, and the</font>
00095 <font class="comment">// second object id is the Datum.</font>
00096 <font class="comment">// </font>
00097 <font class="comment">//   2) The SM wishes to display textual data.</font>
00098 <font class="comment">// </font>
00099 <font class="comment">//      In this case, the SM knows exactly which objects it wants to talk</font>
00100 <font class="comment">// about, so it can supply their object id's. SM programmers must be able</font>
00101 <font class="comment">// to embed constant Names in text.</font>
00102 <font class="comment">// </font>
00103 <font class="comment">//   3) A new workspace object has been created.</font>
00104 <font class="comment">// </font>
00105 <font class="comment">//      The view description for the object may contain text which refers</font>
00106 <font class="comment">// to various objects by name. These objects are known when the new one</font>
00107 <font class="comment">// is created, so the situation is as in 2).</font>
00108 <font class="comment">// </font>
00109 <font class="comment">//   4) The workspace selection has changed.</font>
00110 <font class="comment">// </font>
00111 <font class="comment">//      &lt;To Appear&gt;</font>
00112 <font class="comment">//</font>
00113 <font class="comment">//</font>
00114 <font class="comment">//   Usage:</font>
00115 <font class="comment">//   -----</font>
00116 <font class="comment">// </font>
00117 <font class="comment">//      &lt;To Appear&gt;</font>
00118 <font class="comment">//</font>
00119 
00120 
00121 <font class="comment">//@rn  This stuff was too quickly hacked, and needs more thought. In</font>
00122 <font class="comment">//@rn  particular, the ! operator does not work properly; e.g., the</font>
00123 <font class="comment">//@rn  expression ( !  IsAuto(...) ) is spuriously false when there</font>
00124 <font class="comment">//@rn  is no `auto' key stored at all in the FE.</font>
00125 
00126 
00127 
00128 <font class="comment">//---------------------------------------------------------------------------//</font>
00129 <font class="comment">//----------------------------- FEData --------------------------------------//</font>
00130 <font class="comment">//---------------------------------------------------------------------------//</font>
00131 
<a name="l00132"></a><a class="code" href="class_FEData.html">00132</a> <font class="keyword">class </font><a class="code" href="class_FEData.html">FEData</a>
00133 {
00134 <font class="keyword">private</font>:
00135 <font class="comment"></font>
00136 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00137 <font class="comment"></font>  <font class="comment">//                                                                     //</font>
00138   <font class="comment">// Rep Classes:                                                        //</font>
00139   <font class="comment">//                                                                     //</font><font class="comment"></font>
00140 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00141 <font class="comment"></font>         
<a name="l00142"></a><a class="code" href="struct_FEData__ExpressionRep.html">00142</a>   <font class="keyword">struct </font>ExpressionRep
00143   {
<a name="l00144"></a><a class="code" href="struct_FEData__ExpressionRep.html#a0">00144</a>          <a class="code" href="struct_FEData__ExpressionRep.html#a0">ExpressionRep</a>( ) : refs( 1 ) { }
00145 
<a name="l00146"></a><a class="code" href="struct_FEData__ExpressionRep.html#a1">00146</a>          ExpressionRep* <a class="code" href="struct_FEData__ExpressionRep.html#a1">gimme</a>( )<font class="keyword"> </font>{
00147                 ++refs;
00148                 <font class="keywordflow">return</font> <font class="keyword">this</font>;
00149          }
00150 
<a name="l00151"></a><a class="code" href="struct_FEData__ExpressionRep.html#a2">00151</a>          <font class="keywordtype">void</font> <a class="code" href="struct_FEData__ExpressionRep.html#a2">getHence</a>( )<font class="keyword"> </font>{
00152                 <font class="keywordflow">if</font> ( ! --refs ) { <font class="keyword">delete</font> <font class="keyword">this</font>; }
00153          }
00154 
<a name="l00155"></a><a class="code" href="struct_FEData__ExpressionRep.html#a3">00155</a>          <font class="keyword">virtual</font> <a class="code" href="struct_FEData__ExpressionRep.html#a3">~ExpressionRep</a>( )<font class="keyword"> </font>{ }
00156          
00157          <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="struct_FEData__ExpressionRep.html#a4">printOn</a>(ostream&amp; ostr) <font class="keyword">const</font> = 0;
00158 
00159          <font class="comment">// Data Members:</font>
00160 
<a name="l00161"></a><a class="code" href="struct_FEData__ExpressionRep.html#m0">00161</a>          <font class="keywordtype">int</font> refs;
00162   };
00163 
00164 
<a name="l00165"></a><a class="code" href="struct_FEData__KeyRep.html">00165</a>   <font class="keyword">struct </font>KeyRep : <font class="keyword">public</font> ExpressionRep
00166   {
00167          <a class="code" href="struct_FEData__KeyRep.html#a0">KeyRep</a>(<font class="keywordtype">int</font> i);  <font class="comment">// Stupid special case</font>
00168 
00169          <a class="code" href="struct_FEData__KeyRep.html#a0">KeyRep</a>(<font class="keywordtype">int</font> i, <font class="keyword">const</font> <font class="keywordtype">char</font>* t);
00170 
00171          <a class="code" href="struct_FEData__KeyRep.html#a0">KeyRep</a>(<a class="code" href="class_OID.html">OID</a> oid, <font class="keyword">const</font> <font class="keywordtype">char</font>* t);
00172 
00173          <a class="code" href="struct_FEData__KeyRep.html#a0">KeyRep</a>(ExpressionRep* se, <font class="keyword">const</font> <font class="keywordtype">char</font>* t);
00174 
<a name="l00175"></a><a class="code" href="struct_FEData__KeyRep.html#a4">00175</a>          <a class="code" href="struct_FEData__KeyRep.html#a4">~KeyRep</a>( )<font class="keyword"> </font>{ <font class="keywordflow">if</font> ( subExpression ) subExpression-&gt;getHence(); }
00176 
00177          <font class="keywordtype">void</font> <a class="code" href="struct_FEData__KeyRep.html#a5">printOn</a>(ostream&amp; ostr) <font class="keyword">const</font>;        <font class="comment">// overrides ExpressionRep</font>
00178 
00179          <font class="comment">// Data Members:</font>
00180 
<a name="l00181"></a><a class="code" href="struct_FEData__KeyRep.html#m0">00181</a>          <font class="keyword">const</font> <font class="keywordtype">int</font> index;
<a name="l00182"></a><a class="code" href="struct_FEData__KeyRep.html#m1">00182</a>          <font class="keyword">const</font> <font class="keywordtype">char</font>* text;
<a name="l00183"></a><a class="code" href="struct_FEData__KeyRep.html#m2">00183</a>          <font class="keywordtype">bool</font> isConstant;
<a name="l00184"></a><a class="code" href="struct_FEData__KeyRep.html#m3">00184</a>          ExpressionRep* subExpression;
00185   };
00186 
00187   
<a name="l00188"></a><a class="code" href="struct_FEData__JoinRep.html">00188</a>   <font class="keyword">struct </font>JoinRep : <font class="keyword">public</font> ExpressionRep
00189   {
00190          <a class="code" href="struct_FEData__JoinRep.html#a0">JoinRep</a>(ExpressionRep* a1, ExpressionRep* a2, <font class="keyword">const</font> <font class="keywordtype">char</font>* j);
00191 
00192          <a class="code" href="struct_FEData__JoinRep.html#a1">~JoinRep</a>( );
00193          
00194          <font class="keywordtype">void</font> <a class="code" href="struct_FEData__JoinRep.html#a2">printOn</a>(ostream&amp; ostr) <font class="keyword">const</font>;         <font class="comment">// overrides ExpressionRep</font>
00195 
00196          <font class="comment">// Data Members:</font>
00197 
<a name="l00198"></a><a class="code" href="struct_FEData__JoinRep.html#m0">00198</a>          ExpressionRep* lhs;
<a name="l00199"></a><a class="code" href="struct_FEData__JoinRep.html#m1">00199</a>          ExpressionRep* rhs;
<a name="l00200"></a><a class="code" href="struct_FEData__JoinRep.html#m2">00200</a>          <font class="keyword">const</font> <font class="keywordtype">char</font>* junctor;  <font class="comment">// Always static data</font>
00201   };
00202 
00203 
<a name="l00204"></a><a class="code" href="struct_FEData__NotRep.html">00204</a>   <font class="keyword">struct </font>NotRep : <font class="keyword">public</font> ExpressionRep
00205   {
00206          <a class="code" href="struct_FEData__NotRep.html#a0">NotRep</a>(ExpressionRep* a);
00207 
00208          <a class="code" href="struct_FEData__NotRep.html#a1">~NotRep</a>( );
00209 
00210          <font class="keywordtype">void</font> <a class="code" href="struct_FEData__NotRep.html#a2">printOn</a>(ostream&amp; ostr) <font class="keyword">const</font>;         <font class="comment">// overrides ExpressionRep</font>
00211 
00212          <font class="comment">// Data Members:</font>
00213 
<a name="l00214"></a><a class="code" href="struct_FEData__NotRep.html#m0">00214</a>          ExpressionRep* expr;
00215   };
00216 
00217 
<a name="l00218"></a><a class="code" href="struct_FEData__NameRep.html">00218</a>   <font class="keyword">struct </font>NameRep : <font class="keyword">public</font> ExpressionRep
00219   {
00220          <a class="code" href="struct_FEData__NameRep.html#a0">NameRep</a>(ExpressionRep* a);
00221 
00222          <a class="code" href="struct_FEData__NameRep.html#a1">~NameRep</a>( );
00223 
00224          <font class="keywordtype">void</font> <a class="code" href="struct_FEData__NameRep.html#a2">printOn</a>(ostream&amp; ostr) <font class="keyword">const</font>;         <font class="comment">// overrides ExpressionRep</font>
00225 
00226          <font class="comment">// Data Members:</font>
00227 
<a name="l00228"></a><a class="code" href="struct_FEData__NameRep.html#m0">00228</a>          ExpressionRep* expr;
00229   };
00230 
00231 
00232 <font class="keyword">protected</font>:
00233 
00234   <font class="comment">//-------------------------------------------------------------------------//</font>
00235   <font class="comment">//---------------------------- Expression ---------------------------------//</font>
00236   <font class="comment">//-------------------------------------------------------------------------//</font>
00237   
<a name="l00238"></a><a class="code" href="class_FEData__Expression.html">00238</a>   <font class="keyword">class </font>Expression
00239   {
00240   <font class="keyword">public</font>:
00241          <font class="comment"></font>
00242 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00243 <font class="comment"></font>         <font class="comment">//                                                                     //</font>
00244          <font class="comment">// Constructors:                                                       //</font>
00245          <font class="comment">//                                                                     //</font><font class="comment"></font>
00246 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00247 <font class="comment"></font>         
<a name="l00248"></a><a class="code" href="class_FEData__Expression.html#a0">00248</a>          <a class="code" href="class_FEData__Expression.html#a0">Expression</a>(<font class="keywordtype">int</font> i) : theRep( new KeyRep( i ) ) { }
00249          <font class="comment">// The hackery is getting rather thick; this is a quicky to allow storage</font>
00250          <font class="comment">// of, e.g., enum values as data.</font>
00251          
<a name="l00252"></a><a class="code" href="class_FEData__Expression.html#a1">00252</a>          <a class="code" href="class_FEData__Expression.html#a0">Expression</a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> </font>{
00253                 theRep = E.theRep-&gt;gimme();
00254          }
00255          
<a name="l00256"></a><a class="code" href="class_FEData__Expression.html#a2">00256</a>          <a class="code" href="class_FEData__Expression.html#a2">~Expression</a>( )<font class="keyword"> </font>{ theRep-&gt;getHence(); }
00257  <font class="comment"></font>
00258 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00259 <font class="comment"></font>         <font class="comment">//                                                                     //</font>
00260          <font class="comment">// Operators:                                                          //</font>
00261          <font class="comment">//                                                                     //</font><font class="comment"></font>
00262 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00263 <font class="comment"></font>         
<a name="l00264"></a><a class="code" href="class_FEData__Expression.html#a3">00264</a>          Expression <a class="code" href="class_FEData__Expression.html#a3">operator == </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00265                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"=="</font> );
00266          }
00267 
<a name="l00268"></a><a class="code" href="class_FEData__Expression.html#a4">00268</a>          Expression <a class="code" href="class_FEData__Expression.html#a4">operator != </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00269                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"!="</font> );
00270          }
00271          
<a name="l00272"></a><a class="code" href="class_FEData__Expression.html#a5">00272</a>          Expression <a class="code" href="class_FEData__Expression.html#a5">operator &amp;&amp; </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00273                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"&amp;&amp;"</font> );
00274          }
00275 
<a name="l00276"></a><a class="code" href="class_FEData__Expression.html#a6">00276</a>          Expression <a class="code" href="class_FEData__Expression.html#a6">operator || </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00277                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"||"</font> );
00278          }
00279 
<a name="l00280"></a><a class="code" href="class_FEData__Expression.html#a7">00280</a>          Expression <a class="code" href="class_FEData__Expression.html#a7">operator ! </a>( )<font class="keyword"> const </font>{
00281                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#a0">Expression</a>( <font class="keyword">new</font> NotRep( theRep-&gt;gimme() ) );
00282          }
00283 
<a name="l00284"></a><a class="code" href="class_FEData__Expression.html#a8">00284</a>          Expression <a class="code" href="class_FEData__Expression.html#a8">operator &gt; </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00285                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"&gt;"</font> );
00286          }
00287 
<a name="l00288"></a><a class="code" href="class_FEData__Expression.html#a9">00288</a>          Expression <a class="code" href="class_FEData__Expression.html#a9">operator &gt;= </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00289                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"&gt;="</font> );
00290          }
00291 
<a name="l00292"></a><a class="code" href="class_FEData__Expression.html#a10">00292</a>          Expression <a class="code" href="class_FEData__Expression.html#a10">operator &lt; </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00293                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"&lt;"</font> );
00294          }
00295 
<a name="l00296"></a><a class="code" href="class_FEData__Expression.html#a11">00296</a>          Expression <a class="code" href="class_FEData__Expression.html#a11">operator &lt;= </a>( <font class="keyword">const</font> Expression&amp; E )<font class="keyword"> const </font>{
00297                 <font class="keywordflow">return</font> <a class="code" href="class_FEData__Expression.html#c0">join</a>( E, <font class="stringliteral">"&lt;="</font> );
00298          }
00299          <font class="comment"></font>
00300 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00301 <font class="comment"></font>         <font class="comment">//                                                                     //</font>
00302          <font class="comment">// Output Methods:                                                     //</font>
00303          <font class="comment">//                                                                     //</font><font class="comment"></font>
00304 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00305 <font class="comment"></font>         
00306     <font class="keyword">friend</font> ostream&amp; <a class="code" href="class_FEData__Expression.html#l0">operator &lt;&lt; </a>( ostream&amp; ostr, <font class="keyword">const</font> Expression&amp; E);
00307 <font class="comment"></font>
00308 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00309 <font class="comment"></font>         <font class="comment">//                                                                     //</font>
00310          <font class="comment">// Protected Methods:                                                  //</font>
00311          <font class="comment">//                                                                     //</font><font class="comment"></font>
00312 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00313 <font class="comment"></font>         
<a name="l00314"></a><a class="code" href="class_FEData__Expression.html#a12">00314</a>          <a class="code" href="class_FEData__Expression.html#a0">Expression</a>( ExpressionRep* rep ) : theRep( rep ) { }
00315          <font class="comment">// Call this ONLY when rep.refs already has the right value!</font>
00316 <font class="comment"></font>
00317 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00318 <font class="comment"></font>         <font class="comment">//                                                                     //</font>
00319          <font class="comment">// Data Members:                                                       //</font>
00320          <font class="comment">//                                                                     //</font><font class="comment"></font>
00321 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00322 <font class="comment"></font>
<a name="l00323"></a><a class="code" href="class_FEData__Expression.html#m0">00323</a>          ExpressionRep* theRep;  <font class="comment">// Public on purpose...</font>
00324 <font class="comment"></font>
00325 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00326 <font class="comment"></font>         <font class="comment">//                                                                     //</font>
00327          <font class="comment">// Private Methods:                                                    //</font>
00328          <font class="comment">//                                                                     //</font><font class="comment"></font>
00329 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00330 <font class="comment"></font>
00331   <font class="keyword">private</font>:
00332          
00333          Expression <a class="code" href="class_FEData__Expression.html#c0">join</a>( <font class="keyword">const</font> Expression&amp; E, <font class="keyword">const</font> <font class="keywordtype">char</font>* junctor ) <font class="keyword">const</font>;
00334          
00335   };
00336 
00337 
00338   <font class="comment">//-------------------------------------------------------------------------//</font>
00339   <font class="comment">//------------------------------- Key -------------------------------------//</font>
00340   <font class="comment">//-------------------------------------------------------------------------//</font>
00341 
<a name="l00342"></a><a class="code" href="class_FEData__Key.html">00342</a>   <font class="keyword">class </font>Key : <font class="keyword">public</font> Expression
00343   {
00344   <font class="keyword">public</font>:
00345 <font class="comment"></font>
00346 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00347 <font class="comment"></font>         <font class="comment">//                                                                     //</font>
00348          <font class="comment">// Constructors:                                                       //</font>
00349          <font class="comment">//                                                                     //</font><font class="comment"></font>
00350 <font class="comment">         /////////////////////////////////////////////////////////////////////////</font>
00351 <font class="comment"></font>
<a name="l00352"></a><a class="code" href="class_FEData__Key.html#a0">00352</a>          <a class="code" href="class_FEData__Key.html#a0">Key</a>( <font class="keyword">const</font> Key&amp; K ) : Expression( K.theRep-&gt;gimme() ) { }
00353 
00354          <font class="comment">// Expression's dtor does the job</font>
00355 
00356   <font class="keyword">protected</font>:
00357 
<a name="l00358"></a><a class="code" href="class_FEData__Key.html#b0">00358</a>          <a class="code" href="class_FEData__Key.html#a0">Key</a>(<font class="keywordtype">int</font> i) : Expression( new KeyRep( i ) ) { }  <font class="comment">// Stupid special case</font>
00359 
<a name="l00360"></a><a class="code" href="class_FEData__Key.html#b1">00360</a>          <a class="code" href="class_FEData__Key.html#a0">Key</a>(<font class="keywordtype">int</font> i, <font class="keyword">const</font> <font class="keywordtype">char</font>* t) : Expression( new KeyRep( i, t ) ) { }
00361 
<a name="l00362"></a><a class="code" href="class_FEData__Key.html#b2">00362</a>          <a class="code" href="class_FEData__Key.html#a0">Key</a>(<a class="code" href="class_OID.html">OID</a> oid, <font class="keyword">const</font> <font class="keywordtype">char</font>* t) : Expression( new KeyRep( oid, t ) ) { }
00363 
<a name="l00364"></a><a class="code" href="class_FEData__Key.html#b3">00364</a>          <a class="code" href="class_FEData__Key.html#a0">Key</a>(<font class="keyword">const</font> Key&amp; K, <font class="keyword">const</font> <font class="keywordtype">char</font>* t)
00365            : Expression( new KeyRep( K.theRep-&gt;gimme(), t ) )
00366          { }
00367 
00368   };
00369 
00370 
00371   <font class="comment">//-------------------------------------------------------------------------//</font>
00372   <font class="comment">//---------------------------- DataPair -----------------------------------//</font>
00373   <font class="comment">//-------------------------------------------------------------------------//</font>
00374 
<a name="l00375"></a><a class="code" href="struct_FEData__DataPair.html">00375</a>   <font class="keyword">struct </font>DataPair
00376   {
<a name="l00377"></a><a class="code" href="struct_FEData__DataPair.html#a0">00377</a>          <a class="code" href="struct_FEData__DataPair.html#a0">DataPair</a>( <font class="keyword">const</font> Key&amp; key, <font class="keyword">const</font> Expression&amp; datum )
00378       : theKey( key ), theDatum( datum )
00379          { }
00380          
00381          <font class="comment">// These are largely unneeded, but ListOf requires them:</font>
00382 
<a name="l00383"></a><a class="code" href="struct_FEData__DataPair.html#a1">00383</a>          <font class="keywordtype">bool</font> <a class="code" href="struct_FEData__DataPair.html#a1">operator == </a>(<font class="keyword">const</font> DataPair&amp; dp)<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <font class="keyword">false</font>; }
00384          DataPair&amp; <a class="code" href="struct_FEData__DataPair.html#a2">operator = </a>(<font class="keyword">const</font> DataPair&amp; dp);
00385     <font class="keyword">friend</font> ostream&amp; <a class="code" href="struct_FEData__DataPair.html#l0">operator &lt;&lt; </a>( ostream&amp; ostr, <font class="keyword">const</font> DataPair&amp; dp);
00386 
00387   <font class="keyword">private</font>:
00388 
<a name="l00389"></a><a class="code" href="struct_FEData__DataPair.html#o0">00389</a>          Key theKey;
<a name="l00390"></a><a class="code" href="struct_FEData__DataPair.html#o1">00390</a>          Expression theDatum;
00391   };
00392 
00393 
00394   <font class="comment">//-------------------------------------------------------------------------//</font>
00395   <font class="comment">//------------------------------ Text -------------------------------------//</font>
00396   <font class="comment">//-------------------------------------------------------------------------//</font>
00397 
<a name="l00398"></a><a class="code" href="struct_FEData__Text.html">00398</a>   <font class="keyword">struct </font>Text
00399   {
00400          <a class="code" href="struct_FEData__Text.html#a0">Text</a>(<font class="keyword">const</font> <font class="keywordtype">char</font>* t = <font class="stringliteral">""</font>);
00401          <a class="code" href="struct_FEData__Text.html#a0">Text</a>(<font class="keyword">const</font> Expression&amp; E);
00402          <a class="code" href="struct_FEData__Text.html#a2">operator Chars</a>( ) <font class="keyword">const</font>;
00403          Text&amp; <a class="code" href="struct_FEData__Text.html#a3">operator + </a>(<font class="keyword">const</font> Text&amp; t);
00404          Text&amp; <a class="code" href="struct_FEData__Text.html#a3">operator + </a>(<font class="keyword">const</font> Expression&amp; E);
00405     <font class="keyword">friend</font> ostream&amp; <a class="code" href="struct_FEData__Text.html#l0">operator &lt;&lt; </a>(ostream&amp; ostr, <font class="keyword">const</font> Text&amp; t);
00406   <font class="keyword">private</font>:
00407          <a class="code" href="struct_FEData__Text.html#a0">Text</a>(<font class="keyword">const</font> Text&amp;);
00408          <font class="comment">// A Text is to be passed only by reference, so this is hidden and</font>
00409          <font class="comment">// not to be implemented. Also, unnecessary parenthesizing results</font>
00410          <font class="comment">// in a `passing reference to temp' warning which must not be</font>
00411          <font class="comment">// ignored.</font>
<a name="l00412"></a><a class="code" href="struct_FEData__Text.html#o0">00412</a>          <a class="code" href="class_ostrstream.html">ostrstream</a> ostrstr;
00413   };
00414 
00415 
00416   <font class="comment">//-------------------------------------------------------------------------//</font>
00417   <font class="comment">//------------------------- Key Derivatives -------------------------------//</font>
00418   <font class="comment">//-------------------------------------------------------------------------//</font>
00419   
<a name="l00420"></a><a class="code" href="struct_FEData__True.html">00420</a>   <font class="keyword">struct </font>True : <font class="keyword">public</font> Key
00421   {
<a name="l00422"></a><a class="code" href="struct_FEData__True.html#a0">00422</a>          <a class="code" href="struct_FEData__True.html#a0">True</a>( ) : Key( 1 ) { }
00423   };
00424 
00425 
<a name="l00426"></a><a class="code" href="struct_FEData__False.html">00426</a>   <font class="keyword">struct </font>False : <font class="keyword">public</font> Key
00427   {
<a name="l00428"></a><a class="code" href="struct_FEData__False.html#a0">00428</a>          <a class="code" href="struct_FEData__False.html#a0">False</a>( ) : Key( 0 ) { }
00429   };
00430 
00431 
<a name="l00432"></a><a class="code" href="struct_FEData__Object.html">00432</a>   <font class="keyword">struct </font>Object : <font class="keyword">public</font> Key
00433   {
<a name="l00434"></a><a class="code" href="struct_FEData__Object.html#a0">00434</a>          <a class="code" href="struct_FEData__Object.html#a0">Object</a>(<font class="keywordtype">int</font> i) : Key( i, 0 ) { }
<a name="l00435"></a><a class="code" href="struct_FEData__Object.html#a1">00435</a>          <a class="code" href="struct_FEData__Object.html#a0">Object</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, 0 ) { }
00436          <font class="comment">// Semantic pact with KeyRep: text == 0 =&gt; not a real key</font>
00437   };
00438 
00439 
<a name="l00440"></a><a class="code" href="struct_FEData__CheckinType.html">00440</a>   <font class="keyword">struct </font>CheckinType : <font class="keyword">public</font> Key
00441   {
<a name="l00442"></a><a class="code" href="struct_FEData__CheckinType.html#a0">00442</a>          <a class="code" href="struct_FEData__CheckinType.html#a0">CheckinType</a>(<font class="keywordtype">int</font> i) : Key( i, "checkin_type" ) { }
<a name="l00443"></a><a class="code" href="struct_FEData__CheckinType.html#a1">00443</a>          <a class="code" href="struct_FEData__CheckinType.html#a0">CheckinType</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "checkin_type" ) { }
<a name="l00444"></a><a class="code" href="struct_FEData__CheckinType.html#a2">00444</a>          <a class="code" href="struct_FEData__CheckinType.html#a0">CheckinType</a>(<font class="keyword">const</font> Key&amp; K) : Key( K, "checkin_type" ) { }
00445   };
00446   <font class="comment">// Many menus and ARC slots are conditional, based purely on how the</font>
00447   <font class="comment">// selected objects were checked in (e.g., a group checked in as an</font>
00448   <font class="comment">// abelian group, not an FP group which is discovered to be</font>
00449   <font class="comment">// abelian).  Thus, this allows for associating, e.g., an enum</font>
00450   <font class="comment">// (type) value with an object, when and only when it is created,</font>
00451   <font class="comment">// and for subsequently using the value to choose the right menu item.</font>
00452 
00453 
00454   <font class="comment">// However, some menu items cannot make sense unless some piece of</font>
00455   <font class="comment">// information is known. For example, `Extend &lt;a free group&gt; by &lt;a map&gt;'</font>
00456   <font class="comment">// must not be posted unless the map is known to be an automorphism of</font>
00457   <font class="comment">// the group. Thus, in as few cases as we can get away with (to</font>
00458   <font class="comment">// stave off utter insanity), we dynamically update the FE database</font>
00459   <font class="comment">// with such crucial information when it is discovered. The following</font>
00460   <font class="comment">// provide the interface:</font>
00461   
00462   
<a name="l00463"></a><a class="code" href="struct_FEData__IsHomo.html">00463</a>   <font class="keyword">struct </font>IsHomo : <font class="keyword">public</font> Key
00464   {
<a name="l00465"></a><a class="code" href="struct_FEData__IsHomo.html#a0">00465</a>          <a class="code" href="struct_FEData__IsHomo.html#a0">IsHomo</a>(<font class="keywordtype">int</font> i) : Key( i, "homo" ) { }
<a name="l00466"></a><a class="code" href="struct_FEData__IsHomo.html#a1">00466</a>          <a class="code" href="struct_FEData__IsHomo.html#a0">IsHomo</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "homo" ) { }
00467   };
00468   
00469   
<a name="l00470"></a><a class="code" href="struct_FEData__IsIso.html">00470</a>   <font class="keyword">struct </font>IsIso : <font class="keyword">public</font> Key
00471   {
<a name="l00472"></a><a class="code" href="struct_FEData__IsIso.html#a0">00472</a>          <a class="code" href="struct_FEData__IsIso.html#a0">IsIso</a>(<font class="keywordtype">int</font> i) : Key( i, "iso" ) { }
<a name="l00473"></a><a class="code" href="struct_FEData__IsIso.html#a1">00473</a>          <a class="code" href="struct_FEData__IsIso.html#a0">IsIso</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "iso" ) { }
00474   };
00475   
00476   
<a name="l00477"></a><a class="code" href="struct_FEData__IsAuto.html">00477</a>   <font class="keyword">struct </font>IsAuto : <font class="keyword">public</font> Key
00478   {
<a name="l00479"></a><a class="code" href="struct_FEData__IsAuto.html#a0">00479</a>          <a class="code" href="struct_FEData__IsAuto.html#a0">IsAuto</a>(<font class="keywordtype">int</font> i) : Key( i, "auto" ) { }
<a name="l00480"></a><a class="code" href="struct_FEData__IsAuto.html#a1">00480</a>          <a class="code" href="struct_FEData__IsAuto.html#a0">IsAuto</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "auto" ) { }
00481   };
00482 
00483 
00484   <font class="comment">// The following are for static properties of algebraic objects which</font>
00485   <font class="comment">// are needed to determine whether a menu item, etc., should be posted.</font>
00486 
<a name="l00487"></a><a class="code" href="struct_FEData__Parent.html">00487</a>   <font class="keyword">struct </font>Parent : <font class="keyword">public</font> Key
00488   {
<a name="l00489"></a><a class="code" href="struct_FEData__Parent.html#a0">00489</a>          <a class="code" href="struct_FEData__Parent.html#a0">Parent</a>(<font class="keywordtype">int</font> i) : Key( i, "parent" ) { }
<a name="l00490"></a><a class="code" href="struct_FEData__Parent.html#a1">00490</a>          <a class="code" href="struct_FEData__Parent.html#a0">Parent</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "parent" ) { }
00491   };
00492 
<a name="l00493"></a><a class="code" href="struct_FEData__ParentGroup.html">00493</a>   <font class="keyword">struct </font>ParentGroup : <font class="keyword">public</font> Key
00494   {
<a name="l00495"></a><a class="code" href="struct_FEData__ParentGroup.html#a0">00495</a>          <a class="code" href="struct_FEData__ParentGroup.html#a0">ParentGroup</a>(<font class="keywordtype">int</font> i) : Key( Parent(i), "parent" ) { }
<a name="l00496"></a><a class="code" href="struct_FEData__ParentGroup.html#a1">00496</a>          <a class="code" href="struct_FEData__ParentGroup.html#a0">ParentGroup</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( Parent(o), "parent" ) { }
00497   };
00498   
<a name="l00499"></a><a class="code" href="struct_FEData__Domain.html">00499</a>   <font class="keyword">struct </font>Domain : <font class="keyword">public</font> Key
00500   {
<a name="l00501"></a><a class="code" href="struct_FEData__Domain.html#a0">00501</a>          <a class="code" href="struct_FEData__Domain.html#a0">Domain</a>(<font class="keywordtype">int</font> i) : Key( i, "domain" ) { }
<a name="l00502"></a><a class="code" href="struct_FEData__Domain.html#a1">00502</a>          <a class="code" href="struct_FEData__Domain.html#a0">Domain</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "domain" ) { }
00503   };
00504 
00505   
<a name="l00506"></a><a class="code" href="struct_FEData__Range.html">00506</a>   <font class="keyword">struct </font><a class="code" href="struct_Range.html">Range</a> : <font class="keyword">public</font> Key
00507   {
<a name="l00508"></a><a class="code" href="struct_FEData__Range.html#a0">00508</a>          <a class="code" href="struct_FEData__Range.html#a0">Range</a>(<font class="keywordtype">int</font> i) : Key( i, "range" ) { }
<a name="l00509"></a><a class="code" href="struct_FEData__Range.html#a1">00509</a>          <a class="code" href="struct_FEData__Range.html#a0">Range</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "range" ) { }
00510   };
00511   
00512 
<a name="l00513"></a><a class="code" href="struct_FEData__Oid.html">00513</a>   <font class="keyword">struct </font>Oid : <font class="keyword">public</font> Key
00514   {
<a name="l00515"></a><a class="code" href="struct_FEData__Oid.html#a0">00515</a>          <a class="code" href="struct_FEData__Oid.html#a0">Oid</a>(<font class="keywordtype">int</font> i) : Key( i, "oid" ) { }
<a name="l00516"></a><a class="code" href="struct_FEData__Oid.html#a1">00516</a>          <a class="code" href="struct_FEData__Oid.html#a0">Oid</a>(<a class="code" href="class_OID.html">OID</a> o) : Key( o, "oid" ) { }
00517   };
00518 
00519 
00520   <font class="comment">//-------------------------------------------------------------------------//</font>
00521   <font class="comment">//------------------------------ Name -------------------------------------//</font>
00522   <font class="comment">//-------------------------------------------------------------------------//</font>
00523 
<a name="l00524"></a><a class="code" href="struct_FEData__Name.html">00524</a>   <font class="keyword">struct </font>Name : <font class="keyword">public</font> Expression
00525   {
00526          <a class="code" href="struct_FEData__Name.html#a0">Name</a>(<font class="keywordtype">int</font> i);
00527          <a class="code" href="struct_FEData__Name.html#a0">Name</a>(<a class="code" href="class_OID.html">OID</a> o);
00528          <a class="code" href="struct_FEData__Name.html#a0">Name</a>(<font class="keyword">const</font> Expression&amp; E);
00529   };
00530 
00531 
00532   <font class="comment">// ----------------------------- Link ------------------------------------ //</font>
00533 
<a name="l00534"></a><a class="code" href="struct_FEData__Link.html">00534</a>   <font class="keyword">struct </font>Link : <font class="keyword">public</font> Text
00535   {
00536     <a class="code" href="struct_FEData__Link.html#a0">Link</a>( <font class="keyword">const</font> <a class="code" href="class_Chars.html">Chars</a>&amp; text, <font class="keyword">const</font> <a class="code" href="class_Chars.html">Chars</a>&amp; problemName,
00537           <font class="keyword">const</font> <a class="code" href="class_Chars.html">Chars</a>&amp; fileName, <font class="keywordtype">bool</font> isDynamic = <font class="keyword">false</font> );
00538   };
00539 
00540 
00541   <font class="comment">// ------------------------ SubProblemName ------------------------------- //</font>
00542 
<a name="l00543"></a><a class="code" href="struct_FEData__SubProblemName.html">00543</a>   <font class="keyword">struct </font>SubProblemName
00544   {
<a name="l00545"></a><a class="code" href="struct_FEData__SubProblemName.html#a0">00545</a>     <a class="code" href="struct_FEData__SubProblemName.html#a0">SubProblemName</a>( <a class="code" href="class_OID.html">OID</a> oid, <a class="code" href="class_ARCSlotID.html">ARCSlotID</a> asi ) 
00546       : theOid( oid.unwrap() ), theAsi( asi.unwrap() ) 
00547     { }
00548     
<a name="l00549"></a><a class="code" href="struct_FEData__SubProblemName.html#l0">00549</a>     <font class="keyword">friend</font> ostream&amp; <a class="code" href="struct_FEData__SubProblemName.html#l0">operator &lt;&lt; </a>( ostream&amp; ostr, <font class="keyword">const</font> SubProblemName&amp; n )<font class="keyword"> </font>{
00550       ostr &lt;&lt; <font class="stringliteral">"[get_subProblemName "</font> &lt;&lt; n.theOid &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; n.theAsi &lt;&lt; <font class="stringliteral">"]"</font>;
00551       <font class="keywordflow">return</font> ostr;
00552     }
00553  
00554   <font class="keyword">private</font>:
00555     
<a name="l00556"></a><a class="code" href="struct_FEData__SubProblemName.html#o0">00556</a>     <font class="keywordtype">int</font> theOid;
<a name="l00557"></a><a class="code" href="struct_FEData__SubProblemName.html#o1">00557</a>     <font class="keywordtype">int</font> theAsi;
00558   };
00559 
00560   <font class="comment">// ---------------------------- Banner ----------------------------------- //</font>
00561 
<a name="l00562"></a><a class="code" href="struct_FEData__Banner.html">00562</a>   <font class="keyword">struct </font>Banner
00563   {
<a name="l00564"></a><a class="code" href="struct_FEData__Banner.html#a0">00564</a>     <a class="code" href="struct_FEData__Banner.html#a0">Banner</a>( <a class="code" href="class_OID.html">OID</a> oid ) 
00565       : theOid( oid.unwrap() )
00566     { }
00567     
<a name="l00568"></a><a class="code" href="struct_FEData__Banner.html#l0">00568</a>     <font class="keyword">friend</font> ostream&amp; <a class="code" href="struct_FEData__Banner.html#l0">operator &lt;&lt; </a>( ostream&amp; ostr, <font class="keyword">const</font> Banner&amp; b )<font class="keyword"> </font>{
00569       ostr &lt;&lt; <font class="stringliteral">"[get_viewBanner "</font> &lt;&lt; b.theOid &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; <font class="stringliteral">"]"</font>;
00570       <font class="keywordflow">return</font> ostr;
00571     }
00572  
00573   <font class="keyword">private</font>:
00574     
<a name="l00575"></a><a class="code" href="struct_FEData__Banner.html#o0">00575</a>     <font class="keywordtype">int</font> theOid;
00576   };
00577 
00578 };
00579 
00580 <font class="preprocessor">#endif</font>
</font></pre></div><hr><address><small>Generated at Tue Jun 19 09:49:37 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
