<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/general/include/Set.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/general/include/Set.h</h1><a href="Set_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> *   $Id: Set.h,v 1.5 1996/08/20 22:58:48 alex Exp $</font>
00003 <font class="comment"> */</font>
00004 
00005 <font class="comment">// Copyright (C) 1994 The New York Group Theory Cooperative</font>
00006 <font class="comment">// See magnus/doc/COPYRIGHT for the full notice.</font>
00007 
00008 <font class="comment">// Contents: Definition and implementation of classes:</font>
00009 <font class="comment">//           SetData, SetIteratorData, SetOf, SetIterator.</font>
00010 <font class="comment">//</font>
00011 <font class="comment">// Everything is globbed together for now to keep g++ 2.5.8 happy.</font>
00012 <font class="comment">//</font>
00013 <font class="comment">// Principal Author: Roger Needham</font>
00014 <font class="comment">//</font>
00015 <font class="comment">// Status: Useable.</font>
00016 <font class="comment">//</font>
00017 <font class="comment">// Revision History:</font>
00018 <font class="comment">//</font>
00019 <font class="comment">// * 2/95 sr added</font>
00020 <font class="comment">//      int hashElement(const T &amp; t) const;</font>
00021 <font class="comment">//      to avoid calling t.hash() directly. This accommodates SetOf&lt;int&gt;</font>
00022 <font class="comment">//</font>
00023 <font class="comment">// * 01/96 Dmitry B. implemented IPC tools.</font>
00024 <font class="comment">//</font>
00025 <font class="comment">// * 7/96 Dmitry B. made porting to gcc 2.7.2.</font>
00026 <font class="comment">//</font>
00027 <font class="comment">// Special Notes:</font>
00028 <font class="comment">//</font>
00029 <font class="comment">// * To instantiate SetOf&lt;T&gt;, class T must have</font>
00030 <font class="comment">//   1) An assignment operator</font>
00031 <font class="comment">//   2) A copy constructor</font>
00032 <font class="comment">//   3) An == operator</font>
00033 <font class="comment">//   4) A destructor</font>
00034 <font class="comment">//   5) A method int hash() const  (need not return positive ints)</font>
00035 <font class="comment">//</font>
00036 <font class="comment">// * The iterator template is parameterized by element type rather than</font>
00037 <font class="comment">//   container class type, so g++ 2.5.8 will buy it. We'll switch to the</font>
00038 <font class="comment">//   latter someday. Code which uses iterators will then break, but will be</font>
00039 <font class="comment">//   easy to fix.</font>
00040 <font class="comment">//</font>
00041 <font class="comment">// * The set-theoretic operators are not global, because I'm paranoid about</font>
00042 <font class="comment">//   the following: since there is a conversion T -&gt; SetOf&lt;T&gt;, T would aquire</font>
00043 <font class="comment">//   a host of confusing new operators. For example, if</font>
00044 <font class="comment">//     inline SetOf&lt;T&gt; operator &amp; (const SetOf&lt;T&gt;&amp; S1, const SetOf&lt;T&gt;&amp; S2) {</font>
00045 <font class="comment">//       return setIntersection(S1, S2);</font>
00046 <font class="comment">//     }</font>
00047 <font class="comment">//   then</font>
00048 <font class="comment">//     T t1, t2; T t = t1 &amp; t2;</font>
00049 <font class="comment">//   would be caught by the compiler, but</font>
00050 <font class="comment">//     T t1, t2, t3; if ( (t1 &amp; t2) == t3 ) {...}</font>
00051 <font class="comment">//   would not (assuming T has a default constructor).</font>
00052 <font class="comment">//   Keeping the operators as members is not much of a burden; because of</font>
00053 <font class="comment">//   the symmetry of the operators, one can recast any desired expression</font>
00054 <font class="comment">//   so that a genuine SetOf&lt;T&gt; is the left operand.</font>
00055 <font class="comment">//   Also, this decision is reversible without breaking existing code.</font>
00056 <font class="comment">//</font>
00057 <font class="comment">// Things to Deal With:</font>
00058 <font class="comment">//</font>
00059 <font class="comment">// * Adopt a consistent policy on the return type of assignment-like</font>
00060 <font class="comment">//   operators (val vs. ref). This affects other classes as well.</font>
00061 <font class="comment">//   To bear in mind / investigate is the effect the choice has on</font>
00062 <font class="comment">//   generating supplementary constructor calls, and the fact that the</font>
00063 <font class="comment">//   decision cascades through to assignment-like operators and</font>
00064 <font class="comment">//   functions which call other ones.</font>
00065 <font class="comment">//</font>
00066 <font class="comment">// Implementation Notes:</font>
00067 <font class="comment">//</font>
00068 <font class="comment">// * SetOfs are implemented as open hash tables. They are rehashed (doubling</font>
00069 <font class="comment">//   or halving number of buckets) when the number of elements exceeds</font>
00070 <font class="comment">//   FULLNESS_FACTOR * (number of buckets) or falls below</font>
00071 <font class="comment">//   (number of buckets) / FULLNESS_FACTOR.</font>
00072 <font class="comment">//   The (cheap) decision whether to rehash is made during each insert and</font>
00073 <font class="comment">//   delete, except that if the user specifies an initial size, the new size</font>
00074 <font class="comment">//   will not go below the specified size until the user calls `rehash()'.</font>
00075 <font class="comment">//</font>
00076 <font class="comment">// * We could choose the number of buckets more cleverly, and keep track</font>
00077 <font class="comment">//   of whether any bucket is getting too big. In that case, we'd resize</font>
00078 <font class="comment">//   +/- a small number to spread things out.</font>
00079 
00080 
00081 <font class="preprocessor">#ifndef _SET_H_</font>
00082 <font class="preprocessor"></font><font class="preprocessor">#define _SET_H_</font>
00083 <font class="preprocessor"></font>
00084 <font class="preprocessor">#include "<a class="code" href="global_h.html">global.h</a>"</font>
00085 <font class="preprocessor">#include "<a class="code" href="RefCounter_h.html">RefCounter.h</a>"</font>
00086 <font class="preprocessor">#include "<a class="code" href="PureRep_h.html">PureRep.h</a>"</font>
00087 <font class="preprocessor">#include "<a class="code" href="ObjectOf_h.html">ObjectOf.h</a>"</font>
00088 <font class="preprocessor">#include "<a class="code" href="Cell_h.html">Cell.h</a>"</font>
00089 
00090 
00091 template &lt;class T&gt; <font class="keyword">class </font><a class="code" href="class_SetIteratorData.html">SetIteratorData</a>;
00092 <font class="comment">// Forward declaration for friend declarations.</font>
00093 
00094 
00095 <font class="comment">//---------------------- class SetData ----------------------------------</font>
00096 
00097 
<a name="l00098"></a><a class="code" href="Set_h.html#a0">00098</a> <font class="preprocessor">#define FULLNESS_FACTOR 2</font>
00099 <font class="preprocessor"></font><font class="comment">// Must be &gt;= 2.</font>
00100 
00101 
00102 template&lt;class T&gt;
<a name="l00103"></a><a class="code" href="class_SetData.html">00103</a> <font class="keyword">class </font><a class="code" href="class_SetData.html">SetData</a> : <font class="keyword">public</font> <a class="code" href="class_RefCounter.html">RefCounter</a> {
00104 
00105 <font class="keyword">public</font>:
00106 
<a name="l00107"></a><a class="code" href="class_SetData.html#a0">00107</a>   <a class="code" href="class_SetData.html#a0">SetData</a>(<font class="keywordtype">int</font> size)
00108   <font class="comment">// size is suggestion (possibly very bad) of eventual set cardinality.</font>
00109   <font class="comment">// The result represents an empty set.</font>
00110   {
00111          <font class="comment">// Make sure size has form 2^n - 1.</font>
00112          <font class="keywordflow">if</font> ( size &lt; 0 ) size = 0;
00113          userSize = ( size &gt; 1 ) ? size : 0;
00114          <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> realSize = 1;
00115          <font class="keywordflow">while</font> ( size &gt;&gt;= 1 ) realSize = (realSize &lt;&lt; 1) + 1;
00116          
00117          numberOfBuckets = realSize;
00118          hashTable = <font class="keyword">new</font> <a class="code" href="class_Cell.html">CellType</a>*[realSize];
00119          
00120          <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = 0; i &lt; realSize; i++ )
00121                 hashTable[i] = NULL;
00122          
00123          numberOfElements = 0;
00124   }
00125 
<a name="l00126"></a><a class="code" href="class_SetData.html#a1">00126</a>   <a class="code" href="class_SetData.html#a0">SetData</a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"></font>
00127 <font class="keyword">  </font>{
00128          userSize = 0;
00129          numberOfBuckets = 1;
00130          hashTable = <font class="keyword">new</font> <a class="code" href="class_Cell.html">CellType</a>*[1];
00131          hashTable[0] = <font class="keyword">new</font> <a class="code" href="class_SetData.html#t0">CellType</a>(t);
00132          numberOfElements = 1;
00133   }
00134 
<a name="l00135"></a><a class="code" href="class_SetData.html#a2">00135</a>   <a class="code" href="class_SetData.html#a0">SetData</a>(<font class="keyword">const</font> <a class="code" href="class_SetData.html">SetData</a>&amp; sd)
00136   <font class="comment">// Copy constructor does deep copy.</font>
00137   {
00138          userSize = sd.userSize;
00139          numberOfElements = sd.numberOfElements;
00140          numberOfBuckets = sd.numberOfBuckets;
00141          hashTable = <font class="keyword">new</font> <a class="code" href="class_Cell.html">CellType</a>*[numberOfBuckets];
00142          <a class="code" href="class_Cell.html">CellType</a> *bucket;
00143          <a class="code" href="class_Cell.html">CellType</a> **newBucket;
00144          
00145          <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = 0; i &lt; numberOfBuckets; i++ ) {
00146                 hashTable[i] = NULL;
00147                 newBucket = &amp;hashTable[i];
00148                 bucket = sd.hashTable[i];
00149                 <font class="keywordflow">while</font> ( bucket != NULL ) {
00150                   *newBucket = <font class="keyword">new</font> <a class="code" href="class_SetData.html#t0">CellType</a>(*bucket);
00151                   newBucket = &amp;((*newBucket)-&gt;nextCell);
00152                   bucket = bucket-&gt;nextCell;
00153                 }
00154          }
00155   }
00156 
<a name="l00157"></a><a class="code" href="class_SetData.html#a3">00157</a>   <a class="code" href="class_SetData.html#a3">~SetData</a>()
00158   <font class="comment">// Delete everything associated with this SetData. Reference counting</font>
00159   <font class="comment">// spares the T's if necessary.</font>
00160   {
00161          <font class="keywordflow">if</font> ( hashTable ) {
00162                 <a class="code" href="class_SetData.html#a8">removeAllElements</a>();
00163                 <font class="keyword">delete</font> [] hashTable;
00164                 hashTable = NULL;
00165          }
00166   }
00167 
<a name="l00168"></a><a class="code" href="class_SetData.html#a4">00168</a>   <a class="code" href="class_SetData.html">SetData</a>* <a class="code" href="class_SetData.html#a4">clone</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <font class="keyword">new</font> <a class="code" href="class_SetData.html#a0">SetData</a>(*<font class="keyword">this</font>); }
00169 
<a name="l00170"></a><a class="code" href="class_SetData.html#a5">00170</a>   Bool <a class="code" href="Property_h.html#a1">operator == </a>( <font class="keyword">const</font> <a class="code" href="class_SetData.html">SetData</a>&amp; sd )<font class="keyword"> const</font>
00171 <font class="keyword">  </font>{
00172          <font class="keywordflow">if</font> ( numberOfElements != sd.numberOfElements ) <font class="keywordflow">return</font> FALSE;
00173          <font class="keywordflow">for</font> ( <font class="keywordtype">int</font> i = 0; i &lt; numberOfBuckets; i++ ) {
00174                 <a class="code" href="class_Cell.html">CellType</a>* scan = hashTable[i];
00175                 <font class="keywordflow">while</font> ( scan != NULL ) {
00176                   <font class="keywordflow">if</font> ( !sd.<a class="code" href="class_SetData.html#a10">contains</a>(scan-&gt;<a class="code" href="class_Cell.html#a6">getContents</a>()) ) <font class="keywordflow">return</font> FALSE;
00177                   scan = scan-&gt;nextCell;
00178                 }
00179          }
00180          <font class="keywordflow">return</font> TRUE;
00181   }
00182 
00183   <font class="keywordtype">int</font> <a class="code" href="class_SetData.html#a6">hashElement</a>(<font class="keyword">const</font> T &amp; t) <font class="keyword">const</font>;
00184 
<a name="l00185"></a><a class="code" href="class_SetData.html#a7">00185</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetData.html#a7">rehash</a>( Bool calledByUser = FALSE )<font class="keyword"></font>
00186 <font class="keyword">  </font>{
00187          <font class="keywordflow">if</font> ( calledByUser ) userSize = 0;
00188 
00189          <font class="keywordtype">int</font> newNumberOfBuckets;
00190 
00191          <font class="keywordflow">if</font> ( numberOfElements &gt; FULLNESS_FACTOR * numberOfBuckets )
00192                 newNumberOfBuckets = (numberOfBuckets &lt;&lt; 1) + 1;
00193          <font class="keywordflow">else</font> <font class="keywordflow">if</font> ( numberOfElements &lt; numberOfBuckets / FULLNESS_FACTOR ) {
00194                 <font class="comment">// Assumes FULLNESS_FACTOR &gt;= 2, so won't resize to 0.</font>
00195                 <font class="keywordflow">if</font> ( !userSize || (numberOfBuckets &gt;&gt; 1) &gt;= userSize )
00196                   newNumberOfBuckets = numberOfBuckets &gt;&gt; 1;
00197                 <font class="keywordflow">else</font> <font class="keywordflow">return</font>;
00198          }
00199          <font class="keywordflow">else</font> <font class="keywordflow">return</font>;
00200 
00201          <font class="keywordtype">int</font> i;
00202 
00203          <a class="code" href="class_Cell.html">CellType</a> **newHashTable = <font class="keyword">new</font> <a class="code" href="class_Cell.html">CellType</a>*[newNumberOfBuckets];
00204          <font class="keywordflow">for</font> ( i = 0; i &lt; newNumberOfBuckets; i++ )
00205                 newHashTable[i] = NULL;
00206          
00207          <font class="comment">// Now cycle through the old set, rehash its elements, detach them and</font>
00208          <font class="comment">// reinsert them in newHashTable.</font>
00209          
00210          <a class="code" href="class_Cell.html">CellType</a> *curCell, *tmp;
00211          <font class="keywordtype">int</font> index;
00212          <font class="keywordflow">for</font>( i = 0; i &lt; numberOfBuckets; i++ ) {
00213                 curCell = hashTable[i];
00214                 <font class="keywordflow">while</font> ( curCell != NULL ) {
00215                   tmp = curCell-&gt;nextCell;
00216                   
00217                   <font class="comment">// Rehash and insert entire cell into newHashTable</font>
00218                   index = <a class="code" href="global_h.html#a7">abs</a>(<a class="code" href="class_SetData.html#a6">hashElement</a>(curCell-&gt;<a class="code" href="class_Cell.html#a6">getContents</a>())) % newNumberOfBuckets;
00219                   curCell-&gt;nextCell = newHashTable[index];
00220                   newHashTable[index] = curCell;
00221                   
00222                   curCell = tmp;
00223                 }
00224                 hashTable[i] = NULL;
00225          }
00226          
00227          <font class="comment">// Put all private variables back together and clean up.</font>
00228          numberOfBuckets = newNumberOfBuckets;
00229          <font class="keyword">delete</font> [] hashTable;
00230          hashTable = newHashTable;
00231   }
00232 
<a name="l00233"></a><a class="code" href="class_SetData.html#a8">00233</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetData.html#a8">removeAllElements</a>()
00234   <font class="comment">// Make *this represent an empty set, possibly keeping, e.g., a large</font>
00235   <font class="comment">// but empty bucket table.</font>
00236   {
00237          <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = 0; i &lt; numberOfBuckets; i++ ) {
00238                 <a class="code" href="class_Cell.html">CellType</a> *bucket = hashTable[i];
00239                 <font class="keywordflow">while</font> ( bucket != NULL ) {
00240                   <a class="code" href="class_Cell.html">CellType</a> *tmp = bucket;
00241                   bucket = bucket-&gt;nextCell;
00242                   <font class="keyword">delete</font> tmp;
00243                 }
00244                 hashTable[i] = NULL;
00245          }
00246          numberOfElements = 0;
00247   }
00248 
<a name="l00249"></a><a class="code" href="class_SetData.html#a9">00249</a>   <font class="keywordtype">int</font> <a class="code" href="class_SetData.html#a9">cardinality</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> numberOfElements; }
00250 
<a name="l00251"></a><a class="code" href="class_SetData.html#a10">00251</a>   Bool <a class="code" href="class_SetData.html#a10">contains</a>(<font class="keyword">const</font> T&amp; e)<font class="keyword"> const</font>
00252 <font class="keyword">  </font>{
00253          <font class="keywordtype">int</font> index = <a class="code" href="global_h.html#a7">abs</a>(<a class="code" href="class_SetData.html#a6">hashElement</a>(e)) % numberOfBuckets;
00254          <a class="code" href="class_Cell.html">CellType</a>* search = hashTable[index];
00255          <font class="keywordflow">while</font> ( search != NULL ) {
00256                 <font class="keywordflow">if</font> ( e == search-&gt;<a class="code" href="class_Cell.html#a6">getContents</a>() ) <font class="keywordflow">return</font> TRUE;
00257                 search = search-&gt;nextCell;
00258          }
00259          <font class="keywordflow">return</font> FALSE;
00260   }
00261 
<a name="l00262"></a><a class="code" href="class_SetData.html#a11">00262</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetData.html#a11">adjoinElement</a>(<font class="keyword">const</font> T&amp; e)<font class="keyword"></font>
00263 <font class="keyword">  </font>{
00264          <a class="code" href="class_SetData.html#a7">rehash</a>();
00265          <font class="keywordtype">int</font> index = <a class="code" href="global_h.html#a7">abs</a>(<a class="code" href="class_SetData.html#a6">hashElement</a>(e)) % numberOfBuckets;
00266          <a class="code" href="class_Cell.html">CellType</a>* search = hashTable[index];
00267          <font class="keywordflow">while</font> ( search != NULL ) {
00268                 <font class="keywordflow">if</font> ( e == search-&gt;<a class="code" href="class_Cell.html#a6">getContents</a>() ) <font class="keywordflow">return</font>;
00269                 search = search-&gt;nextCell;
00270          }
00271          search = <font class="keyword">new</font> <a class="code" href="class_SetData.html#t0">CellType</a>(e);
00272          search-&gt;nextCell = hashTable[index];
00273          hashTable[index] = search;
00274          ++numberOfElements;
00275   }
00276 
<a name="l00277"></a><a class="code" href="class_SetData.html#a12">00277</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetData.html#a12">removeElement</a>(<font class="keyword">const</font> T&amp; e)<font class="keyword"></font>
00278 <font class="keyword">  </font>{
00279          <font class="keywordtype">int</font> index = <a class="code" href="global_h.html#a7">abs</a>(<a class="code" href="class_SetData.html#a6">hashElement</a>(e)) % numberOfBuckets;
00280          <a class="code" href="class_Cell.html">CellType</a>* search = hashTable[index];
00281          <font class="keywordflow">if</font> ( search != NULL )
00282                 <font class="keywordflow">if</font> ( e == search-&gt;<a class="code" href="class_Cell.html#a6">getContents</a>() )
00283                   hashTable[index] = search-&gt;nextCell;
00284                 <font class="keywordflow">else</font> {
00285                   <a class="code" href="class_Cell.html">CellType</a>* prev = search;
00286                   <font class="keywordflow">while</font> ( (search = search-&gt;nextCell) != NULL ) {
00287                          <font class="keywordflow">if</font> ( e == search-&gt;<a class="code" href="class_Cell.html#a6">getContents</a>() ) {
00288                                 prev-&gt;nextCell = search-&gt;nextCell;
00289                                 <font class="keywordflow">break</font>;
00290                          }
00291                          prev = search;
00292                   }
00293                 }
00294          <font class="keywordflow">if</font> ( search != NULL ) {
00295                 <font class="keyword">delete</font> search;
00296                 --numberOfElements;
00297                 <a class="code" href="class_SetData.html#a7">rehash</a>();
00298          }
00299   }
00300 
<a name="l00301"></a><a class="code" href="class_SetData.html#a13">00301</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetData.html#a13">printOn</a>(ostream&amp; ostr)<font class="keyword"> const </font>{
00302          ostr &lt;&lt; <font class="stringliteral">"\nSet of cardinality: "</font> &lt;&lt; numberOfElements &lt;&lt; <font class="stringliteral">"\n{"</font> &lt;&lt; endl;
00303          <font class="keywordflow">for</font> ( <font class="keywordtype">int</font> i = 0; i &lt; numberOfBuckets; i++ ) {
00304                 <a class="code" href="class_Cell.html">CellType</a>* scan = hashTable[i];
00305                 <font class="keywordflow">while</font> ( scan != NULL ) {
00306                   ostr &lt;&lt; scan-&gt;getContents() &lt;&lt; endl;
00307                   scan = scan-&gt;nextCell;
00308                 }
00309          }
00310          ostr &lt;&lt; <font class="stringliteral">"\n}"</font> &lt;&lt; endl;
00311   }
00312 
00313 <font class="comment"></font>
00314 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00315 <font class="comment"></font>  <font class="comment">//                                                                     //</font>
00316   <font class="comment">// IPC tools:                                                          //</font>
00317   <font class="comment">//                                                                     //</font><font class="comment"></font>
00318 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00319 <font class="comment"></font>
00320   <font class="keywordtype">void</font> <a class="code" href="class_SetData.html#a14">write</a>( ostream&amp; ostr ) <font class="keyword">const</font>;
00321  
00322   <font class="keywordtype">void</font> <a class="code" href="class_SetData.html#a15">read</a>( istream&amp; istr );
00323  
00324 
00325 <font class="preprocessor">  #ifdef DEBUG</font>
00326 <font class="preprocessor"></font>  <font class="keywordtype">void</font> printStats() <font class="keyword">const</font>
00327   <font class="comment">// Print statistics for hash table (for testing efficiency).</font>
00328   {
00329          cout &lt;&lt; <font class="stringliteral">"\n\nHash table statistics:\n\n"</font>;
00330          cout &lt;&lt; <font class="stringliteral">"User specified size = "</font>;
00331          <font class="keywordflow">if</font> ( userSize ) cout &lt;&lt; userSize &lt;&lt; endl;
00332          <font class="keywordflow">else</font> cout &lt;&lt; <font class="stringliteral">"(cleared by call to `rehash()')"</font> &lt;&lt; endl;
00333          cout &lt;&lt; <font class="stringliteral">"Number of entries = "</font> &lt;&lt; numberOfElements &lt;&lt; endl;
00334          cout &lt;&lt; <font class="stringliteral">"Number of buckets = "</font> &lt;&lt; numberOfBuckets &lt;&lt; endl;
00335          
00336          <font class="keywordtype">double</font> sum = 0;
00337          <font class="keywordtype">double</font> sumSquares = 0;
00338          <font class="keywordtype">long</font> maxLen = 0;
00339          <font class="keywordtype">long</font> minLen = 1000000;
00340          <font class="keywordtype">long</font> numEmpties = 0;
00341          <font class="keywordtype">long</font> len;
00342          <a class="code" href="class_Cell.html">CellType</a> *cPtr;
00343          <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = 0; i &lt; numberOfBuckets; i++ ) {
00344                 cPtr = hashTable[i];
00345                 <font class="keywordflow">if</font> ( !cPtr ) ++numEmpties;
00346                 len = 0;
00347                 <font class="keywordflow">while</font> ( cPtr ) { len++; cPtr = cPtr-&gt;nextCell; }
00348                 maxLen = <a class="code" href="global_h.html#a6">max</a>( len, maxLen );
00349                 minLen = <a class="code" href="global_h.html#a5">min</a>( len, minLen );
00350                 sum += len;
00351                 sumSquares += len*len;
00352          }
00353          <font class="keywordtype">long</font> numNonEmpty = numberOfBuckets-numEmpties;
00354          <font class="keywordtype">double</font> mean = sum / numNonEmpty;
00355          cout &lt;&lt; <font class="stringliteral">"Largest bucket size = "</font> &lt;&lt; maxLen &lt;&lt; endl;
00356          cout &lt;&lt; <font class="stringliteral">"Smallest bucket size = "</font> &lt;&lt; minLen &lt;&lt; endl;
00357          cout &lt;&lt; <font class="stringliteral">"Average non-empty bucket size = "</font> &lt;&lt; mean &lt;&lt; endl;
00358          cout &lt;&lt; <font class="stringliteral">"Number of empty buckets = "</font> &lt;&lt; numEmpties;
00359          cout &lt;&lt; <font class="stringliteral">", or "</font> &lt;&lt; 100*numEmpties/numberOfBuckets &lt;&lt; <font class="stringliteral">"%"</font> &lt;&lt; endl;
00360          cout &lt;&lt; <font class="stringliteral">"Sample standard deviation in non-empty bucket size = sqrt("</font>;
00361          cout &lt;&lt; ((sumSquares - 2*mean*sum + numNonEmpty*mean*mean)/(numNonEmpty-1)) &lt;&lt; <font class="stringliteral">")\n"</font> &lt;&lt; endl;
00362   }
00363 <font class="preprocessor">  #endif</font>
00364 <font class="preprocessor"></font>
00365 <font class="preprocessor">  #ifdef DEBUG</font>
00366 <font class="preprocessor"></font>  <font class="keywordtype">void</font> printRep() <font class="keyword">const</font>
00367   <font class="comment">// Print a legible representation of the hash table.</font>
00368   {
00369          cout &lt;&lt; <font class="stringliteral">"\n\nHash table:\n-----------\n\n"</font>;
00370          <a class="code" href="class_Cell.html">CellType</a> *cPtr;
00371          <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = 0; i &lt; numberOfBuckets; i++ ) {
00372                 cout &lt;&lt; i &lt;&lt; <font class="stringliteral">": "</font>;
00373                 cPtr = hashTable[i];
00374                 <font class="keywordflow">while</font> ( cPtr ) {
00375                   cout &lt;&lt; <font class="stringliteral">". "</font>;
00376                   cPtr = cPtr-&gt;nextCell;
00377                 }
00378                 cout &lt;&lt; endl;
00379          }
00380   }
00381 <font class="preprocessor">  #endif</font>
00382 <font class="preprocessor"></font>  
00383   
00384 <font class="comment">//@db private: </font>
00385 <font class="keyword">protected</font>:
00386 
<a name="l00387"></a><a class="code" href="class_SetData.html#t0">00387</a>   <font class="keyword">typedef</font> <a class="code" href="class_Cell.html">Cell&lt;T&gt;</a> <a class="code" href="class_Cell.html">CellType</a>;
00388 
<a name="l00389"></a><a class="code" href="class_SetData.html#n0">00389</a>   <font class="keyword">friend</font> <a class="code" href="class_SetIteratorData.html">SetIteratorData&lt;T&gt;</a>;
00390 
00391 
00392   <font class="comment">// Data members:</font>
00393 
<a name="l00394"></a><a class="code" href="class_SetData.html#n1">00394</a>   <font class="keywordtype">int</font>         userSize;         <font class="comment">// Initial size &gt; 1 given by the user,</font>
00395                                 <font class="comment">// or 0 if none specified. Reset to 0</font>
00396                                 <font class="comment">// only by rehash(TRUE).</font>
<a name="l00397"></a><a class="code" href="class_SetData.html#n2">00397</a>   <font class="keywordtype">int</font>         numberOfElements;
<a name="l00398"></a><a class="code" href="class_SetData.html#n3">00398</a>   <font class="keywordtype">int</font>         numberOfBuckets;  <font class="comment">// Equal to 2^n - 1 for some n.</font>
<a name="l00399"></a><a class="code" href="class_SetData.html#n4">00399</a>   <a class="code" href="class_Cell.html">CellType</a>**  hashTable;
00400 
00401 };
00402 
00403 
00404 <font class="comment">//---------------------- class SetOf -----------------------------------</font>
00405 
00406 
00407 template&lt;class T&gt;
<a name="l00408"></a><a class="code" href="class_SetOf.html">00408</a> <font class="keyword">class </font><a class="code" href="class_SetOf.html">SetOf</a> : <font class="keyword">public</font> <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt; SetData&lt;T&gt; &gt; {
00409 
00410 <font class="keyword">public</font>:
00411 
<a name="l00412"></a><a class="code" href="class_SetOf.html#s0">00412</a>   <font class="keyword">typedef</font> T SetElementType; <font class="comment">// Export this</font>
00413 
<a name="l00414"></a><a class="code" href="class_SetOf.html#a0">00414</a>   <a class="code" href="class_SetOf.html#a0">SetOf</a>( <font class="keywordtype">int</font> size = 1 ) : <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt;<a class="code" href="struct_VectorPtrRep.html">Rep</a>&gt;( new <a class="code" href="struct_VectorPtrRep.html">Rep</a>(size) ) { }
00415   <font class="comment">// Give rough advice about eventual cardinality. The result is an empty set.</font>
00416   <font class="comment">// If you specify size &gt; 1, the underlying hash table never shrinks</font>
00417   <font class="comment">// below that size until you call `rehash()'.</font>
00418   <font class="comment">// Note that because of hash table doubling, it costs only O(n) to build</font>
00419   <font class="comment">// up a set of cardinality n from the default.</font>
00420 
<a name="l00421"></a><a class="code" href="class_SetOf.html#a1">00421</a>   <a class="code" href="class_SetOf.html#a0">SetOf</a>( <font class="keyword">const</font> T&amp; t ) : <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt;<a class="code" href="struct_VectorPtrRep.html">Rep</a>&gt;( new <a class="code" href="struct_VectorPtrRep.html">Rep</a>(t) ) { }
00422   <font class="comment">// Cast constructor wraps element in a set.</font>
00423 
00424   <font class="comment">// Use compiler's copy constructor, operator=, and destructor.</font>
00425 
00426   <font class="comment">// Standard set-theoretic operators, defined in terms of member</font>
00427   <font class="comment">// functions:</font>
00428 
<a name="l00429"></a><a class="code" href="class_SetOf.html#a2">00429</a>   Bool <a class="code" href="Property_h.html#a1">operator == </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00430          <font class="keywordflow">return</font> <a class="code" href="class_SetOf.html#a19">equalTo</a>(S);
00431   }
00432 
<a name="l00433"></a><a class="code" href="class_SetOf.html#a3">00433</a>   Bool <a class="code" href="Property_h.html#a2">operator != </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00434          <font class="keywordflow">return</font> !<a class="code" href="class_SetOf.html#a19">equalTo</a>(S);
00435   }
00436 
<a name="l00437"></a><a class="code" href="class_SetOf.html#a4">00437</a>   Bool <a class="code" href="Polynomial_h.html#a2">operator &lt; </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00438          <font class="keywordflow">return</font> S.<a class="code" href="class_SetOf.html#a22">properlyContains</a>(*<font class="keyword">this</font>);
00439   }
00440 
<a name="l00441"></a><a class="code" href="class_SetOf.html#a5">00441</a>   Bool <a class="code" href="Generator_h.html#a4">operator &lt;= </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00442          <font class="keywordflow">return</font> S.<a class="code" href="class_SetOf.html#a20">contains</a>(*<font class="keyword">this</font>);
00443   }
00444 
<a name="l00445"></a><a class="code" href="class_SetOf.html#a6">00445</a>   Bool <a class="code" href="Polynomial_h.html#a3">operator &gt; </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00446          <font class="keywordflow">return</font> <a class="code" href="class_SetOf.html#a22">properlyContains</a>(S);
00447   }
00448 
<a name="l00449"></a><a class="code" href="class_SetOf.html#a7">00449</a>   Bool <a class="code" href="Generator_h.html#a6">operator &gt;= </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00450          <font class="keywordflow">return</font> <a class="code" href="class_SetOf.html#a20">contains</a>(S);
00451   }
00452 
<a name="l00453"></a><a class="code" href="class_SetOf.html#a8">00453</a>   Bool <a class="code" href="Generator_h.html#a6">operator &gt;= </a>( <font class="keyword">const</font> T&amp; e )<font class="keyword"> const </font>{
00454          <font class="keywordflow">return</font> <a class="code" href="class_SetOf.html#a20">contains</a>(e);
00455   }
00456 
<a name="l00457"></a><a class="code" href="class_SetOf.html#a9">00457</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="class_SetOf.html#a9">operator &amp; </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00458          <font class="keywordflow">return</font> <a class="code" href="Set_h.html#a2">setIntersection</a>(*<font class="keyword">this</font>, S);
00459   }
00460 
<a name="l00461"></a><a class="code" href="class_SetOf.html#a10">00461</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="class_SetOf.html#a10">operator &amp;= </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> </font>{
00462          <a class="code" href="class_SetOf.html#a25">shrinkToIntersectionWith</a>(S);
00463          <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00464   }
00465 
<a name="l00466"></a><a class="code" href="class_SetOf.html#a11">00466</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="NielsenTransformations_h.html#a5">operator | </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00467          <font class="keywordflow">return</font> <a class="code" href="Set_h.html#a1">setUnion</a>(*<font class="keyword">this</font>, S);
00468   }
00469 
<a name="l00470"></a><a class="code" href="class_SetOf.html#a12">00470</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="Whitehead_h.html#a11">operator |= </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> </font>{
00471          <a class="code" href="class_SetOf.html#a26">adjoinElements</a>(S);
00472          <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00473   }
00474 
<a name="l00475"></a><a class="code" href="class_SetOf.html#a13">00475</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="Whitehead_h.html#a11">operator |= </a>( <font class="keyword">const</font> T&amp; e )<font class="keyword"> </font>{
00476          <a class="code" href="class_SetOf.html#a23">adjoinElement</a>(e);
00477          <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00478   }
00479 
<a name="l00480"></a><a class="code" href="class_SetOf.html#a14">00480</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="class_SetOf.html#a14">operator - </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00481          <font class="keywordflow">return</font> <a class="code" href="Set_h.html#a3">setMinus</a>(*<font class="keyword">this</font>, S);
00482   }
00483 
<a name="l00484"></a><a class="code" href="class_SetOf.html#a15">00484</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="class_SetOf.html#a15">operator -= </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> </font>{
00485          <a class="code" href="class_SetOf.html#a27">removeElements</a>(S);
00486          <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00487   }
00488 
<a name="l00489"></a><a class="code" href="class_SetOf.html#a16">00489</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="class_SetOf.html#a15">operator -= </a>( <font class="keyword">const</font> T&amp; e )<font class="keyword"> </font>{
00490          <a class="code" href="class_SetOf.html#a24">removeElement</a>(e);
00491          <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00492   }
00493 
<a name="l00494"></a><a class="code" href="class_SetOf.html#a17">00494</a>   <a class="code" href="class_SetOf.html">SetOf</a> <a class="code" href="class_SetOf.html#a17">operator ^ </a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> const </font>{
00495          <font class="keywordflow">return</font> <a class="code" href="Set_h.html#a4">setSymmetricDifference</a>(*<font class="keyword">this</font>, S);
00496   }
00497 
00498   <font class="comment">// Member functions:</font>
00499 
<a name="l00500"></a><a class="code" href="class_SetOf.html#a18">00500</a>   <font class="keywordtype">int</font> <a class="code" href="class_SetOf.html#a18">cardinality</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;cardinality(); }
00501 
<a name="l00502"></a><a class="code" href="class_SetOf.html#a19">00502</a>   Bool <a class="code" href="class_SetOf.html#a19">equalTo</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S)<font class="keyword"> const </font>{
00503          <font class="keywordflow">return</font> ((<a class="code" href="class_ObjectOf.html#b0">look</a>() == S.<a class="code" href="class_ObjectOf.html#b0">look</a>()) || (*<a class="code" href="class_ObjectOf.html#b0">look</a>() == *S.<a class="code" href="class_ObjectOf.html#b0">look</a>()));
00504   }
00505   <font class="comment">// TRUE iff S is equal as a set to *this.</font>
00506 
<a name="l00507"></a><a class="code" href="class_SetOf.html#a20">00507</a>   Bool <a class="code" href="class_SetOf.html#a20">contains</a>(<font class="keyword">const</font> T&amp; e)<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;contains(e); }
00508   <font class="comment">// TRUE iff *this contains a T == to e.</font>
00509 
00510   Bool <a class="code" href="class_SetOf.html#a20">contains</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S) <font class="keyword">const</font>;
00511   <font class="comment">// TRUE iff S is a subset of *this.</font>
00512 
<a name="l00513"></a><a class="code" href="class_SetOf.html#a22">00513</a>   Bool <a class="code" href="class_SetOf.html#a22">properlyContains</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S)<font class="keyword"> const </font>{
00514          <font class="keywordflow">return</font> ( <a class="code" href="class_SetOf.html#a18">cardinality</a>() &gt; S.<a class="code" href="class_SetOf.html#a18">cardinality</a>() &amp;&amp; <a class="code" href="class_SetOf.html#a20">contains</a>(S) );
00515   }
00516   <font class="comment">// TRUE iff S is a proper subset of *this.</font>
00517 
<a name="l00518"></a><a class="code" href="class_SetOf.html#a23">00518</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetOf.html#a23">adjoinElement</a>(<font class="keyword">const</font> T&amp; e)<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;adjoinElement(e); }
00519   <font class="comment">// Add e to *this. It is not an error if *this already contains e.</font>
00520 
<a name="l00521"></a><a class="code" href="class_SetOf.html#a24">00521</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetOf.html#a24">removeElement</a>(<font class="keyword">const</font> T&amp; e)<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;removeElement(e); }
00522   <font class="comment">// Remove e from *this.</font>
00523   <font class="comment">// It is not an error if this set does not contain e.</font>
00524 
00525   <font class="keywordtype">void</font> <a class="code" href="class_SetOf.html#a25">shrinkToIntersectionWith</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S);
00526   <font class="comment">// Make *this the intersection of *this and S.</font>
00527 
00528   <font class="keywordtype">void</font> <a class="code" href="class_SetOf.html#a26">adjoinElements</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S);
00529   <font class="comment">// Adjoin each element of S to *this.</font>
00530 
00531   <font class="keywordtype">void</font> <a class="code" href="class_SetOf.html#a27">removeElements</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S);
00532   <font class="comment">// Remove each element of S from *this.</font>
00533 
<a name="l00534"></a><a class="code" href="class_SetOf.html#a28">00534</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetOf.html#a28">removeAllElements</a>()<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;removeAllElements(); }
00535   <font class="comment">// Makes *this into an empty set.</font>
00536 
<a name="l00537"></a><a class="code" href="class_SetOf.html#a29">00537</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetOf.html#a29">rehash</a>( )<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b1">enhance</a>()-&gt;rehash(TRUE); }
00538   <font class="comment">// For tweaking performance. Calling this is never sematically wrong, and</font>
00539   <font class="comment">// in the worst case degrades performance by increasing the constant in O(n);</font>
00540   <font class="comment">// see the comment for the default constructor.</font>
00541 
<a name="l00542"></a><a class="code" href="class_SetOf.html#l1">00542</a>   <font class="keyword">friend</font> ostream&amp; <a class="code" href="DatabaseManager_h.html#a28">operator &lt;&lt; </a>( ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"> </font>{
00543          S.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;printOn(ostr);
00544          <font class="keywordflow">return</font> ostr;
00545   }
00546 
00547 <font class="comment"></font>
00548 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00549 <font class="comment"></font>  <font class="comment">//                                                                     //</font>
00550   <font class="comment">// IPC tools:                                                          //</font>
00551   <font class="comment">//                                                                     //</font><font class="comment"></font>
00552 <font class="comment">  /////////////////////////////////////////////////////////////////////////</font>
00553 <font class="comment"></font>
<a name="l00554"></a><a class="code" href="class_SetOf.html#l2">00554</a>   <font class="keyword">friend</font> ostream&amp; <a class="code" href="Polynomial_h.html#a2">operator &lt; </a>( ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"></font>
00555 <font class="keyword">  </font>{
00556     S.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;write(ostr);
00557     <font class="keywordflow">return</font> ostr;
00558   }
00559   
<a name="l00560"></a><a class="code" href="class_SetOf.html#l3">00560</a>   <font class="keyword">friend</font> istream&amp; <a class="code" href="Polynomial_h.html#a3">operator &gt; </a>( istream&amp; istr, <a class="code" href="class_SetOf.html">SetOf</a>&amp; S )<font class="keyword"></font>
00561 <font class="keyword">  </font>{
00562     S.<a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;read(istr);
00563     <font class="keywordflow">return</font> istr;
00564   }
00565 
00566 
00567 <font class="preprocessor">  #ifdef DEBUG</font>
00568 <font class="preprocessor"></font>    <font class="keywordtype">void</font> printStats()<font class="keyword"> const </font>{ <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;printStats(); }
00569     <font class="keywordtype">void</font> printRep()<font class="keyword"> const </font>{ <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;printRep(); }
00570 <font class="preprocessor">  #endif</font>
00571 <font class="preprocessor"></font>
00572 
00573 
00574 <font class="keyword">protected</font>:
00575 
<a name="l00576"></a><a class="code" href="class_SetOf.html#t0">00576</a>   <font class="keyword">typedef</font> <a class="code" href="class_SetData.html">SetData&lt;T&gt;</a> <a class="code" href="struct_VectorPtrRep.html">Rep</a>;
00577 
<a name="l00578"></a><a class="code" href="class_SetOf.html#l0">00578</a>   <font class="keyword">friend</font> <font class="keyword">class </font><a class="code" href="class_SetIteratorData.html">SetIteratorData</a>&lt;T&gt;;
00579 
00580 <font class="comment">//@rn  SetOf( Rep* p ) : ObjectOf&lt;Rep&gt;(p) { }</font>
00581 
00582 };
00583 
00584 
00585 <font class="comment">// /*@rn g++ 2.5.8 gets confused when you prototype these</font>
00586 
00587 template &lt;class T&gt;
00588 <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a1">setUnion</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;);
00589 
00590 template &lt;class T&gt;
00591 <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a2">setIntersection</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;);
00592 
00593 template &lt;class T&gt;
00594 <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a3">setMinus</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;);
00595 
00596 template &lt;class T&gt;
00597 <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a4">setSymmetricDifference</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp;);
00598 
00599 <font class="comment">// */</font>
00600 
00601 
00602 
00603 <font class="comment">//---------------------- class SetIteratorData ------------------------------</font>
00604 
00605 template&lt;class T&gt;
<a name="l00606"></a><a class="code" href="class_SetContainer.html">00606</a> <font class="keyword">class </font><a class="code" href="class_SetContainer.html">SetContainer</a> : <font class="keyword">public</font> <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt; SetData&lt;T&gt; &gt; {
00607 <font class="keyword">public</font>:
<a name="l00608"></a><a class="code" href="class_SetContainer.html#l0">00608</a>   <font class="keyword">friend</font> <font class="keyword">class </font><a class="code" href="class_SetIteratorData.html">SetIteratorData</a>&lt;T&gt;;
<a name="l00609"></a><a class="code" href="class_SetContainer.html#a0">00609</a>   <a class="code" href="class_SetContainer.html#a0">SetContainer</a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S ) : <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt; <a class="code" href="class_SetData.html">SetData</a>&lt;T&gt; &gt;(S) { }
00610 };
00611 <font class="comment">// A helper class which mimics a SetOf&lt;T&gt;, to get around the usual g++</font>
00612 <font class="comment">// template fuckup. See the theSet member below.</font>
00613 
00614 
00615 template&lt;class T&gt;
<a name="l00616"></a><a class="code" href="class_SetIteratorData.html">00616</a> <font class="keyword">class </font><a class="code" href="class_SetIteratorData.html">SetIteratorData</a> : <font class="keyword">public</font> <a class="code" href="struct_PureRep.html">PureRep</a> {
00617 
00618 <font class="keyword">public</font>:
00619 
<a name="l00620"></a><a class="code" href="class_SetIteratorData.html#a0">00620</a>   <a class="code" href="class_SetIteratorData.html#a0">SetIteratorData</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S) : theSet(S) { <a class="code" href="class_SetIteratorData.html#a6">reset</a>(); }
00621 
00622   <font class="comment">// Use compiler's copy constructor, operator=, and destructor.</font>
00623 
<a name="l00624"></a><a class="code" href="class_SetIteratorData.html#a1">00624</a>   <a class="code" href="struct_PureRep.html">PureRep</a> *<a class="code" href="struct_PureRep.html#a1">clone</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <font class="keyword">new</font> <a class="code" href="class_SetIteratorData.html#a0">SetIteratorData</a>(*<font class="keyword">this</font>); }
00625 
<a name="l00626"></a><a class="code" href="class_SetIteratorData.html#a2">00626</a>   Bool <a class="code" href="Property_h.html#a1">operator == </a>( <font class="keyword">const</font> <a class="code" href="class_SetIteratorData.html">SetIteratorData</a>&amp; sid )<font class="keyword"> const </font>{
00627          <font class="keywordflow">return</font> ( current == sid.current &amp;&amp; theSet.<a class="code" href="class_ObjectOf.html#b0">look</a>() == sid.theSet.<a class="code" href="class_ObjectOf.html#b0">look</a>() );
00628   }
00629 
<a name="l00630"></a><a class="code" href="class_SetIteratorData.html#a3">00630</a>   T <a class="code" href="class_SetIteratorData.html#a3">value</a>( )<font class="keyword"> const </font>{
00631 <font class="preprocessor">         #if SAFETY &gt; 0</font>
00632 <font class="preprocessor"></font>           <font class="keywordflow">if</font> ( current == NULL )
00633                   <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"tried to retrieve value from SetIterator which is done"</font>);
00634 <font class="preprocessor">    #endif</font>
00635 <font class="preprocessor"></font>         <font class="keywordflow">return</font> current-&gt;<a class="code" href="class_Cell.html#a6">getContents</a>();
00636   }
00637 
<a name="l00638"></a><a class="code" href="class_SetIteratorData.html#a4">00638</a>   Bool <a class="code" href="class_SetIteratorData.html#a4">next</a>( )<font class="keyword"> </font>{
00639          <font class="keywordflow">if</font> ( current != NULL )
00640                 current = current-&gt;nextCell;
00641          <font class="keywordflow">if</font> ( current == NULL ) {
00642                 <font class="keywordtype">int</font> numberOfBuckets = theSet.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;numberOfBuckets;
00643                 <font class="keywordflow">if</font> ( bucketIndex &gt;= numberOfBuckets ) <font class="keywordflow">return</font> 0;
00644                 <a class="code" href="class_Cell.html">CellType</a>** hashTable = theSet.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;hashTable;
00645                 ++bucketIndex;
00646                 <font class="keywordflow">while</font> ( bucketIndex &lt; numberOfBuckets &amp;&amp; hashTable[bucketIndex] == NULL )
00647                   ++bucketIndex;
00648                 <font class="keywordflow">if</font> ( bucketIndex &lt; numberOfBuckets )
00649                   current = hashTable[bucketIndex];
00650          }
00651          <font class="keywordflow">return</font> (current != NULL);
00652   }
00653 
<a name="l00654"></a><a class="code" href="class_SetIteratorData.html#a5">00654</a>   Bool <a class="code" href="class_SetIteratorData.html#a5">done</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> (current == NULL); }
00655 
<a name="l00656"></a><a class="code" href="class_SetIteratorData.html#a6">00656</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetIteratorData.html#a6">reset</a>( )<font class="keyword"> </font>{
00657          current = NULL;
00658          bucketIndex = -1;
00659          <a class="code" href="class_SetIteratorData.html#a4">next</a>();
00660   }
00661 
00662 
00663 <font class="keyword">private</font>:
00664 
<a name="l00665"></a><a class="code" href="class_SetIteratorData.html#u0">00665</a>   <font class="keyword">typedef</font> <a class="code" href="class_Cell.html">Cell&lt;T&gt;</a> <a class="code" href="class_Cell.html">CellType</a>;
00666 
00667   <font class="comment">// Data members:</font>
00668 
<a name="l00669"></a><a class="code" href="class_SetIteratorData.html#o0">00669</a>   <a class="code" href="class_Cell.html">CellType</a>*      current;
<a name="l00670"></a><a class="code" href="class_SetIteratorData.html#o1">00670</a>   <font class="keywordtype">int</font>            bucketIndex;
00671 
<a name="l00672"></a><a class="code" href="class_SetIteratorData.html#o2">00672</a>   <font class="keyword">const</font> <a class="code" href="class_SetContainer.html">SetContainer&lt;T&gt;</a> theSet;
00673 
00674   <font class="comment">// If theSet is declared as SetOf&lt;T&gt;, g++ 2.5.8 &amp; 2.6.0 claim that it</font>
00675   <font class="comment">// has incomplete type. Then why, prithee, is this ok?</font>
00676   <font class="comment">// The exact same scheme works in ListOf and AssociationsOf.</font>
00677 };
00678 
00679 
00680 
00681 <font class="comment">//---------------------- class SetIterator ------------------------------</font>
00682 
00683 <font class="comment">// To iterate over the elements of a SetOf&lt;T&gt; S, just do:</font>
00684 <font class="comment">//</font>
00685 <font class="comment">//  SetIterator&lt;T&gt; I(S);</font>
00686 <font class="comment">//  while ( !I.done() ) {</font>
00687 <font class="comment">//    /* Do something with I.value() */</font>
00688 <font class="comment">//    I.next();</font>
00689 <font class="comment">//  }</font>
00690 <font class="comment">//</font>
00691 <font class="comment">// You may assign one SetIterator to another, so the following works:</font>
00692 <font class="comment">//</font>
00693 <font class="comment">//  SetIterator&lt;T&gt; I(S);</font>
00694 <font class="comment">//  while( !I.done() ) {</font>
00695 <font class="comment">//    SetIterator&lt;T&gt; J = I;</font>
00696 <font class="comment">//    while( J.next() )</font>
00697 <font class="comment">//      if ( I.value() == J.value() ) error("Set contains duplicates!");</font>
00698 <font class="comment">//    I.next();</font>
00699 <font class="comment">//  }</font>
00700 <font class="comment">//  int count = 0;</font>
00701 <font class="comment">//  I.reset();</font>
00702 <font class="comment">//  while( !I.done() ) {</font>
00703 <font class="comment">//    SetIterator&lt;T&gt; J(I);</font>
00704 <font class="comment">//    do { if ( I.value() == J.value() ) ++count; } while( J.next() );</font>
00705 <font class="comment">//    I.next();</font>
00706 <font class="comment">//  }</font>
00707 <font class="comment">//  if ( count != S.cardinality() ) error("I give up");</font>
00708 <font class="comment">//</font>
00709 <font class="comment">// Since I was reset, the two excursions of I through S are guaranteed to</font>
00710 <font class="comment">// produce the same sequence of elements. In any case, J is guaranteed to look</font>
00711 <font class="comment">// at the rest of what I is.</font>
00712 <font class="comment">// You may alter S during the iteration, but I uses the old copy</font>
00713 <font class="comment">// of S (see shrinkToIntersectionWith). You may alter the object returned by</font>
00714 <font class="comment">// I.value(), but this will not effect S or I.</font>
00715 
00716 
00717 <font class="comment">/* @@rn Changing parameterization for g++ 2.6.0</font>
00718 <font class="comment"></font>
00719 <font class="comment">template &lt;class SetOfType&gt;</font>
00720 <font class="comment">class SetIterator :</font>
00721 <font class="comment">public ObjectOf&lt; SetIteratorData&lt;SetOfType::SetElementType&gt; &gt; {</font>
00722 <font class="comment">*/</font>
00723 
00724 template &lt;class T&gt;
<a name="l00725"></a><a class="code" href="class_SetIterator.html">00725</a> <font class="keyword">class </font><a class="code" href="class_SetIterator.html">SetIterator</a> : <font class="keyword">public</font> <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt; SetIteratorData&lt;T&gt; &gt; {
00726 
00727 <font class="keyword">public</font>:
00728 
00729 <font class="comment">//@@rn  typedef SetOfType::SetElementType T;</font>
00730 
<a name="l00731"></a><a class="code" href="class_SetIterator.html#a0">00731</a>   <a class="code" href="class_SetIterator.html#a0">SetIterator</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S) : <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt;<a class="code" href="class_SetIteratorData.html">SID</a>&gt;( new <a class="code" href="class_SetIteratorData.html">SID</a>(S) ) { }
00732   <font class="comment">// Constructs iterator from set over which to iterate.</font>
00733 
00734   <font class="comment">// Copy constructor, operator=, and destructor supplied by compiler.</font>
00735 
<a name="l00736"></a><a class="code" href="class_SetIterator.html#a1">00736</a>   Bool <a class="code" href="Property_h.html#a1">operator == </a>( <font class="keyword">const</font> <a class="code" href="class_SetIterator.html">SetIterator</a>&amp; I )<font class="keyword"> const </font>{
00737          <font class="keywordflow">return</font> ((<a class="code" href="class_ObjectOf.html#b0">look</a>() == I.<a class="code" href="class_SetIterator.html#b0">look</a>()) || (*<a class="code" href="class_ObjectOf.html#b0">look</a>() == *I.<a class="code" href="class_SetIterator.html#b0">look</a>()));
00738   }
00739   <font class="comment">// TRUE iff the iterators will look at the same elements of the (physically)</font>
00740   <font class="comment">// same set in the same order. Valid at any point of the iteration.</font>
00741 
<a name="l00742"></a><a class="code" href="class_SetIterator.html#a2">00742</a>   T <a class="code" href="class_SetIterator.html#a2">value</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;<a class="code" href="class_SetIteratorData.html#a3">value</a>(); }
00743   <font class="comment">// Returns the current T. Calling this is a fatal error if done().</font>
00744 
<a name="l00745"></a><a class="code" href="class_SetIterator.html#a3">00745</a>   Bool <a class="code" href="class_SetIterator.html#a3">next</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;<a class="code" href="class_SetIteratorData.html#a4">next</a>(); }
00746   <font class="comment">// Advances this iterator.</font>
00747   <font class="comment">// Returns TRUE iff the iteration has not finished.</font>
00748   <font class="comment">// This may be called after it returns FALSE with no side effect.</font>
00749 
<a name="l00750"></a><a class="code" href="class_SetIterator.html#a4">00750</a>   Bool <a class="code" href="class_SetIterator.html#a4">done</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;<a class="code" href="class_SetIteratorData.html#a5">done</a>(); }
00751   <font class="comment">// Returns TRUE iff the iteration has finished. This may</font>
00752   <font class="comment">// be called after it returns TRUE with no side effect.</font>
00753 
<a name="l00754"></a><a class="code" href="class_SetIterator.html#a5">00754</a>   <font class="keywordtype">void</font> <a class="code" href="class_SetIterator.html#a5">reset</a>( )<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;<a class="code" href="class_SetIteratorData.html#a6">reset</a>(); }
00755   <font class="comment">// Resets this iterator to the state it was in after construction.</font>
00756 
00757 <font class="keyword">protected</font>:
00758 
<a name="l00759"></a><a class="code" href="class_SetIterator.html#t0">00759</a>   <font class="keyword">typedef</font> <a class="code" href="class_SetIteratorData.html">SetIteratorData&lt;T&gt;</a> <a class="code" href="class_SetIteratorData.html">ThisRep</a>;
<a name="l00760"></a><a class="code" href="class_SetIterator.html#t1">00760</a>   <font class="keyword">typedef</font> <a class="code" href="class_ObjectOf.html">ObjectOf&lt;ThisRep&gt;</a> <a class="code" href="class_ObjectOf.html">Base</a>;
00761  
00762   <font class="comment">// Shadow representation accessors to get representations of the</font>
00763   <font class="comment">// right type in the members of this class:</font>
00764  
<a name="l00765"></a><a class="code" href="class_SetIterator.html#b0">00765</a>   <font class="keyword">const</font> <a class="code" href="class_SetIteratorData.html">ThisRep</a>* <a class="code" href="class_ObjectOf.html#b0">look</a>( )<font class="keyword"> const </font>{
00766     <font class="keywordflow">return</font> (<font class="keyword">const</font> <a class="code" href="class_SetIteratorData.html">ThisRep</a>*)<a class="code" href="class_ObjectOf.html#b0">Base::look</a>();
00767   }
<a name="l00768"></a><a class="code" href="class_SetIterator.html#b1">00768</a>   <a class="code" href="class_SetIteratorData.html">ThisRep</a>* <a class="code" href="class_ObjectOf.html#b1">enhance</a>( )<font class="keyword"> const </font>{
00769          <font class="keywordflow">return</font> (<a class="code" href="class_SetIteratorData.html">ThisRep</a>*)<a class="code" href="class_ObjectOf.html#b1">Base::enhance</a>();
00770   }
<a name="l00771"></a><a class="code" href="class_SetIterator.html#b2">00771</a>   <a class="code" href="class_SetIteratorData.html">ThisRep</a>* <a class="code" href="class_ObjectOf.html#b2">change</a>( )<font class="keyword"> </font>{
00772          <font class="keywordflow">return</font> (<a class="code" href="class_SetIteratorData.html">ThisRep</a>*)<a class="code" href="class_ObjectOf.html#b2">Base::change</a>();
00773   }
00774 
<a name="l00775"></a><a class="code" href="class_SetIterator.html#b3">00775</a>   <a class="code" href="class_SetIterator.html#a0">SetIterator</a>( <a class="code" href="class_SetIteratorData.html">ThisRep</a>* rep ) : <a class="code" href="class_ObjectOf.html">Base</a>(rep) { }
00776   <font class="comment">// To wrap new representation</font>
00777 
00778 <font class="keyword">private</font>:
00779 
<a name="l00780"></a><a class="code" href="class_SetIterator.html#u0">00780</a>   <font class="keyword">typedef</font> <a class="code" href="class_SetIteratorData.html">SetIteratorData&lt;T&gt;</a> <a class="code" href="class_SetIteratorData.html">SID</a>;
00781 
00782 };
00783 
00784 
00785 <font class="comment">//------------ SetOf functions which depend on SetIterator --------------------</font>
00786 
00787 <font class="comment">/*</font>
00788 <font class="comment">template &lt;class T&gt;</font>
00789 <font class="comment">void SetOf&lt;T&gt;::shrinkToIntersectionWith(const SetOf&lt;T&gt;&amp; S)</font>
00790 <font class="comment">{</font>
00791 <font class="comment">//@@rn  SetIterator&lt; SetOf&lt;T&gt; &gt; I(*this);</font>
00792 <font class="comment">  SetIterator&lt;T&gt; I(*this);</font>
00793 <font class="comment">  while ( !I.done() ) {</font>
00794 <font class="comment">         if ( !S.contains( I.value() ) ) removeElement( I.value() );</font>
00795 <font class="comment">         I.next();</font>
00796 <font class="comment">  }</font>
00797 <font class="comment">}</font>
00798 <font class="comment"></font>
00799 <font class="comment"></font>
00800 <font class="comment">template &lt;class T&gt;</font>
00801 <font class="comment">void SetOf&lt;T&gt;::adjoinElements(const SetOf&lt;T&gt;&amp; S)</font>
00802 <font class="comment">{</font>
00803 <font class="comment">//@@rn  SetIterator&lt; SetOf&lt;T&gt; &gt; I(S);</font>
00804 <font class="comment">  SetIterator&lt;T&gt; I(S);</font>
00805 <font class="comment">  while ( !I.done() ) {</font>
00806 <font class="comment">         adjoinElement( I.value() );</font>
00807 <font class="comment">         I.next();</font>
00808 <font class="comment">  }</font>
00809 <font class="comment">}</font>
00810 <font class="comment"></font>
00811 <font class="comment"></font>
00812 <font class="comment">template &lt;class T&gt;</font>
00813 <font class="comment">void SetOf&lt;T&gt;::removeElements(const SetOf&lt;T&gt;&amp; S)</font>
00814 <font class="comment">{</font>
00815 <font class="comment">//@@rn  SetIterator&lt; SetOf&lt;T&gt; &gt; I(S);</font>
00816 <font class="comment">  SetIterator&lt;T&gt; I(S);</font>
00817 <font class="comment">  while ( !I.done() ) {</font>
00818 <font class="comment">         removeElement( I.value() );</font>
00819 <font class="comment">         I.next();</font>
00820 <font class="comment">  }</font>
00821 <font class="comment">}</font>
00822 <font class="comment"></font>
00823 <font class="comment"></font>
00824 <font class="comment">template &lt;class T&gt;</font>
00825 <font class="comment">Bool SetOf&lt;T&gt;::contains(const SetOf&lt;T&gt;&amp; S) const</font>
00826 <font class="comment">{</font>
00827 <font class="comment">//@@rn  SetIterator&lt; SetOf&lt;T&gt; &gt; I(S);</font>
00828 <font class="comment">  SetIterator&lt;T&gt; I(S);</font>
00829 <font class="comment">  while ( !I.done() ) {</font>
00830 <font class="comment">         if ( !contains( I.value() ) ) return 0;</font>
00831 <font class="comment">         I.next();</font>
00832 <font class="comment">  }</font>
00833 <font class="comment">  return 1;</font>
00834 <font class="comment">}</font>
00835 <font class="comment">*/</font>
00836 
00837 template &lt;class T&gt;
<a name="l00838"></a><a class="code" href="Set_h.html#a1">00838</a> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a1">setUnion</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S1, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S2)<font class="keyword"></font>
00839 <font class="keyword"></font>{
00840   <font class="keywordflow">if</font> ( S1.<a class="code" href="class_SetOf.html#a18">cardinality</a>() &lt; S2.<a class="code" href="class_SetOf.html#a18">cardinality</a>() ) {
00841          <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> result = S2;
00842 <font class="comment">//@@rn   SetIterator&lt; SetOf&lt;T&gt; &gt; I(S1);</font>
00843          <a class="code" href="class_SetIterator.html">SetIterator&lt;T&gt;</a> I(S1);
00844          <font class="keywordflow">while</font> ( !I.<a class="code" href="class_SetIterator.html#a4">done</a>() ) {
00845                 result.<a class="code" href="class_SetOf.html#a23">adjoinElement</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() );
00846                 I.<a class="code" href="class_SetIterator.html#a3">next</a>();
00847          }
00848          <font class="keywordflow">return</font> result;
00849   } <font class="keywordflow">else</font> {
00850          <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> result = S1;
00851 <font class="comment">//@@rn   SetIterator&lt; SetOf&lt;T&gt; &gt; I(S2);</font>
00852          <a class="code" href="class_SetIterator.html">SetIterator&lt;T&gt;</a> I(S2);
00853          <font class="keywordflow">while</font> ( !I.<a class="code" href="class_SetIterator.html#a4">done</a>() ) {
00854                 result.<a class="code" href="class_SetOf.html#a23">adjoinElement</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() );
00855                 I.<a class="code" href="class_SetIterator.html#a3">next</a>();
00856          }
00857          <font class="keywordflow">return</font> result;
00858   }
00859 }
00860 
00861 
00862 template &lt;class T&gt;
<a name="l00863"></a><a class="code" href="Set_h.html#a2">00863</a> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a2">setIntersection</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S1, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S2)<font class="keyword"></font>
00864 <font class="keyword"></font>{
00865   <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> result;
00866   <font class="keywordflow">if</font> ( S1.<a class="code" href="class_SetOf.html#a18">cardinality</a>() &lt; S2.<a class="code" href="class_SetOf.html#a18">cardinality</a>() ) {
00867 <font class="comment">//@@rn   SetIterator&lt; SetOf&lt;T&gt; &gt; I(S1);</font>
00868          <a class="code" href="class_SetIterator.html">SetIterator&lt;T&gt;</a> I(S1);
00869          <font class="keywordflow">while</font> ( !I.<a class="code" href="class_SetIterator.html#a4">done</a>() ) {
00870                 <font class="keywordflow">if</font> ( S2.<a class="code" href="class_SetOf.html#a20">contains</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() ) )
00871                   result.<a class="code" href="class_SetOf.html#a23">adjoinElement</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() );
00872                 I.<a class="code" href="class_SetIterator.html#a3">next</a>();
00873          }
00874   } <font class="keywordflow">else</font> {
00875 <font class="comment">//@@rn   SetIterator&lt; SetOf&lt;T&gt; &gt; I(S2);</font>
00876          <a class="code" href="class_SetIterator.html">SetIterator&lt;T&gt;</a> I(S2);
00877          <font class="keywordflow">while</font> ( !I.<a class="code" href="class_SetIterator.html#a4">done</a>() ) {
00878                 <font class="keywordflow">if</font> ( S1.<a class="code" href="class_SetOf.html#a20">contains</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() ) )
00879                   result.<a class="code" href="class_SetOf.html#a23">adjoinElement</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() );
00880                 I.<a class="code" href="class_SetIterator.html#a3">next</a>();
00881          }
00882   }
00883   <font class="keywordflow">return</font> result;
00884 }
00885 
00886 
00887 template &lt;class T&gt;
<a name="l00888"></a><a class="code" href="Set_h.html#a3">00888</a> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a3">setMinus</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S1, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S2)<font class="keyword"></font>
00889 <font class="keyword"></font>{
00890   <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> result;
00891 <font class="comment">//@@rn  SetIterator&lt; SetOf&lt;T&gt; &gt; I(S1);</font>
00892   <a class="code" href="class_SetIterator.html">SetIterator&lt;T&gt;</a> I(S1);
00893   <font class="keywordflow">while</font> ( !I.<a class="code" href="class_SetIterator.html#a4">done</a>() ) {
00894          <font class="keywordflow">if</font> ( !S2.<a class="code" href="class_SetOf.html#a20">contains</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() ) )
00895                   result.<a class="code" href="class_SetOf.html#a23">adjoinElement</a>( I.<a class="code" href="class_SetIterator.html#a2">value</a>() );
00896          I.<a class="code" href="class_SetIterator.html#a3">next</a>();
00897   }
00898   <font class="keywordflow">return</font> result;
00899 }
00900 
00901 
00902 template &lt;class T&gt;
<a name="l00903"></a><a class="code" href="Set_h.html#a4">00903</a> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> <a class="code" href="Set_h.html#a4">setSymmetricDifference</a>(<font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S1, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a>&amp; S2)<font class="keyword"></font>
00904 <font class="keyword"></font>{
00905   <a class="code" href="class_SetOf.html">SetOf&lt;T&gt;</a> result;
00906 <font class="comment">//@@rn  SetIterator&lt; SetOf&lt;T&gt; &gt; I1(S1);</font>
00907   <a class="code" href="class_SetIterator.html">SetIterator&lt;T&gt;</a> I1(S1);
00908   <font class="keywordflow">while</font> ( !I1.<a class="code" href="class_SetIterator.html#a4">done</a>() ) {
00909          <font class="keywordflow">if</font> ( !S2.<a class="code" href="class_SetOf.html#a20">contains</a>( I1.<a class="code" href="class_SetIterator.html#a2">value</a>() ) )
00910                   result.<a class="code" href="class_SetOf.html#a23">adjoinElement</a>( I1.<a class="code" href="class_SetIterator.html#a2">value</a>() );
00911          I1.<a class="code" href="class_SetIterator.html#a3">next</a>();
00912   }
00913 <font class="comment">//@@rn  SetIterator&lt; SetOf&lt;T&gt; &gt; I2(S2);</font>
00914   <a class="code" href="class_SetIterator.html">SetIterator&lt;T&gt;</a> I2(S2);
00915   <font class="keywordflow">while</font> ( !I2.<a class="code" href="class_SetIterator.html#a4">done</a>() ) {
00916          <font class="keywordflow">if</font> ( !S1.<a class="code" href="class_SetOf.html#a20">contains</a>( I2.<a class="code" href="class_SetIterator.html#a2">value</a>() ) )
00917                   result.<a class="code" href="class_SetOf.html#a23">adjoinElement</a>( I2.<a class="code" href="class_SetIterator.html#a2">value</a>() );
00918          I2.<a class="code" href="class_SetIterator.html#a3">next</a>();
00919   }
00920   <font class="keywordflow">return</font> result;
00921 }
00922 
00923 
00924 
00925 <font class="preprocessor">#endif</font>
00926 <font class="preprocessor"></font>
00927 
00928 
00929 
</pre></div><hr><address><small>Generated at Tue Jun 19 09:49:35 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
