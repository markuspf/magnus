<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/Elt/include/Word.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/Elt/include/Word.h</h1><a href="Word_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> *   $Id: Word.h,v 1.7 2000/03/03 04:12:05 bormotov Exp $</font>
00003 <font class="comment"> */</font>
00004 
00005 <font class="comment">// Copyright (C) 1994 The New York Group Theory Cooperative</font>
00006 <font class="comment">// See magnus/doc/COPYRIGHT for the full notice.</font>
00007 
00008 <font class="comment">// Contents: Definition of the Word and Genref classes.</font>
00009 <font class="comment">//</font>
00010 <font class="comment">// Principal Authors: Stephane Collart, Roger Needham</font>
00011 <font class="comment">//</font>
00012 <font class="comment">// Status: Useable.</font>
00013 <font class="comment">//</font>
00014 <font class="comment">// Next Implementation Steps:</font>
00015 <font class="comment">//</font>
00016 <font class="comment">// * Need to classify and order the methods and operators better.</font>
00017 <font class="comment">//</font>
00018 <font class="comment">// * Need to decide on a more coherent scheme where and how to declare</font>
00019 <font class="comment">//   global functions on container classes of words. In particular,</font>
00020 <font class="comment">//   functions which modify their arguments in place need a closer</font>
00021 <font class="comment">//   look. (are they really nice and convenient to use? - problem</font>
00022 <font class="comment">//   of unnecessarily cloning).</font>
00023 <font class="comment">//</font>
00024 <font class="comment">// Revision History:</font>
00025 <font class="comment">//</font>
00026 <font class="comment">// 4.6.94 @stc added</font>
00027 <font class="comment">//   method replaceGenerators( const VectorOf&lt;Elt&gt;&amp; eltvec) const</font>
00028 <font class="comment">// 22.11.94 @stc added</font>
00029 <font class="comment">//   int agreementLength( const Word&amp; ) const;</font>
00030 <font class="comment">//   SetOf&lt;Word&gt;&amp; closeUnderInverses(SetOf&lt;Word&gt;&amp; S);</font>
00031 <font class="comment">//   SetOf&lt;Word&gt;&amp; closeUnderCyclicPermutations(SetOf&lt;Word&gt;&amp; S);</font>
00032 <font class="comment">//   inline SetOf&lt;Word&gt;&amp; symmetrise(SetOf&lt;Word&gt;&amp; S);</font>
00033 <font class="comment">// 7.12.94 @stc added bool isProperPower from the Omsk randomMSC stuff</font>
00034 <font class="comment">// 12/16/94 @rn Added nextFreelyReduced, nextCyclicallyReduced.</font>
00035 <font class="comment">// 12/16/94 @rn Added maximalRoot global function. It must be merged with</font>
00036 <font class="comment">//              isProperPower.</font>
00037 <font class="comment">//</font>
00038 <font class="comment">// 12/06/95 Roger added bool allExponentSumsZero( ).</font>
00039 <font class="comment">//</font>
00040 <font class="comment">// * 7/96 Dmitry B. made porting to gcc 2.7.2.</font>
00041 <font class="comment">//</font>
00042 
00043 <font class="preprocessor">#ifndef _WORD_H_</font>
00044 <font class="preprocessor"></font><font class="preprocessor">#define _WORD_H_</font>
00045 <font class="preprocessor"></font>
00046 <font class="preprocessor">#include "<a class="code" href="Elt_h.html">Elt.h</a>"</font>
00047 <font class="preprocessor">#include "<a class="code" href="WordRep_h.html">WordRep.h</a>"</font>
00048 <font class="preprocessor">#include "<a class="code" href="Generator_h.html">Generator.h</a>"</font>
00049 <font class="preprocessor">#include "<a class="code" href="Vector_h.html">Vector.h</a>"</font>
00050 <font class="preprocessor">#include "<a class="code" href="List_h.html">List.h</a>"</font>
00051 <font class="preprocessor">#include "<a class="code" href="Chars_h.html">Chars.h</a>"</font>
00052 <font class="preprocessor">#include "<a class="code" href="DerivedObjectOf_h.html">DerivedObjectOf.h</a>"</font>
00053 
00054 
00055 <font class="keyword">class </font><a class="code" href="class_Genref.html">Genref</a>;
00056 
<a name="l00057"></a><a class="code" href="class_Word.html">00057</a> <font class="keyword">class </font><a class="code" href="class_Word.html">Word</a> : <font class="keyword">public</font> <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;Elt,WordRep&gt; {
00058 
00059 <font class="keyword">public</font>:  
00060 <font class="comment"></font>
00061 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00062 <font class="comment"></font><font class="comment">//                                                                   //</font>
00063 <font class="comment">// Constructors:                                                     //</font>
00064 <font class="comment">//                                                                   //</font><font class="comment"></font>
00065 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00066 <font class="comment"></font>
<a name="l00067"></a><a class="code" href="class_Word.html#a0">00067</a>   <a class="code" href="class_Word.html#a0">Word</a>( ) : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;(new <a class="code" href="struct_WordRep.html">WordRep</a>(0)) { }
00068   <font class="comment">// Default constructor makes empty word.</font>
00069 
00070   <font class="comment">// copy constructor supplied by compiler</font>
00071 
<a name="l00072"></a><a class="code" href="class_Word.html#a1">00072</a>   <a class="code" href="class_Word.html#a0">Word</a>( <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Generator&gt;</a>&amp; v ) :
00073     <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;(new <a class="code" href="struct_WordRep.html">WordRep</a>(v))
00074   { }
00075   <font class="comment">// For initializing a Word from a Vector of Generators.</font>
00076 
<a name="l00077"></a><a class="code" href="class_Word.html#a2">00077</a>   <a class="code" href="class_Word.html#a0">Word</a>( <font class="keyword">const</font> <a class="code" href="class_ListOf.html">ListOf&lt;Generator&gt;</a>&amp; l ) :
00078     <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;(new <a class="code" href="struct_WordRep.html">WordRep</a>(l))
00079   { }
00080   <font class="comment">// For initializing a Word from a List of Generators.</font>
00081 
<a name="l00082"></a><a class="code" href="class_Word.html#a3">00082</a>   <a class="code" href="class_Word.html#a0">Word</a>( <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; g ) : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;( new <a class="code" href="struct_WordRep.html">WordRep</a>(g) ) { }
00083   <font class="comment">// Cast constructor.</font>
00084 
<a name="l00085"></a><a class="code" href="class_Word.html#a4">00085</a>   <a class="code" href="class_Word.html#a0">Word</a>( <font class="keyword">const</font> <a class="code" href="class_Elt.html">Elt</a>&amp; e ) : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;( e ) { }
00086   <font class="comment">// Cast constructor.</font>
00087   
00088   <font class="comment">// destructor supplied by compiler</font>
00089 <font class="comment"></font>
00090 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00091 <font class="comment"></font><font class="comment">//                                                                   //</font>
00092 <font class="comment">// Type and representation stuff:                                    //</font>
00093 <font class="comment">//                                                                   //</font><font class="comment"></font>
00094 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00095 <font class="comment"></font> 
<a name="l00096"></a><a class="code" href="class_Word.html#d0">00096</a>   <font class="keyword">static</font> <a class="code" href="class_Type.html">Type</a> <a class="code" href="class_Word.html#d0">type</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="struct_WordRep.html#d0">WordRep::type</a>(); }
00097  
00098   <font class="comment">// inherited from Elt:</font>
00099   <font class="comment">// Type actualType( ) const { return look()-&gt;actualType(); }</font>
00100 <font class="comment"></font>
00101 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00102 <font class="comment"></font><font class="comment">//                                                                   //</font>
00103 <font class="comment">// Methods:                                                          //</font>
00104 <font class="comment">//                                                                   //</font><font class="comment"></font>
00105 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00106 <font class="comment"></font>
<a name="l00107"></a><a class="code" href="class_Word.html#a5">00107</a>   <font class="keywordtype">int</font> <a class="code" href="class_Word.html#a5">length</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;length(); }
00108 
00109   <a class="code" href="class_Generator.html">Generator</a> <a class="code" href="class_Word.html#a6">operator [] </a>( <font class="keywordtype">int</font> i ) <font class="keyword">const</font>;
00110   <font class="comment">// access to const word just gives a val</font>
00111   <font class="comment">// @stc added the const version of op[] for const words - selected</font>
00112   <font class="comment">// automatically by compiler</font>
00113 
00114   <a class="code" href="class_Genref.html">Genref</a> <a class="code" href="class_Word.html#a6">operator [] </a>( <font class="keywordtype">int</font> i );
00115   <font class="comment">// Subscripting for random read/write access. Zero-based indexing.</font>
00116   <font class="comment">// WordData does bounds checking. Return type is actually Genref,</font>
00117   <font class="comment">// to be used as a Generator by the user.</font>
00118   <font class="comment">// @stc removed const qualifier to remove loophole</font>
00119 
00120   Bool <a class="code" href="Polynomial_h.html#a2">operator &lt; </a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; ) <font class="keyword">const</font>;
00121   <font class="comment">// ShortLex order defined by following order on generators:</font>
00122   <font class="comment">// compare them first by magnitude of ord, then g &lt; g^-1.</font>
00123 
00124   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a9">nextInShortLex</a>(<font class="keywordtype">int</font> numberOfGens) <font class="keyword">const</font>;
00125   <font class="comment">// Return the word, not freely reduced, which comes after</font>
00126   <font class="comment">// *this in the ShortLex order on numberOfGens generators.</font>
00127 
00128   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a10">nextFreelyReduced</a>(<font class="keywordtype">int</font> numberOfGens) <font class="keyword">const</font>;
00129   <font class="comment">// Return the freely reduced word which comes after</font>
00130   <font class="comment">// *this in the ShortLex order on numberOfGens generators.</font>
00131   <font class="comment">// It is a fatal error to call this with a non-freely reduced word.</font>
00132 
00133   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a11">nextCyclicallyReduced</a>(<font class="keywordtype">int</font> numberOfGens) <font class="keyword">const</font>;
00134   <font class="comment">// Return the cyclically reduced word which comes after</font>
00135   <font class="comment">// *this in the ShortLex order on numberOfGens generators.</font>
00136   <font class="comment">// It is a fatal error to call this with a non-freely reduced word.</font>
00137 
00138   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a12">subword</a>(<font class="keyword">const</font> <font class="keywordtype">int</font> i, <font class="keyword">const</font> <font class="keywordtype">int</font> j) <font class="keyword">const</font>;
00139   <font class="comment">// Return the subword [i, j).</font>
00140 
<a name="l00141"></a><a class="code" href="class_Word.html#a13">00141</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a13">initialSegment</a>(<font class="keyword">const</font> <font class="keywordtype">int</font> i)<font class="keyword"> const </font>{
00142          <font class="keywordflow">return</font> <a class="code" href="class_Word.html#a12">subword</a>(0, i);
00143   }
00144 
<a name="l00145"></a><a class="code" href="class_Word.html#a14">00145</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a14">terminalSegment</a>(<font class="keyword">const</font> <font class="keywordtype">int</font> i)<font class="keyword"> const </font>{
00146          <font class="keywordflow">return</font> <a class="code" href="class_Word.html#a12">subword</a>(<a class="code" href="class_Word.html#a5">length</a>() - i, <a class="code" href="class_Word.html#a5">length</a>());
00147   }
00148 
00149   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a15">findAgreement</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp;) <font class="keyword">const</font>;
00150   <font class="comment">// Return identical initial segment of the argument and *this.</font>
00151 
00152   <font class="keywordtype">int</font> <a class="code" href="class_Word.html#a16">agreementLength</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; ) <font class="keyword">const</font>;
00153   <font class="comment">// give max length of identical initial segment; more efficient</font>
00154   <font class="comment">// than actually constructing segment to determine length</font>
00155 
00156   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a17">shortenByRelator</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp;) <font class="keyword">const</font>;
00157   <font class="comment">// Find a subword w of *this which is an initial segment of the argument</font>
00158   <font class="comment">// of length more than half of the argument.</font>
00159   <font class="comment">// Return *this if there is no such w; otherwise the result of replacing w</font>
00160   <font class="comment">// by the inverse of the shorter half.</font>
00161 
00162   <font class="keywordtype">int</font> <a class="code" href="class_Word.html#a18">numberOfOccurrences</a>(<font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; g) <font class="keyword">const</font>;
00163   <font class="comment">// Return the number of g's and -g's in *this.</font>
00164 
00165   <font class="keywordtype">int</font> <a class="code" href="AP-fixups_h.html#a12">exponentSum</a>(<font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; g) <font class="keyword">const</font>;
00166   <font class="comment">// Return the exponent sum of g in *this.</font>
00167 
00168   <font class="keywordtype">bool</font> <a class="code" href="class_Word.html#a20">allExponentSumsZero</a>( ) <font class="keyword">const</font>;
00169   <font class="comment">// That is, iff this word is trivial in the derived group of the</font>
00170   <font class="comment">// ambient free group.</font>
00171 
00172   <font class="keywordtype">bool</font> <a class="code" href="class_Word.html#a21">isProperPower</a>( ) <font class="keyword">const</font>;
00173   <font class="comment">// whether *this is a proper power of a non-trivial word.</font>
00174   <font class="comment">// @stc might need one which gives you the smallest proper factor too.</font>
00175   <font class="comment">// @stc apart from the implementation which might make you blanch,</font>
00176   <font class="comment">// there is the Q whether this should reduce first or no: now it does.</font>
00177 
00178   <a class="code" href="class_Generator.html">Generator</a> <a class="code" href="class_Word.html#a22">maxOccurringGenerator</a>( ) <font class="keyword">const</font>;
00179   <font class="comment">// Return the generator in *this with ord of maximal magnitude</font>
00180   <font class="comment">// in the standard order on integers. It is an error for *this to be</font>
00181   <font class="comment">// the trivial word.</font>
00182 
00183   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a23">replaceGeneratorWithWord</a>(<font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp;, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp;) <font class="keyword">const</font>;
00184   <font class="comment">// Return the result of replacing each occurrence of the Generator</font>
00185   <font class="comment">// (or its inverse) with the Word (or its inverse).</font>
00186 
00187   <a class="code" href="class_Elt.html">Elt</a> <a class="code" href="class_Word.html#a24">replaceGenerators</a>( <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Elt&gt;</a>&amp; eltvec ) <font class="keyword">const</font>;
00188   <font class="comment">// Return the result of simultaneously replacing generator with ord i+1</font>
00189   <font class="comment">// through eltvec[i], i = 0 .. eltvec.length(); it is an error for </font>
00190   <font class="comment">// maxOccuringGenerator() to be greater than eltvec.length()</font>
00191 
00192   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a24">replaceGenerators</a>( <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; eltvec ) <font class="keyword">const</font>;
00193   <font class="comment">// Return the result of simultaneously replacing generator with ord i+1</font>
00194   <font class="comment">// through eltvec[i], i = 0 .. eltvec.length(); it is an error for </font>
00195   <font class="comment">// maxOccuringGenerator() to be greater than eltvec.length()</font>
00196   <font class="comment">// @stc this method added as temporary palliative to the lack of</font>
00197   <font class="comment">// convertibility between various Vectors</font>
00198   <font class="comment">// @rn Changed return type to Word to work around g++ 2.6.0 bug,</font>
00199   <font class="comment">//     and replaced implementation with more somewhat efficient one.</font>
00200   <font class="comment">//     It does not do free reduction.</font>
00201 
00202   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a26">replaceSubword</a>(<font class="keyword">const</font> <font class="keywordtype">int</font> i, <font class="keyword">const</font> <font class="keywordtype">int</font> j, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w) <font class="keyword">const</font>;
00203   <font class="comment">// Return result of replacing *this[i, j) with w.</font>
00204   <font class="comment">// w may have any length.</font>
00205 
00206   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a27">freelyReduce</a>( ) <font class="keyword">const</font>;
00207   <font class="comment">// Return a freely reduced copy of *this.</font>
00208 
00209   <a class="code" href="class_Word.html">Word</a> <a class="code" href="AP-fixups_h.html#a13">cyclicallyReduce</a>(<font class="keywordtype">void</font>) <font class="keyword">const</font>;
00210   <font class="comment">// Return a cyclically reduced copy of *this.</font>
00211 
00212   <a class="code" href="class_Word.html">Word</a> <a class="code" href="AP-fixups_h.html#a9">cyclicallyPermute</a>(<font class="keyword">const</font> <font class="keywordtype">int</font> j) <font class="keyword">const</font>;
00213   <font class="comment">// Return result where old jth gen becomes new 0th gen.</font>
00214   <font class="comment">// Thus w.cyclicallyPermute(j), j &gt; 0, means `left-shift' j letters.</font>
00215   <font class="comment">// Negative j's yield a `right-shift'.</font>
00216   <font class="comment">// j's of magnitude exceeding length of *this wrap around.</font>
00217 
<a name="l00218"></a><a class="code" href="class_Word.html#a30">00218</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a30">inverse</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_Word.html#a0">Word</a>(<a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;inverse()); }
00219 
00220   <font class="comment">// All Word multiplication does pure concatenation without free reduction.</font>
00221 
<a name="l00222"></a><a class="code" href="class_Word.html#a31">00222</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="PolyWord_h.html#a1">operator * </a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> const </font>{
00223          <font class="keywordflow">return</font> ( *<a class="code" href="class_DerivedObjectOf.html#b0">look</a>() * *w.<a class="code" href="class_DerivedObjectOf.html#b0">look</a>() );
00224   }
00225 
<a name="l00226"></a><a class="code" href="class_Word.html#a32">00226</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="PolyWord_h.html#a1">operator * </a>( <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; x )<font class="keyword"> </font>{
00227          <font class="keywordflow">return</font> <a class="code" href="class_Word.html#a0">Word</a>( <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;rightMultBy(x) );
00228   }
00229 
<a name="l00230"></a><a class="code" href="class_Word.html#l1">00230</a>   <font class="keyword">inline</font> <font class="keyword">friend</font> <a class="code" href="class_Word.html">Word</a> <a class="code" href="PolyWord_h.html#a1">operator * </a>( <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; x, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> </font>{
00231          <font class="keywordflow">return</font> <a class="code" href="class_Word.html#a0">Word</a>( w.<a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;leftMultBy(x) );
00232   }
00233 
<a name="l00234"></a><a class="code" href="class_Word.html#l2">00234</a>   <font class="keyword">inline</font> <font class="keyword">friend</font> <a class="code" href="class_Word.html">Word</a> <a class="code" href="PolyWord_h.html#a1">operator * </a>( <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; x, <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; y )<font class="keyword"> </font>{
00235          <font class="keywordflow">return</font> <a class="code" href="class_Word.html#a0">Word</a>( <font class="keyword">new</font> WordRep(x, y) );
00236   }
00237 
<a name="l00238"></a><a class="code" href="class_Word.html#a33">00238</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a33">operator *= </a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> </font>{
00239         <font class="keywordflow">return</font> *<font class="keyword">this</font> = *<font class="keyword">this</font> * w;
00240   }
00241 
<a name="l00242"></a><a class="code" href="class_Word.html#a34">00242</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#a33">operator *= </a>( <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; x )<font class="keyword"> </font>{
00243         <font class="keywordflow">return</font> *<font class="keyword">this</font> = *<font class="keyword">this</font> * x;
00244   }
00245 <font class="comment"></font>
00246 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00247 <font class="comment"></font><font class="comment">//                                                                   //</font>
00248 <font class="comment">// Static auxiliary functions:                                       //</font>
00249 <font class="comment">//                                                                   //</font><font class="comment"></font>
00250 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00251 <font class="comment"></font>
00252   <font class="keyword">static</font> <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#d1">wordByLexRank</a>( <font class="keywordtype">int</font> numGens, <font class="keywordtype">int</font> lexRank );
00253   <font class="comment">// gives the lexRank-th word with numGens number of Generators in</font>
00254   <font class="comment">// the short lexicographic order</font>
00255 
<a name="l00256"></a><a class="code" href="class_Word.html#d2">00256</a>   <font class="keyword">static</font> <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Word.html#d1">wordByLexRank</a>( <a class="code" href="class_VectorOf.html">VectorOf&lt;int&gt;</a> vi )
00257   <font class="comment">// same for call with standardised single argument signature</font>
00258         { <font class="keywordflow">return</font> <a class="code" href="class_Word.html#d1">wordByLexRank</a>(vi[0],vi[1]); }
00259 <font class="comment"></font>
00260 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00261 <font class="comment"></font><font class="comment">//                                                                   //</font>
00262 <font class="comment">// I/O:                                                              //</font>
00263 <font class="comment">//                                                                   //</font><font class="comment"></font>
00264 <font class="comment">///////////////////////////////////////////////////////////////////////</font>
00265 <font class="comment"></font>
00266   <font class="comment">// Inherited from Elt:</font>
00267   <font class="comment">// void printOn(ostream&amp;) const; // pseudo-virtual</font>
00268   <font class="comment">// void debugPrint(ostream&amp;) const; // pseudo-virtual</font>
00269 
00270     <font class="comment">// helper classes</font>
00271  
<a name="l00272"></a><a class="code" href="class_Word__EmptyWord.html">00272</a>     <font class="keyword">class </font>EmptyWord {
<a name="l00273"></a><a class="code" href="class_Word__EmptyWord.html#o0">00273</a>         <a class="code" href="class_Chars.html">Chars</a> emptyWord;
00274     <font class="keyword">public</font>:
<a name="l00275"></a><a class="code" href="class_Word__EmptyWord.html#a0">00275</a>         <a class="code" href="class_Word__EmptyWord.html#a0">EmptyWord</a>( <font class="keyword">const</font> <a class="code" href="class_Chars.html">Chars</a>&amp; ew ) : emptyWord(ew) { };
<a name="l00276"></a><a class="code" href="class_Word__EmptyWord.html#a1">00276</a>         <a class="code" href="class_Word__EmptyWord.html#a1">operator Chars</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> emptyWord; }
00277     };
00278  
<a name="l00279"></a><a class="code" href="class_Word__ProductJunctor.html">00279</a>     <font class="keyword">class </font>ProductJunctor {
<a name="l00280"></a><a class="code" href="class_Word__ProductJunctor.html#o0">00280</a>         <a class="code" href="class_Chars.html">Chars</a> junctor;
00281     <font class="keyword">public</font>:
<a name="l00282"></a><a class="code" href="class_Word__ProductJunctor.html#a0">00282</a>         <a class="code" href="class_Word__ProductJunctor.html#a0">ProductJunctor</a>( <font class="keyword">const</font> <a class="code" href="class_Chars.html">Chars</a>&amp; j ) : junctor(j) { };
<a name="l00283"></a><a class="code" href="class_Word__ProductJunctor.html#a1">00283</a>         <a class="code" href="class_Word__ProductJunctor.html#a1">operator Chars</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> junctor; }
00284     };
00285 
00286 
00287 <font class="keyword">private</font>:
00288 
<a name="l00289"></a><a class="code" href="class_Word.html#u0">00289</a>   <font class="keyword">typedef</font> WordData::GeneratorPtrType <a class="code" href="class_WordData.html">GeneratorPtrType</a>;  <font class="comment">// Pointer to generator</font>
<a name="l00290"></a><a class="code" href="class_Word.html#u1">00290</a>   <font class="keyword">typedef</font> WordData::cGeneratorPtrType <a class="code" href="class_WordData.html">cGeneratorPtrType</a>;<font class="comment">// Same, but const</font>
<a name="l00291"></a><a class="code" href="class_Word.html#u2">00291</a>   <font class="keyword">typedef</font> WordData::GeneratorType <a class="code" href="class_WordData.html">GeneratorType</a>;
00292   <font class="comment">// A signed integral type. 0 is not used, and the inverse of a generator g</font>
00293   <font class="comment">// is -g.</font>
00294 
<a name="l00295"></a><a class="code" href="class_Word.html#l0">00295</a>   <font class="keyword">friend</font> <font class="keyword">class </font><a class="code" href="class_Genref.html">Genref</a>;
00296   <font class="comment">// so Genref can access the representation to perform assignments.</font>
00297 
00298   <font class="comment">// Some hidden constructors:</font>
00299 
<a name="l00300"></a><a class="code" href="class_Word.html#c0">00300</a>   <a class="code" href="class_Word.html#a0">Word</a>( <font class="keywordtype">int</font> len ) : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;( new <a class="code" href="struct_WordRep.html">WordRep</a>(len) ) { }
00301   <font class="comment">// Returns an uninitialized word of specified length.</font>
00302 
<a name="l00303"></a><a class="code" href="class_Word.html#c1">00303</a>   <a class="code" href="class_Word.html#a0">Word</a>( <font class="keyword">const</font> <a class="code" href="class_WordData.html">GeneratorType</a>* p, <font class="keywordtype">int</font> len ) :
00304     <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;( new <a class="code" href="struct_WordRep.html">WordRep</a>(p, len) )
00305   { }
00306   <font class="comment">// For initializing a word from a raw array of GeneratorType.</font>
00307 
00308   <font class="comment">//@rn:@stc arg type ok?:</font>
<a name="l00309"></a><a class="code" href="class_Word.html#c2">00309</a>   <a class="code" href="class_Word.html#a0">Word</a>( <a class="code" href="struct_EltRep.html">EltRep</a>* rep ) : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_Elt.html">Elt</a>,<a class="code" href="struct_WordRep.html">WordRep</a>&gt;((<a class="code" href="struct_WordRep.html">WordRep</a>*)rep) { }
00310   <font class="comment">// Special constructor to make an object out of a delegated method</font>
00311   <font class="comment">// which returns a representation.</font>
00312 
00313 };
00314 
00315 
00316 <font class="comment">//--------------------------- Genref ------------------------------//</font>
00317 
00318 
<a name="l00319"></a><a class="code" href="class_Genref.html">00319</a> <font class="keyword">class </font><a class="code" href="class_Genref.html">Genref</a> {
00320   
00321 <font class="keyword">public</font>:
00322   
00323   <font class="comment">// no default constructor because of reference members</font>
00324   <font class="comment">// destructor compiler-supplied</font>
00325   
<a name="l00326"></a><a class="code" href="class_Genref.html#a0">00326</a>   <a class="code" href="class_Generator.html">Generator</a> <a class="code" href="class_ObjectOf.html#a2">operator = </a>( <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; g )<font class="keyword"> </font>{
00327          <font class="keywordflow">return</font> wref.<a class="code" href="class_DerivedObjectOf.html#b2">change</a>()-&gt;<a class="code" href="struct_VectorPtrRep.html#a8">ref</a>(index) = ord(g);
00328   }
00329 
<a name="l00330"></a><a class="code" href="class_Genref.html#a1">00330</a>   <font class="keywordtype">int</font> <a class="code" href="Property_h.html#a1">operator == </a>( <font class="keyword">const</font> <a class="code" href="class_Generator.html">Generator</a>&amp; g )<font class="keyword"> </font>{
00331          <font class="keywordflow">return</font> wref.<a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;<a class="code" href="struct_VectorPtrRep.html#a9">val</a>(index) == g;
00332   }
00333   <font class="comment">// @stc as long as there is no global == which takes two Generator</font>
00334   <font class="comment">// arguments, this has to be explicitely provided (ARM prohibits</font>
00335   <font class="comment">// type conversion to apply method).</font>
00336  
<a name="l00337"></a><a class="code" href="class_Genref.html#a2">00337</a>   <a class="code" href="class_Genref.html#a2">operator Generator</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> wref.<a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;<a class="code" href="struct_VectorPtrRep.html#a9">val</a>(index); }
00338 
00339   
00340 <font class="keyword">private</font>:
00341 
<a name="l00342"></a><a class="code" href="class_Genref.html#l0">00342</a> <font class="keyword">friend</font> <font class="keyword">class </font><a class="code" href="class_Word.html">Word</a>; <font class="comment">//@rn only op[] when possible.</font>
00343 
<a name="l00344"></a><a class="code" href="class_Genref.html#c0">00344</a>   <a class="code" href="class_Genref.html#c0">Genref</a>( <a class="code" href="class_Word.html">Word</a>&amp; w, <font class="keywordtype">int</font> i ) : wref(w), index(i) { }
00345   <font class="comment">// Hide this from unauthorized users.</font>
00346 
00347   <font class="comment">// data members</font>
00348   
<a name="l00349"></a><a class="code" href="class_Genref.html#o0">00349</a>   <a class="code" href="class_Word.html">Word</a>&amp; wref;
00350   
<a name="l00351"></a><a class="code" href="class_Genref.html#o1">00351</a>   <font class="keywordtype">int</font> index;
00352 
00353   <font class="comment">// make copy constructor inaccessible</font>
<a name="l00354"></a><a class="code" href="class_Genref.html#c1">00354</a>   <a class="code" href="class_Genref.html#c0">Genref</a>( <font class="keyword">const</font> <a class="code" href="class_Genref.html">Genref</a>&amp; g ) : wref(g.wref), index(g.index) {
00355          <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"called hidden Genref copy constructor"</font>);
00356   }
00357   
00358   <font class="comment">// make assignment operator inaccessible</font>
<a name="l00359"></a><a class="code" href="class_Genref.html#c2">00359</a>   <a class="code" href="class_Genref.html">Genref</a> <a class="code" href="class_ObjectOf.html#a2">operator = </a>( <font class="keyword">const</font> <a class="code" href="class_Genref.html">Genref</a>&amp; g )<font class="keyword"> </font>{
00360          <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"called hidden Genref assignment operator"</font>);
00361   }
00362 };
00363 
00364 
00365 <font class="comment">//----------------------------------- ------------------------------//</font>
00366 <font class="comment">//------------------------------ Word ------------------------------//</font>
00367 <font class="comment">//----------------------- inline functions -------------------------//</font>
00368 
00369 
<a name="l00370"></a><a class="code" href="class_Word.html#a6">00370</a> <font class="keyword">inline</font> <a class="code" href="class_Generator.html">Generator</a> <a class="code" href="class_Word.html#a6">Word::operator [] </a>( <font class="keywordtype">int</font> i )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;val(i); }
00371 
<a name="l00372"></a><a class="code" href="class_Word.html#a7">00372</a> <font class="keyword">inline</font> <a class="code" href="class_Genref.html">Genref</a> <a class="code" href="class_Word.html#a6">Word::operator [] </a>( <font class="keywordtype">int</font> i )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="class_Word.html#l0">Genref</a>( *<font class="keyword">this</font>, i ); }
00373 
00374 
00375 
00376 <font class="preprocessor">#include "<a class="code" href="Set_h.html">Set.h</a>"</font>
00377 
00378  
00379 <font class="comment">//-------------- Word: associated global functions ----------------//</font>
00380 
00381 istream&amp; <a class="code" href="BaseProperties_h.html#a3">operator&gt;&gt;</a>( istream&amp; istr, <a class="code" href="class_Word.html">Word</a>&amp; );
00382 
00383 <font class="comment">// @rn 12/16/94 This is here temporarily, until we can sort things out.</font>
00384 <font class="keywordtype">int</font> <a class="code" href="Word_h.html#a1">maximalRoot</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w);
00385 
00386 
00387 <font class="comment">// syntactic operations on container classes of words:</font>
00388 <font class="comment">// @stc some or all of these functions could be made into template</font>
00389 <font class="comment">// functions for various container classes, if the container classes</font>
00390 <font class="comment">// have sufficiently standardised handles.</font>
00391 
00392 
00393 <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; <a class="code" href="Word_h.html#a2">closeUnderInverses</a>(<a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; S);
00394 <font class="comment">// closes S syntactically to contain all syntactic inverses of words</font>
00395 <font class="comment">// in S; returns a reference to the new S.</font>
00396 <font class="comment">// Does not freely reduce.</font>
00397 
00398  
00399 <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; <a class="code" href="Word_h.html#a3">closeUnderCyclicPermutations</a>(<a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; S);
00400 <font class="comment">// closes S syntactically to contain all syntactic cyclic permutations</font>
00401 <font class="comment">// of words in S; returns a reference to the new S.</font>
00402 <font class="comment">// Does not freely reduce.</font>
00403 
00404 
<a name="l00405"></a><a class="code" href="Word_h.html#a4">00405</a> <font class="keyword">inline</font> <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; <a class="code" href="Word_h.html#a4">symmetrise</a>(<a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; S)<font class="keyword"> </font>{
00406 
00407   <font class="keywordflow">return</font> <a class="code" href="Word_h.html#a3">closeUnderCyclicPermutations</a>(<a class="code" href="Word_h.html#a2">closeUnderInverses</a>(S));
00408 }
00409 <font class="comment">// closes S syntactically to contain all syntactic inverses and</font>
00410 <font class="comment">// syntactic cyclic permutations of words in S; returns a reference</font>
00411 <font class="comment">// to the new S.</font>
00412 <font class="comment">// Does not freely reduce.</font>
00413 
00414 
00415 <font class="keywordtype">int</font> <a class="code" href="Word_h.html#a5">cancellationLambda</a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; ss );
00416 <font class="comment">// computes the smallest lambda such that no two words of ss have a</font>
00417 <font class="comment">// common initial segment of length greater than or equal to</font>
00418 <font class="comment">// one lamdba-th of either of their lengths.</font>
00419 <font class="comment">// ss is assumed to be symmetrised.</font>
00420 <font class="comment">// the function returns 0 if lambda is infinite, otherwise the value of</font>
00421 <font class="comment">// lambda; as a special case, lambda == 1 means two words agree over</font>
00422 <font class="comment">// at least half of one, ie. the words do not define a small</font>
00423 <font class="comment">// cancellation group.</font>
00424 <font class="comment">// @stc beware that if the words are compacted words, lambda can easily</font>
00425 <font class="comment">// overflow; the function does not check this</font>
00426 <font class="comment">// @stc need to add security checks</font>
00427 
00428 
00429 <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="Word_h.html#a6">hasMetricSmallCancellation</a>( <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; S, <font class="keyword">const</font> <font class="keywordtype">int</font> lambda );
00430 <font class="comment">// This method takes an int argument lambda, and checks whether the given</font>
00431 <font class="comment">// words satisfy the C'(1/lambda) condition.</font>
00432 <font class="comment">// The words are expected to be freely reduced, and the set symmetrised.</font>
00433 <font class="comment">// If any two words R1, R2 in symmetrized relators set such that</font>
00434 <font class="comment">// R1 = p * r1 and R2 = p * r2 (graphically) satisfy the condition</font>
00435 <font class="comment">// |p| &lt; 1/lambda * min{|R1|, |R2|},  where |w| is the length of a word w,</font>
00436 <font class="comment">// then the finitely presented group is the metric small cancellation one,</font>
00437 <font class="comment">// and the answer is YES; otherwise NO.</font>
00438 <font class="comment">// This function is of limited usefulness, but can refute the small</font>
00439 <font class="comment">// cancellation property faster for a given lambda.</font>
00440 <font class="comment">// @stc need to add security checks</font>
00441 
00442 <font class="preprocessor">#endif</font>
00443 <font class="preprocessor"></font>
</pre></div><hr><address><small>Generated at Tue Jun 19 09:49:34 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
