<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/Equations/include/VectorPtr.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/Equations/include/VectorPtr.h</h1><a href="VectorPtr_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> *   $Id: VectorPtr.h,v 1.8 1999/11/23 20:25:06 bormotov Exp $</font>
00003 <font class="comment"> */</font>
00004  
00005 <font class="comment">//   Copyright (C) 1994 The New York Group Theory Cooperative</font>
00006 <font class="comment">//   See magnus/doc/COPYRIGHT for the full notice.</font>
00007  
00008 <font class="comment">// Contents: Definition of VectorPtrOf&lt;T&gt; and VectorPtrRep&lt;T&gt; class</font>
00009 <font class="comment">//</font>
00010 <font class="comment">// Principal Author: Dmitry Pechkin</font>
00011 <font class="comment">//</font>
00012 <font class="comment">// Status: under trial.</font>
00013 <font class="comment">//</font>
00014 <font class="comment">// Revision History:</font>
00015 <font class="comment">//</font>
00016 <font class="comment">// * 96/01/06 @dp Added functions in class VectorPtrOf&lt;T&gt;:</font>
00017 <font class="comment">//     T val( int i ) const;</font>
00018 <font class="comment">//     T&amp; ref( int i );</font>
00019 <font class="comment">//</font>
00020 <font class="comment">// * 7/96 Dmitry B. made porting to gcc 2.7.2.</font>
00021 <font class="comment">//</font>
00022 <font class="comment">// * 3/99 Dmitry B. moved the following implementation to VectorPtr.C </font>
00023 <font class="comment">//   to satisfy new C++ standard:</font>
00024 <font class="comment">//</font>
00025 <font class="comment">//   VectorItemRef&lt;T&gt; VectorPtrOf&lt;T&gt;::operator [] ( int i );</font>
00026 <font class="comment">//</font>
00027 <font class="comment">//</font>
00028 <font class="comment">// * 03/97 dp fixed VectorPtrRep::shrink(int start, int newlen);</font>
00029 <font class="comment">//                  VectorPtrRep( const VectorPtrRep&amp; vr );</font>
00030 <font class="comment">//                  bool VectorPtrOf::operator == ( const VectorPtrOf&amp; v ) const;</font>
00031 <font class="comment">//</font>
00032 <font class="comment">// * 04/97 dp added bool VectorPtrOf&lt;T&gt;::isValid(int) const.</font>
00033 <font class="comment">//</font>
00034 <font class="comment">// Special Notes:</font>
00035 <font class="comment">//</font>
00036 <font class="comment">// * These classes are remake of VectorOf&lt;T&gt; and VectorRep&lt;T&gt; classes</font>
00037 <font class="comment">//   for one purpose only: class T may not have default constructor.</font>
00038 <font class="comment">//   But new implementation is some slow.</font>
00039 <font class="comment">//</font>
00040 <font class="comment">// * Some problem exists: now on comparison of uninitialized element of</font>
00041 <font class="comment">//   VectorPtrOf&lt;T&gt; and element of T error will not occur </font>
00042 <font class="comment">//   (VectorPtrItemRef::operator==() is optimized for this),</font>
00043 <font class="comment">//   but if there is global operator==(T,T) error could be occur</font>
00044 <font class="comment">//   because in cast operator VectorPtrItemRef::operator T() </font>
00045 <font class="comment">//   method VectorPtr&lt;T&gt;::val(int) is called which caused error</font>
00046 <font class="comment">//   if the element is uninitialized. Should be behavoiur</font>
00047 <font class="comment">//</font>
00048 <font class="comment">// * They aren't derived from VectorOf&lt;&gt; and VectorRep&lt;&gt; because</font>
00049 <font class="comment">//   now the last ones require some repairs to fit to general scheme of </font>
00050 <font class="comment">//   derived objects, e.g. like Group hierarchy.</font>
00051 <font class="comment">//</font>
00052 <font class="comment">// * To instantiate VectorPtrOf&lt;T&gt;, class T must have</font>
00053 <font class="comment">//   1) A copy constructor</font>
00054 <font class="comment">//   2) An assignment operator</font>
00055 <font class="comment">//   3) An == operator</font>
00056 <font class="comment">//   4) A destructor</font>
00057 <font class="comment">//</font>
00058 <font class="comment">// OTHER NOTES FROM Vector.h:</font>
00059 <font class="comment">//</font>
00060 <font class="comment">// Further implementation steps:</font>
00061 <font class="comment">//</font>
00062 <font class="comment">// * Analogs of the List methods would be nice.</font>
00063 <font class="comment">//</font>
00064 <font class="comment">// * Should negative indices count from the end of the vector?</font>
00065 <font class="comment">//</font>
00066 <font class="comment">// * VectorOf should also have cast constructors from SetOf, ListOf, etc,</font>
00067 <font class="comment">//   in order to be able to conveniently use the latter where a VectorOf</font>
00068 <font class="comment">//   is expected in a constructor etc.</font>
00069 <font class="comment">//</font>
00070 <font class="comment">// * Should some compatibility mechanism be installed between things</font>
00071 <font class="comment">//   like say VectorOf&lt;Elt&gt; and VectorOf&lt;Word&gt;?</font>
00072 <font class="comment">//</font>
00073 <font class="comment">// Bugs:</font>
00074 <font class="comment">//</font>
00075 <font class="comment">// * g++ 2.5.8 and less can't find templates of non-inlined functions</font>
00076 <font class="comment">//   so it is necessary to give explicit definitions in Vector.C of</font>
00077 <font class="comment">//   every instance.</font>
00078 <font class="comment">//</font>
00079  
00080 <font class="preprocessor">#ifndef _VECTOR_PTR_H_</font>
00081 <font class="preprocessor"></font><font class="preprocessor">#define _VECTOR_PTR_H_</font>
00082 <font class="preprocessor"></font> 
00083 
00084 <font class="preprocessor">#include &lt;iostream.h&gt;</font>
00085 
00086 <font class="preprocessor">#include "<a class="code" href="RefCounter_h.html">RefCounter.h</a>"</font>
00087 <font class="preprocessor">#include "<a class="code" href="ObjectOf_h.html">ObjectOf.h</a>"</font>
00088 
00089 <font class="comment">//@db porting</font>
00090 template &lt; class T &gt; <font class="keyword">class </font><a class="code" href="class_VectorItemRef.html">VectorItemRef</a>;
00091 
00092 
<a name="l00093"></a><a class="code" href="struct_VectorPtrRep.html">00093</a> template &lt;class T&gt; <font class="keyword">struct </font><a class="code" href="struct_VectorPtrRep.html">VectorPtrRep</a> : <font class="keyword">public</font> <a class="code" href="class_RefCounter.html">RefCounter</a> {
00094   
00095   <font class="keyword">public</font> :
00096   
00097   <font class="comment">// copy constructor does deep copy</font>
00098   
<a name="l00099"></a><a class="code" href="struct_VectorPtrRep.html#a0">00099</a>   <a class="code" href="struct_VectorPtrRep.html#a0">VectorPtrRep</a>( <font class="keyword">const</font> <a class="code" href="struct_VectorPtrRep.html">VectorPtrRep</a>&amp; vr )<font class="keyword"> </font>{
00100     len = vr.last - vr.first;
00101     first = 0;
00102     last = len;
00103     vec = <font class="keyword">new</font> (T*)[len];
00104 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00105 <font class="preprocessor"></font>    <font class="keywordflow">if</font>( !vec )
00106       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::VectorPtrRep(const VectorPtrRep&amp; vr)"</font>);
00107 <font class="preprocessor">#endif</font>
00108 <font class="preprocessor"></font>    <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = 0; i &lt; len; i++ ) {
00109       <font class="keywordflow">if</font>( vr.vec[vr.first + i] ) {
00110         vec[i] = <font class="keyword">new</font> T( *vr.vec[vr.first + i] );
00111 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00112 <font class="preprocessor"></font>        <font class="keywordflow">if</font>( !vec[i] )
00113           <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::VectorPtrRep(const VectorPtrRep&amp; vr)"</font>);
00114 <font class="preprocessor">#endif</font>
00115 <font class="preprocessor"></font>      }
00116       <font class="keywordflow">else</font>
00117         vec[i] = NULL;
00118     }
00119     fastExpansion = <font class="keyword">false</font>;
00120   }
00121   
<a name="l00122"></a><a class="code" href="struct_VectorPtrRep.html#a1">00122</a>   <a class="code" href="struct_VectorPtrRep.html#a0">VectorPtrRep</a>( <font class="keywordtype">int</font> l )<font class="keyword"> </font>{
00123     len = l;
00124     first = 0;
00125     last = len;
00126     vec = <font class="keyword">new</font> (T*)[len];
00127 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00128 <font class="preprocessor"></font>    <font class="keywordflow">if</font>( !vec )
00129       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::VectorPtrRep(int)"</font>);
00130 <font class="preprocessor">#endif</font>
00131 <font class="preprocessor"></font>    <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i&lt;len; i++) vec[i] = NULL;
00132     fastExpansion = <font class="keyword">false</font>;
00133   }
00134   <font class="comment">// creates an uninitialized vector of length l</font>
00135   
<a name="l00136"></a><a class="code" href="struct_VectorPtrRep.html#a2">00136</a>   <a class="code" href="struct_VectorPtrRep.html#a0">VectorPtrRep</a>( <font class="keywordtype">int</font> l, <font class="keywordtype">bool</font> e )<font class="keyword"> </font>{
00137     len = l;
00138     first = 0;
00139     last = len;
00140     vec = <font class="keyword">new</font> (T*)[len];
00141 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00142 <font class="preprocessor"></font>    <font class="keywordflow">if</font>( !vec )
00143       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::VectorPtrRep(int, bool)"</font>);
00144 <font class="preprocessor">#endif</font>
00145 <font class="preprocessor"></font>    <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i&lt;len; i++) vec[i] = NULL;
00146     fastExpansion = e;
00147   }
00148   <font class="comment">// creates an uninitialized vector of length l</font>
00149 
<a name="l00150"></a><a class="code" href="struct_VectorPtrRep.html#a3">00150</a>   <a class="code" href="struct_VectorPtrRep.html#a3">~VectorPtrRep</a>( )<font class="keyword"> </font>{ 
00151     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i&lt;len; i++)
00152       <font class="keyword">delete</font> vec[i];
00153     <font class="keyword">delete</font> [] vec;
00154   }
00155   
00156   <font class="comment">// standard cloning operation for representations</font>
00157   
<a name="l00158"></a><a class="code" href="struct_VectorPtrRep.html#a4">00158</a>   <a class="code" href="struct_VectorPtrRep.html">VectorPtrRep</a>* <a class="code" href="struct_VectorPtrRep.html#a4">clone</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <font class="keyword">new</font> <a class="code" href="struct_VectorPtrRep.html#a0">VectorPtrRep</a>( *<font class="keyword">this</font> ); }
00159 
<a name="l00160"></a><a class="code" href="struct_VectorPtrRep.html#a5">00160</a>   <font class="keywordtype">int</font> <a class="code" href="struct_VectorPtrRep.html#a5">length</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> last - first; }
00161 
<a name="l00162"></a><a class="code" href="struct_VectorPtrRep.html#a6">00162</a>   <font class="keywordtype">bool</font> <a class="code" href="struct_VectorPtrRep.html#a6">isValid</a>(<font class="keywordtype">int</font> i)<font class="keyword"> const </font>{ 
00163 <font class="preprocessor">#if ( SAFETY &gt; 0 )</font>
00164 <font class="preprocessor"></font>    <font class="keywordflow">if</font> ( i &lt; 0 || i &gt;= last - first ) 
00165       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf index out of bounds "</font>
00166             <font class="stringliteral">"in VectorPtrRep::isValid(int)"</font>);
00167 <font class="preprocessor">#endif</font>
00168 <font class="preprocessor"></font>    <font class="keywordflow">return</font> ( vec[first+i] ? <font class="keyword">true</font> : <font class="keyword">false</font> );
00169   }
00170 
<a name="l00171"></a><a class="code" href="struct_VectorPtrRep.html#a7">00171</a>   <font class="keywordtype">void</font> <a class="code" href="struct_VectorPtrRep.html#a7">set</a>(<font class="keywordtype">int</font> i, <font class="keyword">const</font> T&amp; t)<font class="keyword"> </font>{
00172 <font class="preprocessor">#if ( SAFETY &gt; 0 )</font>
00173 <font class="preprocessor"></font>    <font class="keywordflow">if</font> ( i &lt; 0 || i &gt;= last - first ) 
00174       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf index out of bounds "</font>
00175             <font class="stringliteral">"in VectorPtrRep::set(int, const T&amp;)"</font>);
00176 <font class="preprocessor">#endif</font>
00177 <font class="preprocessor"></font>    <font class="keywordflow">if</font> (!vec[first+i]){
00178       <font class="keyword">delete</font> vec[first+i];
00179       vec[first+i] = <font class="keyword">new</font> T(t);
00180 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00181 <font class="preprocessor"></font>      <font class="keywordflow">if</font>( !vec[first+i] )
00182         <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::set(int,T)"</font>);
00183 <font class="preprocessor">#endif</font>
00184 <font class="preprocessor"></font>    }
00185     <font class="keywordflow">else</font> *vec[first+i] = t;
00186   }
00187 
00188   <font class="comment">// for reference access</font>
<a name="l00189"></a><a class="code" href="struct_VectorPtrRep.html#a8">00189</a>   T&amp; <a class="code" href="struct_VectorPtrRep.html#a8">ref</a>(<font class="keywordtype">int</font> i)<font class="keyword"> </font>{
00190 <font class="preprocessor">#if ( SAFETY &gt; 0 )</font>
00191 <font class="preprocessor"></font>    <font class="keywordflow">if</font> ( i &lt; 0 || i &gt;= last - first ) 
00192       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf index out of bounds in T&amp; VectorRep::ref(int) const"</font>);
00193     <font class="keywordflow">if</font>( !<a class="code" href="struct_VectorPtrRep.html#a6">isValid</a>(i) )
00194       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf access denied to uninitialized element "</font>
00195             <font class="stringliteral">"in T&amp; VectorPtrRep::ref(int) const"</font>);
00196 <font class="preprocessor">#endif</font>
00197 <font class="preprocessor"></font>    <font class="keywordflow">return</font> *vec[first + i];
00198   }
00199 
00200   <font class="comment">// for value access</font>
<a name="l00201"></a><a class="code" href="struct_VectorPtrRep.html#a9">00201</a>   T <a class="code" href="struct_VectorPtrRep.html#a9">val</a>(<font class="keywordtype">int</font> i)<font class="keyword"> const </font>{
00202 <font class="preprocessor">#if ( SAFETY &gt; 0 )</font>
00203 <font class="preprocessor"></font>    <font class="keywordflow">if</font> ( i &lt; 0 || i &gt;= last - first ) 
00204       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf index out of bounds in T VectorRep::val(int) const"</font>);
00205     <font class="keywordflow">if</font>( !<a class="code" href="struct_VectorPtrRep.html#a6">isValid</a>(i) )
00206       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf access denied to uninitialized element "</font>
00207             <font class="stringliteral">"in T VectorPtrRep::val(int) const"</font>);
00208 <font class="preprocessor">#endif</font>
00209 <font class="preprocessor"></font>    <font class="keywordflow">return</font> *vec[first + i];
00210   }
00211 
<a name="l00212"></a><a class="code" href="struct_VectorPtrRep.html#a10">00212</a>   <a class="code" href="class_VectorItemRef.html">VectorItemRef&lt;T&gt;</a> <a class="code" href="struct_VectorPtrRep.html#a10">operator [] </a>( <font class="keywordtype">int</font> i )<font class="keyword"> </font>{ 
00213 <font class="preprocessor">#if ( SAFETY &gt; 0 )</font>
00214 <font class="preprocessor"></font>    <font class="keywordflow">if</font> ( i &lt; 0 || i &gt;= <a class="code" href="struct_VectorPtrRep.html#a5">length</a>() ) 
00215       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf index out of bounds in VectorRep::operator [](int)"</font>);
00216 <font class="preprocessor">#endif</font>
00217 <font class="preprocessor"></font>    <font class="keywordflow">if</font>( <a class="code" href="struct_VectorPtrRep.html#a6">isValid</a>(i) )
00218       <font class="keywordflow">return</font> <a class="code" href="class_VectorItemRef.html">VectorItemRef&lt;T&gt;</a>(vec[i]);
00219     <font class="keywordflow">else</font>
00220       <font class="keywordflow">return</font> <a class="code" href="class_VectorItemRef.html">VectorItemRef&lt;T&gt;</a>(&amp;vec[i], 0);
00221   }
00222 
<a name="l00223"></a><a class="code" href="struct_VectorPtrRep.html#a11">00223</a>   <font class="keywordtype">void</font> <a class="code" href="struct_VectorPtrRep.html#a11">append</a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"> </font>{
00224     <font class="keywordflow">if</font> ( last &lt; len ) {
00225       vec[last++] = <font class="keyword">new</font> T(t);
00226     }
00227     <font class="keywordflow">else</font> {
00228       <font class="keywordflow">if</font>( fastExpansion &amp;&amp; len ) len *= 2; <font class="keywordflow">else</font> len++;
00229       T** new_vec = <font class="keyword">new</font> (T *)[len];
00230 <font class="preprocessor"> #if ( SAFETY &gt; 1 )</font>
00231 <font class="preprocessor"></font>      <font class="keywordflow">if</font>( !new_vec )
00232         <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::append(T)"</font>);
00233 <font class="preprocessor">#endif</font>
00234 <font class="preprocessor"></font>     <font class="keywordtype">int</font> j = 0;
00235       <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = first; i &lt; last; i++ )
00236         new_vec[j++] = vec[i];
00237       <font class="keyword">delete</font> [] vec;
00238       vec = new_vec;
00239       vec[j++] = <font class="keyword">new</font> T(t);
00240 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00241 <font class="preprocessor"></font>      <font class="keywordflow">if</font>( !vec[j-1] )
00242         <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::append(T)"</font>);
00243 <font class="preprocessor">#endif</font>
00244 <font class="preprocessor"></font>      last = j;
00245       first = 0;
00246       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = last; i&lt;len; i++)
00247         vec[i] = NULL;
00248     }
00249   }
00250 
<a name="l00251"></a><a class="code" href="struct_VectorPtrRep.html#a12">00251</a>   <font class="keywordtype">void</font> <a class="code" href="struct_VectorPtrRep.html#a12">prepend</a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"> </font>{
00252     <font class="keywordflow">if</font> ( first &gt; 0 ) {
00253       vec[--first] = <font class="keyword">new</font> T(t);
00254     }
00255     <font class="keywordflow">else</font> {
00256       <font class="keywordflow">if</font>( fastExpansion &amp;&amp; len ) len *= 2; <font class="keywordflow">else</font> len++;
00257       T** new_vec = <font class="keyword">new</font> (T *)[len];
00258 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00259 <font class="preprocessor"></font>    <font class="keywordflow">if</font>( !new_vec )
00260       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::prepend(T)"</font>);
00261 <font class="preprocessor">#endif</font>
00262 <font class="preprocessor"></font>      <font class="keywordtype">int</font> j = 0;
00263       new_vec[j++] = <font class="keyword">new</font> T(t);
00264 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00265 <font class="preprocessor"></font>    <font class="keywordflow">if</font>( !new_vec[0] )
00266       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorPtrRep::prepend(int)"</font>);
00267 <font class="preprocessor">#endif</font>
00268 <font class="preprocessor"></font>      <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = first; i &lt; last; i++ )
00269         new_vec[j++] = vec[i];
00270       <font class="keyword">delete</font> [] vec;
00271       vec = new_vec;
00272       last = j;
00273       first = 0;
00274       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = last; i&lt;len; i++)
00275         vec[i] = NULL;
00276     }
00277   }
00278 
<a name="l00279"></a><a class="code" href="struct_VectorPtrRep.html#a13">00279</a>   <font class="keywordtype">void</font> <a class="code" href="struct_VectorPtrRep.html#a13">shrink</a>( <font class="keywordtype">int</font> start, <font class="keywordtype">int</font> newlen )<font class="keyword"> </font>{
00280 <font class="preprocessor">#if ( SAFETY &gt; 0 )</font>
00281 <font class="preprocessor"></font>    <font class="keywordflow">if</font> ( start &lt; 0 || first + start &gt;= last || newlen &gt; last - first )
00282       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"argument to VectorRep::shrink out of bounds"</font>);
00283 <font class="preprocessor">#endif</font>
00284 <font class="preprocessor"></font>    <font class="comment">// The semantics are dangerous if we allow shrink to `expand' the VectorPtrOf:</font>
00285     <font class="comment">// a copy construction may throw the `extra' stuff away in between</font>
00286     <font class="comment">// calls to shrink.</font>
00287 
00288     <font class="comment">// free all elements of vector which are out of new bounds</font>
00289 
00290     T** tmp;
00291 
00292     T** tmpStart = vec+first+start;
00293     <font class="keywordflow">for</font>(tmp = vec+first; tmp&lt;tmpStart; tmp++) {
00294       <font class="keyword">delete</font> *tmp;
00295       *tmp = NULL;
00296     }
00297 
00298     T** tmpLast = vec+last;
00299     <font class="keywordflow">for</font>(tmp = tmpStart+newlen; tmp&lt;tmpLast; tmp++) {
00300       <font class="keyword">delete</font> *tmp;
00301       *tmp = NULL;
00302     }
00303 
00304     first += start;
00305     last = first + newlen;
00306   }
00307 
00308   
00309   <font class="keyword">private</font> :
00310   
00311   <font class="comment">// assignment operator undesired : made inaccessible private</font>
00312   <a class="code" href="struct_VectorPtrRep.html">VectorPtrRep</a>&amp; <a class="code" href="class_RefCounter.html#c0">operator = </a>( <font class="keyword">const</font> <a class="code" href="struct_VectorPtrRep.html">VectorPtrRep</a>&amp; );
00313   <font class="comment">// { }//@rn</font>
00314 
00315   <font class="comment">// data members</font>
00316   
<a name="l00317"></a><a class="code" href="struct_VectorPtrRep.html#o0">00317</a>   <font class="keywordtype">bool</font> fastExpansion; <font class="comment">// true if expansion should be done by doubling space </font>
<a name="l00318"></a><a class="code" href="struct_VectorPtrRep.html#o1">00318</a>   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> first; <font class="comment">// index of first valid entry</font>
<a name="l00319"></a><a class="code" href="struct_VectorPtrRep.html#o2">00319</a>   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> last;  <font class="comment">// index + 1 of last valid entry</font>
<a name="l00320"></a><a class="code" href="struct_VectorPtrRep.html#o3">00320</a>   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> len;   <font class="comment">// actual length of storage, so last - first &lt;= len</font>
00321   
<a name="l00322"></a><a class="code" href="struct_VectorPtrRep.html#o4">00322</a>   T** vec;
00323 };
00324 
00325 
00326 
<a name="l00327"></a><a class="code" href="class_VectorPtrOf.html">00327</a> template &lt;class T&gt; <font class="keyword">class </font><a class="code" href="class_VectorPtrOf.html">VectorPtrOf</a> : <font class="keyword">public</font> <a class="code" href="class_ObjectOf.html">ObjectOf</a>&lt; VectorPtrRep&lt;T&gt; &gt; {
00328   
<a name="l00329"></a><a class="code" href="class_VectorPtrOf.html#u0">00329</a>   <font class="keyword">typedef</font> <a class="code" href="struct_VectorPtrRep.html">VectorPtrRep&lt; T &gt;</a> <a class="code" href="struct_VectorPtrRep.html">Rep</a>;
<a name="l00330"></a><a class="code" href="class_VectorPtrOf.html#u1">00330</a>   <font class="keyword">typedef</font> <a class="code" href="class_ObjectOf.html">ObjectOf&lt; Rep &gt;</a> <a class="code" href="class_ObjectOf.html">Base</a>;
00331   
00332 <font class="keyword">public</font>:
00333   
00334   <font class="comment">// copy constructor, operator=, and destructor supplied by compiler.</font>
00335   
<a name="l00336"></a><a class="code" href="class_VectorPtrOf.html#a0">00336</a>   <a class="code" href="class_VectorPtrOf.html#a0">VectorPtrOf</a>( <font class="keywordtype">int</font> len = 0 ) : <a class="code" href="class_ObjectOf.html">Base</a>( new <a class="code" href="struct_VectorPtrRep.html">Rep</a>(len) ) { }
00337 
<a name="l00338"></a><a class="code" href="class_VectorPtrOf.html#a1">00338</a>   <a class="code" href="class_VectorPtrOf.html#a0">VectorPtrOf</a>( <font class="keywordtype">int</font> len, <font class="keywordtype">bool</font> e ) : <a class="code" href="class_ObjectOf.html">Base</a>( new <a class="code" href="struct_VectorPtrRep.html">Rep</a>(len,e) ) { }
00339   <font class="comment">// When e is true, the vector length doubles when an append or prepend</font>
00340   <font class="comment">// needs more space (instead of increasing by 1).</font>
00341 
<a name="l00342"></a><a class="code" href="class_VectorPtrOf.html#a2">00342</a>   <a class="code" href="class_VectorPtrOf.html#a0">VectorPtrOf</a>( <font class="keywordtype">int</font> len, <font class="keyword">const</font> <a class="code" href="class_VectorPtrOf.html">VectorPtrOf</a>&amp; v ) : <a class="code" href="class_ObjectOf.html">Base</a>( new <a class="code" href="struct_VectorPtrRep.html">Rep</a>(len) ) {
00343     <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; <a class="code" href="global_h.html#a5">min</a>( len, v.length() ); i++)
00344       <font class="keywordflow">if</font>( v.look()-&gt;isValid(i) )
00345         <a class="code" href="class_ObjectOf.html#b1">enhance</a>()-&gt;set(i, v[i]);
00346   }
00347   <font class="comment">// to make a vector of given length, (partly) initialized with</font>
00348   <font class="comment">// (part of) another vector</font>
00349 
<a name="l00350"></a><a class="code" href="class_VectorPtrOf.html#a3">00350</a>   <a class="code" href="class_VectorPtrOf.html#a0">VectorPtrOf</a>( <font class="keywordtype">int</font> len, <font class="keywordtype">bool</font> e, <font class="keyword">const</font> <a class="code" href="class_VectorPtrOf.html">VectorPtrOf</a>&amp; v ) : <a class="code" href="class_ObjectOf.html">Base</a>( new <a class="code" href="struct_VectorPtrRep.html">Rep</a>(len,e)){
00351     <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; <a class="code" href="global_h.html#a5">min</a>( len, v.length() ); i++) 
00352       <font class="keywordflow">if</font>( v.look()-&gt;isValid(i) )
00353         <a class="code" href="class_ObjectOf.html#b1">enhance</a>()-&gt;set(i, v[i]);
00354   }
00355   <font class="comment">// See comment for VectorPtrOf( int len, bool e ).</font>
00356 
<a name="l00357"></a><a class="code" href="class_VectorPtrOf.html#a4">00357</a>   <font class="keywordtype">bool</font> <a class="code" href="Property_h.html#a1">operator == </a>( <font class="keyword">const</font> <a class="code" href="class_VectorPtrOf.html">VectorPtrOf</a>&amp; v )<font class="keyword"> const</font>
00358 <font class="keyword">  </font>{
00359     <font class="keywordflow">if</font> (<a class="code" href="class_ObjectOf.html#b0">look</a>() == v.<a class="code" href="class_ObjectOf.html#b0">look</a>()) <font class="keywordflow">return</font> <font class="keyword">true</font>;
00360     <font class="keywordflow">if</font> ( <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;length() != v.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;<a class="code" href="struct_VectorPtrRep.html#a5">length</a>() ) <font class="keywordflow">return</font> <font class="keyword">false</font>;
00361     <font class="keywordtype">int</font> i = <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;length();
00362     <font class="keywordflow">while</font> ( i-- ) 
00363       <font class="keywordflow">if</font>( <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;isValid(i) != v.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;<a class="code" href="struct_VectorPtrRep.html#a6">isValid</a>(i) ||
00364           <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;isValid(i) &amp;&amp; !(<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;val(i) == v.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;<a class="code" href="struct_VectorPtrRep.html#a9">val</a>(i)) ) 
00365         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00366     <font class="keywordflow">return</font> <font class="keyword">true</font>;
00367   }
00368   
<a name="l00369"></a><a class="code" href="class_VectorPtrOf.html#a5">00369</a>   <font class="keywordtype">bool</font> <a class="code" href="Property_h.html#a2">operator != </a>( <font class="keyword">const</font> <a class="code" href="class_VectorPtrOf.html">VectorPtrOf</a>&amp; v )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> !(*<font class="keyword">this</font> == v); }
00370 
<a name="l00371"></a><a class="code" href="class_VectorPtrOf.html#a6">00371</a>   T <a class="code" href="class_VectorPtrOf.html#a6">operator [] </a>( <font class="keywordtype">int</font> i )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;val(i); }
00372 
<a name="l00373"></a><a class="code" href="class_VectorPtrOf.html#a7">00373</a>   <a class="code" href="class_VectorItemRef.html">VectorItemRef&lt;T&gt;</a> <a class="code" href="class_VectorPtrOf.html#a6">operator [] </a>( <font class="keywordtype">int</font> i )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;operator [](i); }
00374 
<a name="l00375"></a><a class="code" href="class_VectorPtrOf.html#a8">00375</a>   T <a class="code" href="class_VectorPtrOf.html#a8">val</a>( <font class="keywordtype">int</font> i )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;val(i); }
00376 
<a name="l00377"></a><a class="code" href="class_VectorPtrOf.html#a9">00377</a>   T&amp; <a class="code" href="class_VectorPtrOf.html#a9">ref</a>( <font class="keywordtype">int</font> i )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;ref(i); }
00378 
<a name="l00379"></a><a class="code" href="class_VectorPtrOf.html#a10">00379</a>   <font class="keywordtype">bool</font> <a class="code" href="class_VectorPtrOf.html#a10">isValid</a>( <font class="keywordtype">int</font> i )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;isValid(i); }
00380   
<a name="l00381"></a><a class="code" href="class_VectorPtrOf.html#a11">00381</a>   <font class="keywordtype">int</font> <a class="code" href="class_VectorPtrOf.html#a11">length</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;length(); }
00382 
<a name="l00383"></a><a class="code" href="class_VectorPtrOf.html#a12">00383</a>   <font class="keywordtype">int</font> <a class="code" href="class_VectorPtrOf.html#a12">hash</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;length(); }
00384   <font class="comment">//@rn Replace this in specific template instances if you want</font>
00385   <font class="comment">//    any semblance of efficiency.</font>
00386   
<a name="l00387"></a><a class="code" href="class_VectorPtrOf.html#a13">00387</a>   <font class="keywordtype">int</font> <a class="code" href="class_VectorPtrOf.html#a13">indexOf</a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"> const </font>{
00388     <font class="keywordtype">int</font> i = <a class="code" href="class_VectorPtrOf.html#a11">length</a>();
00389     <font class="keywordflow">while</font> ( i-- ) 
00390       <font class="keywordflow">if</font> ( <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;isValid(i) &amp;&amp; <a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;val(i) == t ) <font class="keywordflow">return</font> i;
00391     <font class="keywordflow">return</font> -1;
00392   }
00393   <font class="comment">// Returns the index of t in this VectorPtrOf, or -1 if not here.</font>
00394   
<a name="l00395"></a><a class="code" href="class_VectorPtrOf.html#a14">00395</a>   <font class="keywordtype">void</font> <a class="code" href="class_VectorPtrOf.html#a14">append</a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;append(t); }
00396   <font class="comment">// Appends t to this VectorPtrOf.</font>
00397   
<a name="l00398"></a><a class="code" href="class_VectorPtrOf.html#a15">00398</a>   <font class="keywordtype">void</font> <a class="code" href="class_VectorPtrOf.html#a15">prepend</a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;prepend(t); }
00399   <font class="comment">// Prepends t to this VectorPtrOf.</font>
00400 
<a name="l00401"></a><a class="code" href="class_VectorPtrOf.html#a16">00401</a>   <font class="keywordtype">void</font> <a class="code" href="class_VectorPtrOf.html#a16">shrink</a>( <font class="keywordtype">int</font> newLength )<font class="keyword"> </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;shrink(0, newLength); }
<a name="l00402"></a><a class="code" href="class_VectorPtrOf.html#a17">00402</a>   <font class="keywordtype">void</font> <a class="code" href="class_VectorPtrOf.html#a16">shrink</a>( <font class="keywordtype">int</font> start, <font class="keywordtype">int</font> newLength )<font class="keyword"></font>
00403 <font class="keyword">  </font>{ <a class="code" href="class_ObjectOf.html#b2">change</a>()-&gt;shrink(start, newLength); }
00404 
00405   <font class="comment">// I/O :</font>
00406  
00407   <font class="comment">// @stc these should not be inlined here but its easier than</font>
00408   <font class="comment">// fighting with g++'s template shortcomings</font>
<a name="l00409"></a><a class="code" href="class_VectorPtrOf.html#l0">00409</a>   <font class="keyword">inline</font> <font class="keyword">friend</font> ostream&amp; <a class="code" href="DatabaseManager_h.html#a28">operator &lt;&lt; </a>( ostream&amp; o, <font class="keyword">const</font> <a class="code" href="class_VectorPtrOf.html">VectorPtrOf</a>&amp; v )<font class="keyword"> </font>{
00410  
00411     o &lt;&lt; <font class="stringliteral">"&lt;"</font>;
00412     <font class="keywordflow">if</font> ( v.<a class="code" href="class_VectorPtrOf.html#a11">length</a>() == 0 )
00413       o &lt;&lt; <font class="stringliteral">" "</font>;
00414     <font class="keywordflow">else</font> {
00415       <font class="keywordflow">if</font>( v.<a class="code" href="class_VectorPtrOf.html#a10">isValid</a>(0) )
00416         o &lt;&lt; v[0];
00417       <font class="keywordflow">else</font>
00418         o &lt;&lt; <font class="stringliteral">"-?-"</font>;
00419     }
00420     <font class="keywordflow">for</font> ( <font class="keywordtype">int</font> i = 1; i &lt; v.<a class="code" href="class_VectorPtrOf.html#a11">length</a>(); i++ ) {
00421       o &lt;&lt; <font class="stringliteral">","</font>;
00422       <font class="keywordflow">if</font>( v.<a class="code" href="class_ObjectOf.html#b0">look</a>()-&gt;<a class="code" href="struct_VectorPtrRep.html#a6">isValid</a>(i) )
00423         o &lt;&lt; v[i];
00424       <font class="keywordflow">else</font>
00425         o &lt;&lt; <font class="stringliteral">"-?-"</font>; 
00426     }
00427     o &lt;&lt; <font class="stringliteral">"&gt;"</font>;
00428     <font class="keywordflow">return</font> o;
00429   }
00430  
00431 <font class="keyword">private</font>:
00432 
00433 };
00434 
00435 
<a name="l00436"></a><a class="code" href="class_VectorItemRef.html">00436</a> template &lt; class T &gt; <font class="keyword">class </font><a class="code" href="class_VectorItemRef.html">VectorItemRef</a> {
00437   
00438 <font class="keyword">public</font>:
00439   
00440   <font class="comment">// no default constructor because of reference members</font>
00441   <font class="comment">// destructor compiler-supplied</font>
00442   
<a name="l00443"></a><a class="code" href="class_VectorItemRef.html#a0">00443</a>   T&amp; <a class="code" href="class_ObjectOf.html#a2">operator = </a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"> </font>{ 
00444     <font class="keywordflow">if</font> (elPoint) 
00445       *elPoint = t;
00446     <font class="keywordflow">else</font> {
00447       elPoint = *elAddr = <font class="keyword">new</font> T(t);
00448 <font class="preprocessor">#if ( SAFETY &gt; 1 )</font>
00449 <font class="preprocessor"></font>      <font class="keywordflow">if</font>( !elPoint )
00450         <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"Cannot allocate memory in VectorItemRef::operator=(T&amp;)"</font>);
00451 <font class="preprocessor">#endif</font>
00452 <font class="preprocessor"></font>     
00453     }
00454     <font class="keywordflow">return</font> *elPoint;
00455   }
00456 
<a name="l00457"></a><a class="code" href="class_VectorItemRef.html#a1">00457</a>   <font class="keywordtype">bool</font> <a class="code" href="Property_h.html#a1">operator == </a>( <font class="keyword">const</font> T&amp; t )<font class="keyword"> </font>{ 
00458     <font class="keywordflow">if</font> (elPoint)
00459       <font class="keywordflow">return</font> *elPoint == t; 
00460     <font class="keywordflow">else</font>
00461       <font class="keywordflow">return</font> <font class="keyword">false</font>;
00462   }
00463   <font class="comment">// if a global operator == with two T arguments is defined, the above</font>
00464   <font class="comment">// is not necessary; if T only has a member operator == with one T</font>
00465   <font class="comment">// argument, then the above is necessary, since the ARM excludes</font>
00466   <font class="comment">// type conversion to apply a method.</font>
00467  
<a name="l00468"></a><a class="code" href="class_VectorItemRef.html#a2">00468</a>   <a class="code" href="class_VectorItemRef.html#a2">operator T</a>( )<font class="keyword"> </font>{ 
00469     <font class="keywordflow">if</font> (!elPoint)
00470       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf access denied to uninitialized element "</font>
00471             <font class="stringliteral">"in  VectorItemRef::operator T()"</font>);
00472     <font class="keywordflow">return</font> *elPoint;
00473   }
00474   
00475 <font class="keyword">private</font>:
00476 
<a name="l00477"></a><a class="code" href="class_VectorItemRef.html#l0">00477</a>   <font class="keyword">friend</font> <font class="keyword">class </font><a class="code" href="struct_VectorPtrRep.html">VectorPtrRep</a>&lt;T&gt;; <font class="comment">//@@rn only op[] when possible.</font>
00478 
<a name="l00479"></a><a class="code" href="class_VectorItemRef.html#c0">00479</a>   <a class="code" href="class_VectorItemRef.html#c0">VectorItemRef</a>( T* p) : elPoint(p) { }
00480   <font class="comment">// Hide this from unauthorized users.</font>
00481 
<a name="l00482"></a><a class="code" href="class_VectorItemRef.html#c1">00482</a>   <a class="code" href="class_VectorItemRef.html#c0">VectorItemRef</a>( T** addr, T* p) : elPoint(0), elAddr(addr) { }
00483   <font class="comment">// Hide this from unauthorized users.</font>
00484 
00485   <font class="comment">// data members</font>
00486 
00487 
<a name="l00488"></a><a class="code" href="class_VectorItemRef.html#o0">00488</a>   T* elPoint;
<a name="l00489"></a><a class="code" href="class_VectorItemRef.html#o1">00489</a>   T** elAddr;
00490 
00491 <font class="keyword">private</font>:
00492 
00493   <font class="comment">//@dp old notes: no assignment operator generated by compiler because of ref member.</font>
00494   <font class="comment">//@dp Really, compiler (gcc 2.7.2) generates default operator=(const VectorItemRef&amp;)</font>
00495   <font class="comment">//    like for the structures that is wrong. We need this operator in expressions </font>
00496   <font class="comment">//    like this:  a[i] = b[i] where b[i] must be initialized.</font>
00497   <a class="code" href="class_VectorItemRef.html">VectorItemRef</a>&amp; <a class="code" href="class_ObjectOf.html#a2">operator = </a>( <font class="keyword">const</font> <a class="code" href="class_VectorItemRef.html">VectorItemRef</a>&amp; ref );
00498 
00499   <font class="comment">// make copy constructor inaccessible</font>
00500 
00501   <font class="comment">// @db porting</font>
00502 
00503 <font class="keyword">public</font>: 
00504 
<a name="l00505"></a><a class="code" href="class_VectorItemRef.html#a3">00505</a>   <a class="code" href="class_VectorItemRef.html#c0">VectorItemRef</a>( <font class="keyword">const</font> <a class="code" href="class_VectorItemRef.html">VectorItemRef</a>&amp; ref )<font class="keyword"></font>
00506 <font class="keyword">  </font>{
00507     <font class="keywordflow">if</font>( !ref.elPoint ) {
00508       <a class="code" href="error_h.html#a0">error</a>(<font class="stringliteral">"VectorPtrOf&lt;T&gt;: access denied to uninitialized element t"</font>
00509             <font class="stringliteral">"in  VectorItemRef::operator=(const VectorItemRef&amp; t)"</font>);
00510       
00511     }
00512     <font class="keywordflow">if</font>( <font class="keyword">this</font> != &amp;ref ) {
00513       <font class="keywordflow">if</font>( elPoint )
00514         *elPoint = *ref.elPoint;
00515       <font class="keywordflow">else</font>
00516         elPoint = *elAddr = <font class="keyword">new</font> T( *ref.elPoint );
00517     }
00518   }
00519 
00520 };
00521 
00522 <font class="preprocessor">#endif</font>
</font></pre></div><hr><address><small>Generated at Tue Jun 19 09:49:35 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
