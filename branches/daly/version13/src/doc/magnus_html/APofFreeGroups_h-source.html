<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/AProducts/include/APofFreeGroups.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/AProducts/include/APofFreeGroups.h</h1><a href="APofFreeGroups_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> *   $Id: APofFreeGroups.h,v 1.6 2000/02/09 22:07:31 bormotov Exp $</font>
00003 <font class="comment"> */</font>
00004 
00005 <font class="comment">// Copyright (C) 1996 The New York Group Theory Cooperative</font>
00006 <font class="comment">// See magnus/doc/COPYRIGHT for the full notice.</font>
00007 
00008 <font class="comment">// Contents: Definition of the AmalgProductOfFreeGroups class.</font>
00009 <font class="comment">//</font>
00010 <font class="comment">// Principal Authors: Eugene Paderin, Dmitry Pechkin</font>
00011 <font class="comment">//</font>
00012 <font class="comment">// Status: in progress</font>
00013 <font class="comment">//</font>
00014 <font class="comment">// Revision History:</font>
00015 <font class="comment">//</font>
00016 <font class="comment">//   02-10-96: the preliminary release.</font>
00017 <font class="comment">//</font>
00018 <font class="comment">//   03-29-96: bugfix, more comments added.</font>
00019 <font class="comment">//</font>
00020 <font class="comment">// Special Notes:</font>
00021 <font class="comment">//</font>
00022 <font class="comment">//  * Local And Global Words</font>
00023 <font class="comment">//</font>
00024 <font class="comment">//  When dealing with AP words, we use two distinct ways of coding</font>
00025 <font class="comment">//  generators. The AP is defined with two groups which of them has</font>
00026 <font class="comment">//  its own "local" coding of generators. The result is an FP group</font>
00027 <font class="comment">//  generated by the same generators, but coded the different way</font>
00028 <font class="comment">//  (generators of the first group have the same numbers while those</font>
00029 <font class="comment">//  of the second one have shifted numbers -- we call this coding</font>
00030 <font class="comment">//  global). The user gives words in global coding using letters</font>
00031 <font class="comment">//  from both groups -- we do not redefine FPGroup::readWord and</font>
00032 <font class="comment">//  FPGroup::writeWord (so the FrontEnd developer should take this</font>
00033 <font class="comment">//  into account). At the same time, all manipulations with subgroups</font>
00034 <font class="comment">//  and their bases are being done in local coding, so we have to</font>
00035 <font class="comment">//  convert words from one coding into another, and vice versa.</font>
00036 <font class="comment">//</font>
00037 <font class="comment">//</font>
00038 
00039 <font class="preprocessor">#ifndef _AMALGAMATED_PRODUCT_H_</font>
00040 <font class="preprocessor"></font><font class="preprocessor">#define _AMALGAMATED_PRODUCT_H_</font>
00041 <font class="preprocessor"></font>
00042 <font class="preprocessor">#include "<a class="code" href="FreeGroup_h.html">FreeGroup.h</a>"</font>
00043 <font class="preprocessor">#include "<a class="code" href="FPGroup_h.html">FPGroup.h</a>"</font>
00044 <font class="preprocessor">#include "<a class="code" href="APofFreeGroupsRep_h.html">APofFreeGroupsRep.h</a>"</font>
00045 
00046 
<a name="l00047"></a><a class="code" href="class_AmalgProductOfFreeGroups.html">00047</a> <font class="keyword">class </font><a class="code" href="class_AmalgProductOfFreeGroups.html">AmalgProductOfFreeGroups</a> : <font class="keyword">public</font> <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;FPGroup,AmalgProductOfFreeGroupsRep&gt; {
00048 
00049 <font class="keyword">public</font>:
00050 <font class="comment"></font>
00051 <font class="comment">  ///////////////////////////////////////////////////////</font>
00052 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00053   <font class="comment">//  Constructors                                     //</font>
00054   <font class="comment">//                                                   //</font><font class="comment"></font>
00055 <font class="comment">  ///////////////////////////////////////////////////////</font>
00056 <font class="comment"></font>
00057   <font class="comment">// Copy constructor, operator= and destructor provided by compiler.</font>
00058 
00059   <font class="comment">// To define the amalgamated product (AP), one should give two</font>
00060   <font class="comment">// (free) groups as factors, and two vectors of Words which define</font>
00061   <font class="comment">// two subgroups in corresponding groups (so the vectors must be bases).</font>
00062   <font class="comment">// Then we claim the subgroups to be amalgamated, i.e. we suppose</font>
00063   <font class="comment">// that the ith word of the first vector is mapped to the ith word</font>
00064   <font class="comment">// of the second one. This is a standard way to define an AP.</font>
00065 
00066   <font class="comment">// At the same time, we define the AP as a FP group, so all the</font>
00067   <font class="comment">// methods of FPGroup is fully applicable to the AP class.</font>
00068 
<a name="l00069"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a0">00069</a>   <a class="code" href="class_AmalgProductOfFreeGroups.html#a0">AmalgProductOfFreeGroups</a>() :
00070   <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_FPGroup.html">FPGroup</a>, <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>&gt;(
00071         new <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>(<a class="code" href="class_FreeGroup.html">FreeGroup</a>(), <a class="code" href="class_FreeGroup.html">FreeGroup</a>(),
00072                                         <a class="code" href="class_VectorOf.html">VectorOf</a>&lt;<a class="code" href="class_Word.html">Word</a>&gt;(), <a class="code" href="class_VectorOf.html">VectorOf</a>&lt;<a class="code" href="class_Word.html">Word</a>&gt;() )
00073     ) {}
00074   <font class="comment">// Default constructor is provided solely for constructing an AP group</font>
00075   <font class="comment">// from an input stream, e.g. like this:</font>
00076   <font class="comment">//</font>
00077   <font class="comment">//   AmalgProductOfFreeGroups AP;</font>
00078   <font class="comment">//   Chars errMesg = cin &gt;&gt; AP;</font>
00079   <font class="comment">//   ...</font>
00080   <font class="comment">// Do not use it for purposes other than this.</font>
00081 
<a name="l00082"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a1">00082</a>   <a class="code" href="class_AmalgProductOfFreeGroups.html#a0">AmalgProductOfFreeGroups</a>(<font class="keyword">const</font> <a class="code" href="class_FreeGroup.html">FreeGroup</a>&amp; g1, <font class="keyword">const</font> <a class="code" href="class_FreeGroup.html">FreeGroup</a>&amp; g2,
00083                            <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gen1,
00084                            <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gen2  ) :
00085     <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_FPGroup.html">FPGroup</a>, <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>&gt;(
00086         new <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>(g1, g2, gen1, gen2)
00087     ) {}
00088   <font class="comment">// Construct an amalgamated product of given free groups. Given vectors</font>
00089   <font class="comment">// of words generate associated subgroups.</font>
00090 
<a name="l00091"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a2">00091</a>   <a class="code" href="class_AmalgProductOfFreeGroups.html#a0">AmalgProductOfFreeGroups</a>(<font class="keyword">const</font> <a class="code" href="class_SGofFreeGroup.html">SGofFreeGroup</a>&amp; sg1, <font class="keyword">const</font> <a class="code" href="class_SGofFreeGroup.html">SGofFreeGroup</a>&amp; sg2)
00092     : <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_FPGroup.html">FPGroup</a>, <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>&gt;(
00093         new <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>(sg1, sg2) 
00094       ) {}
00095   <font class="comment">// Construct an amalgamated product with given (associated) subgroups</font>
00096   <font class="comment">// which store references to their parent groups.</font>
00097 
<a name="l00098"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a3">00098</a>   <a class="code" href="class_AmalgProductOfFreeGroups.html#a0">AmalgProductOfFreeGroups</a>( <font class="keyword">const</font> <a class="code" href="class_Group.html">Group</a>&amp; G ) :
00099     <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_FPGroup.html">FPGroup</a>,<a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>&gt;(G) { }
00100   <font class="comment">// Cast construtor: to cast an arbitrary group as an AP group.</font>
00101   <font class="comment">// NB. This rewraps the unchanged representation, hence is in general</font>
00102   <font class="comment">// only useful for casting a group known to be an actual AP group.</font>
00103 
00104   <font class="comment">// Destructor provided by compiler.</font>
00105 <font class="comment"></font>
00106 <font class="comment">  ///////////////////////////////////////////////////////</font>
00107 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00108   <font class="comment">//  Accessors / Modifiers                            //</font>
00109   <font class="comment">//                                                   //</font><font class="comment"></font>
00110 <font class="comment">  ///////////////////////////////////////////////////////</font>
00111 <font class="comment"></font>
<a name="l00112"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#d0">00112</a>   <font class="keyword">static</font> <a class="code" href="class_Type.html">Type</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#d0">type</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html#d0">AmalgProductOfFreeGroupsRep::type</a>(); }
00113   <font class="comment">// Overrides FPGroup::type();</font>
00114   
00115   <font class="comment">// Type actualType() const; </font>
00116   <font class="comment">// Overrides pseudo-virtual FPGroup::actualType().</font>
00117 
00118 
00119   <a class="code" href="class_FreeGroup.html">FreeGroup</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a4">factor</a>( <font class="keyword">const</font> NumberOfFactor&amp; t ) <font class="keyword">const</font>;
00120   <font class="comment">// Returns left or right factor of the amalgamated product.</font>
00121   <font class="comment">// LEFT_FACTOR and RIGHT_FACTOR values are valid for number of factor.</font>
00122 
00123   <a class="code" href="class_SGofFreeGroup.html">SGofFreeGroup</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a5">subgroup</a>( <font class="keyword">const</font> NumberOfFactor&amp; t ) <font class="keyword">const</font>;
00124   <font class="comment">// Returns amalgamated subgroup of left or right factor respectively.</font>
00125   <font class="comment">// LEFT_FACTOR and RIGHT_FACTOR values are valid for number of factor.</font>
00126 <font class="comment"></font>
00127 <font class="comment">  ///////////////////////////////////////////////////////</font>
00128 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00129   <font class="comment">//  Methods dealing with group structure             //</font>
00130   <font class="comment">//                                                   //</font><font class="comment"></font>
00131 <font class="comment">  ///////////////////////////////////////////////////////</font>
00132 <font class="comment"></font>
00133   <font class="comment">// int order( ) const;   </font>
00134   <font class="comment">// Returns the order of the AP as the FP group.</font>
00135   <font class="comment">// Overrides pseudo-virtual FPGroup::order().</font>
00136             
<a name="l00137"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a6">00137</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a6">isFree</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b1">enhance</a>()-&gt;isFree(); }
00138   <font class="comment">// Returns YES if this group is free on its generators, NO if not,</font>
00139   <font class="comment">// and DONTKNOW if this cannot be currently determined.</font>
00140   <font class="comment">//@ep  Now gives answer only for some special cases;</font>
00141   <font class="comment">//     to be enhanced in the future.</font>
00142   <font class="comment"></font>
00143 <font class="comment">  ///////////////////////////////////////////////////////</font>
00144 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00145   <font class="comment">//  Methods which deal with group elements           //</font>
00146   <font class="comment">//                                                   //</font><font class="comment"></font>
00147 <font class="comment">  ///////////////////////////////////////////////////////</font>
00148 <font class="comment"></font>      
00149   <font class="comment">// Elt eval( const Word&amp; w ) const;</font>
00150   <font class="comment">// Takes a word and evaluates it as a formal word in the generators</font>
00151   <font class="comment">// of the group. Returns a (possibly canonic) representative of the</font>
00152   <font class="comment">// element. </font>
00153   <font class="comment">// Overrides pseudo-virtual FPGroup::eval().</font>
00154 
00155   <font class="comment">// Trichotomy wordProblem( const Word&amp; w ) const;</font>
00156   <font class="comment">// Returns YES if w represents the identity, NO if not, and</font>
00157   <font class="comment">// DONTKNOW if no answer can be determined.</font>
00158   <font class="comment">// Overrides pseudo-virtual FPGroup::wordProblem().</font>
00159 
<a name="l00160"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a7">00160</a>   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a7">decompose</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00161     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;decompose(w);
00162   }
00163   <font class="comment">// Decomposes the given word to the product of words d_1 d_2 ....</font>
00164   <font class="comment">// such that every d_i belongs to one of the factors and any</font>
00165   <font class="comment">// two successive words belong to distinct factors.</font>
00166   <font class="comment">// If w is empty word, returns Vector of size 0.</font>
00167     
<a name="l00168"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a8">00168</a>   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a8">reducedDecomposition</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00169     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;reducedDecomposition(w);
00170   }
00171   <font class="comment">// Finds the minimal (in the sense of number of components) decomposition</font>
00172   <font class="comment">// of the given word. Each component belongs to one factor and any two </font>
00173   <font class="comment">// successive components belong to different factors.</font>
00174   <font class="comment">// If w is identity element in AP, returns Vector of size 0.</font>
00175   
<a name="l00176"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a9">00176</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a9">reducedFormOf</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00177     <font class="keywordflow">return</font> <a class="code" href="AP-fixups_h.html#a14">compose</a>(<a class="code" href="class_AmalgProductOfFreeGroups.html#a8">reducedDecomposition</a>(w));
00178   }
00179   <font class="comment">// As above, but result is presented as a single word.</font>
00180   
<a name="l00181"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a10">00181</a>   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a10">normalDecomposition</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00182     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;normalDecomposition(w);
00183   }
00184   <font class="comment">// Finds the normal decomposition of the given word: this is</font>
00185   <font class="comment">// the reduced decomposition where all components except the</font>
00186   <font class="comment">// first one are some right Schreier representatives.</font>
00187   <font class="comment">// Returns vector of components of decomposition.</font>
00188   
<a name="l00189"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a11">00189</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a11">normalFormOf</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00190     <font class="keywordflow">return</font> <a class="code" href="AP-fixups_h.html#a14">compose</a>(<a class="code" href="class_AmalgProductOfFreeGroups.html#a10">normalDecomposition</a>(w));
00191   }
00192   <font class="comment">// Finds the normal decomposition of the given word: this is</font>
00193   <font class="comment">// the reduced decomposition where all components except the</font>
00194   <font class="comment">// first one are some right Schreier representatives.</font>
00195   <font class="comment">// As above, but result is presented as a single word.</font>
00196 
<a name="l00197"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a12">00197</a>   <font class="keywordtype">void</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a12">cyclicDecomposition</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; result, 
00198                            <a class="code" href="class_Word.html">Word</a>&amp; conjugator)<font class="keyword"> const </font>
00199 <font class="keyword">  </font>{
00200     <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;cyclicDecomposition(w,result,conjugator);
00201   }
00202   <font class="comment">// Finds cyclic reduced decomposition (named `result') of w such that </font>
00203   <font class="comment">//          w = result^conjugator.</font>
00204   <font class="comment">// Cyclic decomposition is normal one satisfied the condition: all cyclic </font>
00205   <font class="comment">// permutations are normal decompositions. Let a normal decomposition </font>
00206   <font class="comment">// be g_1 * g_2 * ... * g_N, then the last one satisfies the condition above </font>
00207   <font class="comment">// iff  N &gt; 1 &amp;&amp; factor(g1) != factor(gN)  or N &lt;= 1.</font>
00208   <font class="comment">// Each word of `result' represents a component g_i of the decomposition.</font>
00209 
<a name="l00210"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a13">00210</a>   <font class="keywordtype">void</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a13">cyclicReduction</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <a class="code" href="class_Word.html">Word</a>&amp; result, <a class="code" href="class_Word.html">Word</a>&amp; conjugator)<font class="keyword"> const </font>{
00211     <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;cyclicReduction(w,result,conjugator);
00212   }
00213   <font class="comment">// Finds cyclic reduction (named `result') of w such that </font>
00214   <font class="comment">//          w = result^conjugator.</font>
00215   <font class="comment">// Cyclic decomposition is normal one satisfied the condition: all cyclic </font>
00216   <font class="comment">// permutations are normal decompositions. Let a normal decomposition </font>
00217   <font class="comment">// be g1 * g2 * ... * gN, then the last one satisfies the condition above </font>
00218   <font class="comment">// iff  N &gt; 1 &amp;&amp; factor(g1) != factor(gN)  or N &lt;= 1.</font>
00219   <font class="comment">// As above, but `result' is presented as a single word.</font>
00220 
<a name="l00221"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a14">00221</a>   <font class="keywordtype">int</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a14">numberOfSubstitutions</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w )<font class="keyword"> const </font>{
00222     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;numberOfSubstitutions( w );
00223   }
00224   <font class="comment">// If the given word represents 1 in the group</font>
00225   <font class="comment">// the function computes the number of uses of a relation</font>
00226   <font class="comment">// a = b to deduce that w = 1, i.e. in re-expressing w as </font>
00227   <font class="comment">// a product of conjugates of a * b^-1, computes the number</font>
00228   <font class="comment">// of these conjugates.</font>
00229 
00230   
<a name="l00231"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a15">00231</a>   NumberOfFactor <a class="code" href="class_AmalgProductOfFreeGroups.html#a15">factorOfFormalWord</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00232     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;factorOfFormalWord(w);
00233   }
00234   <font class="comment">// Determines the group the given formal word belongs to.</font>
00235   
<a name="l00236"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a16">00236</a>   NumberOfFactor <a class="code" href="class_AmalgProductOfFreeGroups.html#a16">factorOfElement</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00237     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;factorOfElement(w);
00238   }
00239   <font class="comment">// Determines the group the given formal word belongs to</font>
00240   <font class="comment">// and also checks whether the given element of the product belongs to </font>
00241   <font class="comment">// the amalgamated subgroup.</font>
00242   
<a name="l00243"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a17">00243</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a17">localToGlobal</a>(<font class="keyword">const</font> <a class="code" href="struct_LocalWord.html">LocalWord</a>&amp; w)<font class="keyword"> const </font>{
00244     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;localToGlobal(w);
00245   }
00246   <font class="comment">// Converts local coding word into global one.</font>
00247   
<a name="l00248"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a18">00248</a>   <a class="code" href="struct_LocalWord.html">LocalWord</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a18">globalToLocal</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00249     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;globalToLocal(w);
00250   }
00251   <font class="comment">// Converts global coding word into local one.</font>
00252   
00253   
<a name="l00254"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a19">00254</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="class_AmalgProductOfFreeGroups.html#a19">isHyperbolic</a>()<font class="keyword"> const </font>{
00255     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;isHyperbolic();
00256   }
00257   <font class="comment">// In general, the problem is undecidable, so this method can</font>
00258   <font class="comment">// return dontknow.</font>
00259   <font class="comment">//@ep In present, it _always_ returns dontknow -- temporary stub.</font>
00260   
00261   
<a name="l00262"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a20">00262</a>   <font class="keywordtype">void</font> <a class="code" href="Word_h.html#a1">maximalRoot</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <a class="code" href="class_Word.html">Word</a>&amp; root, <font class="keywordtype">int</font>&amp; power)<font class="keyword"> const </font>{
00263     <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;maximalRoot(w,root,power);
00264   }
00265   <font class="comment">// Finds maximal root of given word w. The root word is stored in `root',</font>
00266   <font class="comment">// and its power in `power'.</font>
00267   <font class="comment">//@ep  This is a temporary stub implemented only for one relator case.</font>
00268   <font class="comment">// Included here for maintaining inheritance. Invoking this causes</font>
00269   <font class="comment">// an error report.</font>
00270   
00271   <font class="comment">//@ep  The following two methods need maximalRoot to be implemented, so</font>
00272   <font class="comment">// they are now defined only for one relator case.</font>
00273   
<a name="l00274"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a21">00274</a>   <font class="keywordtype">bool</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a21">isProperPower</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00275     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;isProperPower(w);
00276   }
00277   <font class="comment">// Determines whether w is a proper power.</font>
00278   
<a name="l00279"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a22">00279</a>   <font class="keywordtype">bool</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a22">isProperPowerOfSecond</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w, <font class="keywordtype">int</font>&amp; power)<font class="keyword"> const </font>{
00280     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;isProperPowerOfSecond( u, w, power );
00281   }
00282   <font class="comment">// Determines whether u is a proper power of w.</font>
00283   
<a name="l00284"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a23">00284</a>   <font class="keywordtype">bool</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a23">commute</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w)<font class="keyword"> const </font>{
00285     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;commute(u,w);
00286   }
00287   <font class="comment">// Determines whether [u,w] = 1.</font>
00288   
<a name="l00289"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a24">00289</a>   <font class="keywordtype">bool</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a24">isSubgroupAbelian</a>(<font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; subgroupWords)<font class="keyword"> const </font>{
00290     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;isSubgroupAbelian(subgroupWords);
00291   }
00292   <font class="comment">// Determines whether the subgroup generated by the given set of words</font>
00293   <font class="comment">// is abelian.</font>
00294 
<a name="l00295"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a25">00295</a>   <font class="keywordtype">bool</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a25">isSubgroupTrivial</a>(<font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; vec)<font class="keyword"> const </font>{
00296     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;isSubgroupTrivial(vec);
00297   }
00298   <font class="comment">// Determines whether subgroup generated by vec is trivial.</font>
00299 
<a name="l00300"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a26">00300</a>   <font class="keywordtype">bool</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a26">isSubgroupCyclic</a>(<font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; vec)<font class="keyword"> const </font>{
00301     <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;isSubgroupCyclic(vec);
00302   }
00303   <font class="comment">// Determines whether subgroup generated by vec is cyclic.</font>
00304   <font class="comment">//@ep Invokes maximalRoot, so it is unusable now.</font>
00305 
00306 <font class="comment"></font>
00307 <font class="comment">  ///////////////////////////////////////////////////////</font>
00308 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00309   <font class="comment">//  I/O                                              //</font>
00310   <font class="comment">//                                                   //</font><font class="comment"></font>
00311 <font class="comment">  ///////////////////////////////////////////////////////</font>
00312 <font class="comment"></font>
00313   <font class="comment">// void printRelators(ostream&amp; ostr) const;</font>
00314   <font class="comment">// Overrides pseudo-virtual FPGroup::printRelators().</font>
00315 
00316   <font class="comment">// void printOn(ostream&amp; o) const;</font>
00317   <font class="comment">// Overrides pseudo-virtual FPGroup::printOn().</font>
00318 
00319   <font class="comment">// GroupRep* readFrom(istream&amp; istr, Chars&amp; errMesg) const;</font>
00320   <font class="comment">// Overrides pseudo-virtual FPGroup::readFrom().</font>
00321 
<a name="l00322"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#a27">00322</a>   <font class="keywordtype">void</font> <a class="code" href="class_AmalgProductOfFreeGroups.html#a27">printDecomposition</a>(ostream&amp; ostr, <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> deco)<font class="keyword"> const </font>{
00323     <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;printDecomposition(ostr, deco);
00324   }
00325   <font class="comment">// Prints given vector of words which are separated by dot:</font>
00326   <font class="comment">//           word1 . word2 .     . wordN</font>
00327 <font class="comment"></font>
00328 <font class="comment">  ///////////////////////////////////////////////////////</font>
00329 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00330   <font class="comment">//  Private helper stuff:                            //</font>
00331   <font class="comment">//                                                   //</font><font class="comment"></font>
00332 <font class="comment">  ///////////////////////////////////////////////////////</font>
00333 <font class="comment"></font>
00334 <font class="keyword">protected</font>:
00335 
00336   <font class="comment">// Special wrapping constructor to wrap new representations (returned</font>
00337   <font class="comment">// by eg. delegated methods) and for base initialisation by derived</font>
00338   <font class="comment">// classes:</font>
00339   
<a name="l00340"></a><a class="code" href="class_AmalgProductOfFreeGroups.html#b0">00340</a>   <a class="code" href="class_AmalgProductOfFreeGroups.html#a0">AmalgProductOfFreeGroups</a>( <a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>* newrep ) :
00341   <a class="code" href="class_DerivedObjectOf.html">DerivedObjectOf</a>&lt;<a class="code" href="class_FPGroup.html">FPGroup</a>,<a class="code" href="struct_AmalgProductOfFreeGroupsRep.html">AmalgProductOfFreeGroupsRep</a>&gt;(newrep) { }
00342   
00343 <font class="comment"></font>
00344 <font class="comment">  ///////////////////////////////////////////////////////</font>
00345 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00346   <font class="comment">//  Debugging stuff                                  //</font>
00347   <font class="comment">//                                                   //</font><font class="comment"></font>
00348 <font class="comment">  ///////////////////////////////////////////////////////</font>
00349 <font class="comment"></font>
00350 <font class="keyword">private</font>:
00351 
00352 <font class="preprocessor">#ifdef DEBUG</font>
00353 <font class="preprocessor"></font>  <font class="comment">//friend int main( );</font>
00354   <font class="keyword">friend</font> <font class="keywordtype">void</font> <a class="code" href="Margin_h.html#a9">debugPrint</a>(ostream&amp;, <font class="keyword">const</font> <a class="code" href="class_AmalgProductOfFreeGroups.html">AmalgProductOfFreeGroups</a>&amp; g);
00355 <font class="preprocessor">#endif</font>
00356 <font class="preprocessor"></font>
00357 };
00358 
00359 <font class="preprocessor">#endif</font>
00360 <font class="preprocessor"></font>
00361 
</pre></div><hr><address><small>Generated at Tue Jun 19 09:49:33 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
