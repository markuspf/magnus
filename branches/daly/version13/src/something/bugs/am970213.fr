From alexei@rio Thu Feb 13 14:58:51 1997
Date: Thu, 13 Feb 1997 14:58:43 -0500
From: alexei@rio (Alexei Myasnikov)
To: bormotov@rio

           Magnus Version 1.9.7 beta,
         Release date: February 11, 1997
Magnus session started on
Thu Feb 13 14:46:50 EST 1997
by alexei at giraffe.
SunOS giraffe 5.5 Generic_103093-07 sun4m sparc SUNW,SPARCstation-20 sparc sun4
<(1) magic_cookie_ 20984
<(2) init_quit_msg_ {-1 0}
<(3) init_delete_msg_ {-1 1}
<(4) init_view_req_msg_ {${viewID} 0 ${ARCSlotID}}
<(5) init_arc_msg_ {${viewID} 1 ${ARCSlotID} ${value}}
<(6) init_start_msg_ {${viewID} 2}
<(7) init_suspend_msg_ {${viewID} 3}
<(8) init_resume_msg_ {${viewID} 4}
<(9) init_terminate_msg_ {${viewID} 5}
<(10) type_name_ {finitely presented group} G SMFPGroup
<(11) type_name_ {word} w SMWord
<(12) type_name_ {subgroup} H SMSubgroup
<(13) type_name_ {map} m SMMap
<(14) type_name_ {equation} E SMEquation
<(15) menu_defn_ menu checkin signature {} itemGroups {{1 {{{Abelian Group} {_defineAbelGroup_ {Define an abelian group}} {-2 0}} {{Automatic Group} {} {}} {{Finitely Presented Group} {_defineFPGroup_ {Define a finitely presented group}} {-2 1}} {{Free Group} {_defineFreeGroup_ {Define a free group}} {-2 2}} {{Hyperbolic Group} {} {}} {{Matrix Group} {} {}} {{Metabelian Group} {} {}} {{Nilpotent Group} {_defineNilpotentGroup_ {Define a nilpotent group}} {-2 3}} {{One Relator Group} {_defineFPGroup_ {Define an one-relator group}} {-2 4}} {{Permutation Group} {} {}} {{Polycyclic Group} {} {}} {{Small Cancellation Group} {_defineFPGroup_ {Define a small cancellation group}} {-2 5}}  s {{Direct Product} {} {}} {{Semidirect Product} {} {}} {{Free Product} {} {}} {{Amalgamated Product} {} {-2 6}} {{Tree Product} {} {}} {{Graph Product} {} {}} }}}
<(16) menu_defn_ menu checkin signature {SMFPGroup} itemGroups {{1 {{{Word in the generators of $A($x1,name)} {_defineWord_ {Define a word in the generators of $A($x1,name)}} {-2 7}} {{Subgroup of $A($x1,name)} {_defineSubgroup_ {Define a subgroup of $A($x1,name)}} {-2 8}} {{Map from the generators of $A($x1,name) to $A($x1,name)} {_defineMap_ {Define a map from $A($x1,name) to $A($x1,name)}} {-2 9}} }} {{($A($x1,checkin_type)==1)} {{{Quadratic equation in $A($x1,name)} {_defineEquation_ {Define an equation in $A($x1,name)}} {-2 10}} {{Set of words in $A($x1,name)} {_defineSetOfWords_ {Define a set of words in $A($x1,name)}} {-2 11}} {{Tuple of words in $A($x1,name)} {_defineVectorOfWords_ {Define a tuple of words in $A($x1,name)}} {-2 12}} }}}
<(17) menu_defn_ menu checkin signature {SMFPGroup SMFPGroup} itemGroups {{1 {{{Map from the generators of $A($x1,name) to $A($x2,name)} {_defineMap_ {Define a map from $A($x1,name) to $A($x2,name)}} {-2 13}} {{Map from the generators of $A($x2,name) to $A($x1,name)} {_defineMap_ {Define a map from $A($x2,name) to $A($x1,name)}} {-2 14}} }}}
<(18) menu_defn_ menu tools signature {SMFPGroup} itemGroups {{{($A($x1,checkin_type)==5)} {{{Is $A($x1,name) trivial ?} {} {-2 15}} {{Is $A($x1,name) finite ?} {} {-2 16}} {{Is $A($x1,name) abelian ?} {} {-2 17}} }} {{($A($x1,checkin_type)==4)} {{{Is $A($x1,name) trivial ?} {} {-2 18}} {{Is $A($x1,name) finite ?} {} {-2 19}} {{Is $A($x1,name) abelian ?} {} {-2 20}} }} {{(($A($x1,checkin_type)==6)||($A($x1,checkin_type)==7))} {{{Is $A($x1,name) trivial ?} {} {-2 21}} {{Is $A($x1,name) finite ?} {} {-2 22}} {{Is $A($x1,name) abelian ?} {} {-2 23}} }} {{((($A($x1,checkin_type)==2)||($A($x1,checkin_type)==3))||($A($x1,checkin_type)==0))} {{{Is $A($x1,name) trivial ?} {} {-2 24}} }} {{((($A($x1,checkin_type)==2)||($A($x1,checkin_type)==0))||($A($x1,checkin_type)==3))} {{{Is $A($x1,name) finite ?} {} {-2 25}} }} {{($A($x1,checkin_type)==3)} {{{Is $A($x1,name) abelian ?} {} {-2 26}} }} {{($A($x1,checkin_type)==0)} {{{Is $A($x1,name) abelian ?} {} {-2 27}} {{Is $A($x1,name) nilpotent ?} {_defineInt_ {Enter the nilpotency class: } 1 {}} {-2 28}} }} {{(((($A($x1,checkin_type)==4)||($A($x1,checkin_type)==5))||($A($x1,checkin_type)==6))||($A($x1,checkin_type)==7))} {{{Is $A($x1,name) nilpotent ?} {} {}} }} {{((($A($x1,checkin_type)!=1)&&($A($x1,checkin_type)!=3))&&($A($x1,checkin_type)!=2))} {{{Is $A($x1,name) polycyclic ?} {} {}} {{Is $A($x1,name) metabelian ?} {} {}} }} {{(((($A($x1,checkin_type)==0)||($A($x1,checkin_type)==6))||($A($x1,checkin_type)==7))||($A($x1,checkin_type)==5))} {{{Is $A($x1,name) metric small cancellation ?} {} {-2 29}} }} {{($A($x1,checkin_type)==3)} {{{Is $A($x1,name) metric small cancellation ?} {} {}} }} {{((($A($x1,checkin_type)!=1)&&($A($x1,checkin_type)!=4))&&($A($x1,checkin_type)!=2))} {{{Is $A($x1,name) hyperbolic ?} {} {}} }} {{((($A($x1,checkin_type)!=1)&&($A($x1,checkin_type)!=5))&&($A($x1,checkin_type)!=2))} {{{Is $A($x1,name) a one-relator group ?} {} {}} }} {{($A($x1,checkin_type)==5)} {{{Is $A($x1,name) free ?} {} {-2 30}} }} {{(((($A($x1,checkin_type)==4)||($A($x1,checkin_type)==0)



)||($A($x1,checkin_type)==6))||($A($x1,checkin_type)==7))} {{{Is $A($x1,name) free ?} {} {}} }} {{($A($x1,checkin_type)==2)} {{{Is $A($x1,name) free abelian ?} {} {-2 31}} }} {{($A($x1,checkin_type)==3)} {{{Is $A($x1,name) free nilpotent ?} {} {-2 32}} }} {{($A($x1,checkin_type)!=1)} { s }} {{($A($x1,checkin_type)==2)} {{{Compute the order of $A($x1,name)} {} {-2 33}} }} {{($A($x1,checkin_type)==4)} {{{Compute the order of $A($x1,name)} {} {-2 34}} }} {{($A($x1,checkin_type)==5)} {{{Compute the order of $A($x1,name)} {} {-2 35}} {{Find HNN-presentation of $A($x1,name)} {} {-2 36}} }} {{(($A($x1,checkin_type)==6)||($A($x1,checkin_type)==7))} {{{Compute the order of $A($x1,name)} {} {-2 37}} }} {{($A($x1,checkin_type)==0)} {{{Compute the order of $A($x1,name)} {} {-2 38}} }} {{($A($x1,checkin_type)==3)} {{{Compute the order of $A($x1,name)} {} {-2 39}} }} {{(($A($x1,checkin_type)!=2)&&($A($x1,checkin_type)!=1))} {{{Compute the cyclic decomposition of $A($x1,name) abelianized} {} {-2 40}} }} {{($A($x1,checkin_type)==5)} {{{Compute the integral homology of $A($x1,name)} {} {-2 41}} }} {{(((($A($x1,checkin_type)==0)||($A($x1,checkin_type)==6))||($A($x1,checkin_type)==7))||($A($x1,checkin_type)==4))} {{{Compute an integral homology group of $A($x1,name)} {_defineInt_ {What dimension?} 2 {}} {-2 42}} }} {{($A($x1,checkin_type)==3)} {{{Compute the integral homology of $A($x1,name)} {} {}} }} {{($A($x1,checkin_type)==3)} {{{Compute the center of $A($x1,name)} {} {-2 43}} }} {{((($A($x1,checkin_type)!=1)&&($A($x1,checkin_type)!=2))&&($A($x1,checkin_type)!=3))} {{{Compute the center of $A($x1,name)} {} {}} }} {{((($A($x1,checkin_type)!=1)&&($A($x1,checkin_type)!=2))&&($A($x1,checkin_type)!=3))} {{{Find a finite rewriting system for $A($x1,name)} {} {-2 44}} }} {{(($A($x1,checkin_type)!=2)&&($A($x1,checkin_type)!=3))} {{{Find a ShortLex automatic structure for $A($x1,name)} {} {-2 45}} }} {{((($A($x1,checkin_type)==2)||($A($x1,checkin_type)==1))||($A($x1,checkin_type)==3))} { s }} {{($A($x1,checkin_type)==2)} {{{Compute the



 torsion-free rank of $A($x1,name)} {} {-2 46}} {{Compute the torsion subgroup of $A($x1,name)} {} {-2 47}} {{Compute the order of the torsion subgroup of $A($x1,name)} {} {-2 48}} {{Compute the cyclic decomposition of $A($x1,name)} {} {-2 49}} {{Compute the primary decomposition of $A($x1,name)} {} {-2 50}} }} {{($A($x1,checkin_type)==1)} {{{Find the n-th element of $A($x1,name)} {_defineInt_ {Ente<r the number n: } 0 {}} {-2 51}} {{Randomly enumerate automorphisms of $A($x1,name)} {_defineInt_ {Average number of Nielsen generators?} 1 {}} {-2 52}} {{Randomly enumerate automorphisms of $A($x1,name) of finite order} {_defineInt_ {Average number of Nielsen generators?} 1 {}} {-2 53}} }} {{($A($x1,checkin_type)==3)} {{{Compute the nilpotent structure of $A($x1,name)} {} {-2 54}} {{Compute a Malcev basis for the the relation subgroup of $A($x1,name)} {} {}} }}}
<(19) menu_defn_ menu tools signature {SMWord} itemGroups {{{(($A($A($x1,parent),checkin_type)!=3)&&($A($A($x1,parent),checkin_type)!=2))} {{{Freely reduce $A($x1,name)} {} {-2 55}} {{Cyclically reduce $A($x1,name)} {} {-2 56}} {{Compute the formal inverse of $A($x1,name)} {} {-2 57}} {{Find the i-th initial segment of $A($x1,name)} {_defineInt_ {Enter length of the initial segment: } 1 {}} {-2 58}} {{Find the i-th terminal segment of $A($x1,name)} {_defineInt_ {Enter length of the terminal segment: } 1 {}} {-2 59}} {{Find a subword of $A($x1,name)} {_defineInt_ {Enter the initial position: } 1 {}} {-2 60}} {{Find the n-th element of $A($A($x1,parent),name) (after the word $A($x1,name) in the lex order)} {_defineInt_ {Enter the number n: } 0 {}} {-2 61}}  s }} {{($A($A($x1,parent),checkin_type)==2)} {{{Reduce $A($x1,name) to its abelian form} {} {-2 62}} {{Find the inverse of $A($x1,name) , in abelian form} {} {-2 63}}  s }} {{($A($A($x1,parent),checkin_type)==1)} {{{Is $A($x1,name) trivial in $A($A($x1,parent),name) ?} {} {-2 64}} }} {{(($A($A($x1,parent),checkin_type)==6)||($A($A($x1,parent),checkin_type)==7))} {{{Is $A($x1,name) trivial in $A($A($x1,parent),name) ?} {} {-2 65}} }} {{((($A($A($x1,parent),checkin_type)!=1)&&($A($A($x1,parent),checkin_type)!=6))&&($A($A($x1,parent),checkin_type)!=7))} {{{Is $A($x1,name) trivial in $A($A($x1,parent),name) ?} {} {-2 66}} }} {{($A($A($x1,parent),checkin_type)==2)} {{{Compute the order of  $A($x1,name)} {} {-2 67}} {{Compute the p-height of  $A($x1,name)} {_defineInt_ {Enter the p  } 1 {}} {-2 68}} {{Compute the maximal root of  $A($x1,name)} {} {-2 69}} {{Is  $A($x1,name)  a proper power ?} {} {-2 70}} {{Is the subgroup generated by $A($x1,name) pure ?} {} {-2 71}} }} {{($A($A($x1,parent),checkin_type)==3)} {{{Is $A($x1,name) of finite order in $A($A($x1,parent),name) ?} {} {-2 72}} }} {{(((($A($A($x1,parent),checkin_type)!=2)&&($A($A($x1,parent),checkin_type)!=1))&&($A($A($x1,parent),checkin_type)!=3))&&($A($A($x1,parent),checkin_type)!=0))} {{{Is $A($x1,name) of 



finite order in $A($A($x1,parent),name) ?} {} {}} }} {{($A($A($x1,parent),checkin_type)==0)} {{{Is $A($x1,name) of finite order in $A($A($x1,parent),name) ?} {} {-2 73}} }} {{((($A($A($x1,parent),checkin_type)!=2)&&($A($A($x1,parent),checkin_type)!=1))&&($A($A($x1,parent),checkin_type)!=7))} {{{Is $A($x1,name) a proper power in $A($A($x1,parent),name) ?} {} {}} }} {{($A($A($x1,parent),checkin_type)==7)} {{{Is $A($x1,name) a proper power in $A($A($x1,parent),name) ?} {} {-2 74}} }} {{($A($A($x1,parent),checkin_type)==1)} {{{Is $A($x1,name) a proper power in $A($A($x1,parent),name) ?} {} {-2 75}} {{Compute the maximal root of $A($x1,name) in $A($A($x1,parent),name)} {} {-2 76}} }} {{(((($A($A($x1,parent),checkin_type)!=2)&&($A($A($x1,parent),checkin_type)!=1))&&($A($A($x1,parent),checkin_type)!=3))&&($A($A($x1,parent),checkin_type)!=0))} {{{Is $A($x1,name) central in $A($A($x1,parent),name) ?} {} {}} }} {{($A($A($x1,parent),checkin_type)==0)} {{{Is $A($x1,name) central in $A($A($x1,parent),name) ?} {} {-2 77}} }} {1 { s }} {{($A($A($x1,parent),checkin_type)==2)} {{{Compute the canonical decomposition of $A($x1,name)} {} {-2 78}} {{Compute the primary decomposition of  $A($x1,name)} {} {-2 79}} }} {{($A($A($x1,parent),checkin_type)==3)} {{{Compute the centralizers of $A($x1,name) in $A($A($x1,parent),name)} {} {-2 80}} }} {{((($A($A($x1,parent),checkin_type)!=2)&&($A($A($x1,parent),checkin_type)!=3))&&($A($A($x1,parent),checkin_type)!=7))} {{{Compute the centralizer of $A($x1,name) in $A($A($x1,parent),name)} {} {}} }} {{($A($A($x1,parent),checkin_type)==7)} {{{Compute the centralizer of $A($x1,name) in $A($A($x1,parent),name)} {} {-2 81}} }} {{($A($A($x1,parent),checkin_type)==1)} {{{Is $A($x1,name) a commutator in $A($A($x1,parent),name) ?} {} {-2 82}} {{Is $A($x1,name) in the commutator subgroup of $A($A($x1,parent),name) ?} {} {-2 83}} {{Is $A($x1,name) part of a basis of $A($A($x1,parent),name) ?} {} {-2 84}} }} {{(($A($A($x1,parent),checkin_type)==6)||($A($A($x1,parent),checkin_type)==7))} {{{Compute the redu



ced form of $A($x1,name)} {} {-2 85}} {{Compute the normal form of $A($x1,name)} {} {-2 86}} {{Compute the cyclic normal form of $A($x1,name)} {} {-2 87}} }} {{($A($A($x1,parent),checkin_type)==7)} {{{Compute the maximal root of $A($x1,name) in $A($A($x1,parent),name)} {} {-2 88}} }}}
<(20) menu_defn_ menu tools signature {SMSubgroup} itemGroups {{{($A($A($x1,parent),checkin_type)==1)} {{{Is $A($x1,name) trivial ?} {} {-2 89}} }} {{((($A($A($x1,parent),checkin_type)==2)||($A($A($x1,parent),checkin_type)==0))||($A($A($x1,parent),checkin_type)==4))} {{{Is $A($x1,name) trivial ?} {} {-2 90}} }} {{(($A($A($x1,parent),checkin_type)==0)||($A($A($x1,parent),checkin_type)==4))} {{{Is $A($x1,name) finite ?} {} {}} {{Is $A($x1,name) abelian ?} {} {-2 91}} }} {{(($A($A($x1,parent),checkin_type)==6)||($A($A($x1,parent),checkin_type)==7))} {{{Is $A($x1,name) abelian ?} {} {-2 92}} }} {{($A($A($x1,parent),checkin_type)==0)} {{{Is $A($x1,name) nilpotent ?} {_defineInt_ {Enter the nilpotency class: } 1 {}} {-2 93}} {{Is $A($x1,name) central ?} {} {-2 94}} }} {{($A($A($x1,parent),checkin_type)==2)} {{{Is $A($x1,name) isolated in $A($A($x1,parent),name) ?} {} {-2 95}} {{Compute  the order of  $A($x1,name)} {} {-2 96}} {{Compute the torsion-free rank of $A($x1,name)} {} {-2 97}} {{Compute the order of the torsion subgroup of $A($x1,name)} {} {-2 98}}  s {{Compute the cyclic decomposition for $A($x1,name)} {} {-2 99}} {{Compute the primary decomposition for  $A($x1,name)} {} {-2 100}}  s {{Is $A($x1,name) = $A($A($x1,parent),name) ?} {} {-2 101}} {{Compute the index of $A($x1,name) in $A($A($x1,parent),name)} {} {-2 102}} {{Compute the isolator of  $A($x1,name)} {} {-2 103}} {{Compute a virtual free complement of  $A($x1,name)} {} {-2 104}} {{Is $A($x1,name) pure in $A($A($x1,parent),name) ?} {} {-2 105}} }} {{($A($A($x1,parent),checkin_type)==3)} {{{Is $A($x1,name) trivial ?} {} {-2 106}} {{Is $A($x1,name) finite ?} {} {-2 107}} {{Is $A($x1,name) abelian ?} {} {-2 108}} {{Is $A($x1,name) central ?} {} {}} }} {{(($A($A($x1,parent),checkin_type)==6)||($A($A($x1,parent),checkin_type)==7))} {{{Is $A($x1,name) trivial ?} {} {-2 109}} }} {{($A($A($x1,parent),checkin_type)==1)} {{{Is $A($x1,name) normal in $A($A($x1,parent),name) ?} {} {-2 110}} {{What is the index of $A($x1,name) in $A($A($x1,parent),name) ?} {} {-2 



111}}  s {{Compute a Nielsen basis for $A($x1,name)} {} {-2 112}} {{Compute the normaliser of $A($x1,name) in $A($A($x1,parent),name) ?} {} {-2 113}} {{Compute a finite index subgroup of $A($A($x1,parent),name) with $A($x1,name) as a free factor} {} {-2 114}} }} {{((((($A($A($x1,parent),checkin_type)==0)||($A($A($x1,parent),checkin_type)==6))||($A($A($x1,parent),checkin_type)==7))||($A($A($x1,parent),checkin_type)==5))||($A($A($x1,parent),checkin_type)==4))} {{{Enumerate relators for $A($x1,name)} {} {-2 115}} }}}
<(21) menu_defn_ menu tools signature {SMSetOfWords} itemGroups {{{($A($A($x1,parent),checkin_type)==1)} {{{Is $A($x1,name) part of a basis of $A($A($x1,parent),name) ?} {} {-2 116}} }}}
<(22) menu_defn_ menu tools signature {SMVectorOfWords} itemGroups {{{($A($A($x1,parent),checkin_type)==1)} {{{Find Whitehead reduction of $A($x1,name)} {} {-2 117}} }}}
<(23) menu_defn_ menu tools signature {SMMap} itemGroups {{1 {{{Does $A($x1,name) extend to homomorphism ?} {} {-2 118}} }}}
<(24) menu_defn_ menu tools signature {SMHomomorphism} itemGroups {{1 {}} {{($A($A($x1,domain),checkin_type)!=2)} {{{Is $A($x1,name) a monomorphism ?} {} {}} {{Is $A($x1,name) an epimorphism ?} {} {}} }} {{($A($A($x1,domain),checkin_type)==2)} {{{Is $A($x1,name) a monomorphism ?} {} {-2 119}} {{Is $A($x1,name) an epimorphism ?} {} {-2 120}} {{Is $A($x1,name) an automorphism ?} {} {-2 121}} }} {{($A($A($x1,domain),checkin_type)==1)} {{{Is $A($x1,name) an automorphism ?} {} {-2 122}} }} {{(($A($A($x1,domain),checkin_type)!=1)&&($A($A($x1,domain),checkin_type)!=2))} {{{Is $A($x1,name) an automorphism ?} {} {}} }} {{($A($x1,auto)&&($A($A($x1,domain),checkin_type)==1))} {{{Is $A($x1,name) an IA-automorphism ?} {} {-2 123}} {{Is $A($x1,name) an inner automorphism ?} {} {-2 124}} {{Compute the inverse of $A($x1,name)} {} {-2 125}} }} {{(!$A($x1,auto)||($A($A($x1,domain),checkin_type)!=1))} {{{Is $A($x1,name) an IA-automorphism ?} {} {}} {{Is $A($x1,name) an inner automorphism ?} {} {}}  s {{Extend $A($A($x1,domain),name) by $A($x1,name)} {} {-2 126}} }}}
<(25) menu_defn_ menu tools signature {SMHomomorphism2} itemGroups {{1 {}} {{($A($A($x1,domain),checkin_type)!=2)} {{{Is $A($x1,name) a monomorphism ?} {} {}} {{Is $A($x1,name) an epimorphism ?} {} {}} {{Is $A($x1,name) an isomorphism ?} {} {}} }} {{($A($A($x1,domain),checkin_type)==2)} {{{Is $A($x1,name) a monomorphism ?} {} {-2 127}} {{Is $A($x1,name) an epimorphism ?} {} {-2 128}} {{Is $A($x1,name) an isomorphism ?} {} {-2 129}} }} {{($A($x1,auto)&&($A($A($x1,domain),checkin_type)==1))} {{{Compute the inverse of $A($x1,name)} {} {-2 130}}  s {{Extend $A($A($x1,domain),name) by $A($x1,name)} {} {-2 131}} }}}
<(26) menu_defn_ menu tools signature {SMEquation} itemGroups {{1 {{{Find a surface form of $A($x1,name)} {} {-2 132}} {{Solve the equation $A($x1,name)  = 1} {} {-2 133}} }}}
<(27) menu_defn_ menu tools signature {SMWord SMWord} itemGroups {{{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==2))} {{{Compute the product $A($x1,name) $A($x2,name) , in abelian form} {} {-2 134}} {{Compute the product $A($x2,name) $A($x1,name) , in abelian form} {} {-2 135}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)!=2))} {{{Compute the formal product $A($x1,name)  *  $A($x2,name)} {} {-2 136}} {{Compute the formal product $A($x2,name)  *  $A($x1,name)} {} {-2 137}} }} {1 { s }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==2))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {-2 138}} {{Is $A($x1,name) a power of $A($x2,name) ?} {} {-2 139}} {{Is $A($x2,name) a power of $A($x1,name) ?} {} {-2 140}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==1))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {-2 141}} }} {{(($A($x1,parent)==$A($x2,parent))&&(($A($A($x1,parent),checkin_type)==6)||($A($A($x1,parent),checkin_type)==7)))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {-2 142}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==0))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {-2 143}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==3))} {{{Are $A($x1,name) and $A($x2,name) conjugate in $A($A($x1,parent),name) ?} {} {}} }} {{(((($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)!=2))&&($A($A($x1,parent),checkin_type)!=3))&&($A($A($x1,parent),checkin_type)!=7))} {{{Are $A($x1,name) and $A($x2,name) conjugate in $A($A($x1,parent),name) ?} {} {-2 144}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==7))} {{{Are $A($x1,name) and $A($x2,name) conjugate in $A($A($x1,parent),name) ?} {} {-2 145}} {{Is $A($x1,name) a proper power of $A($x2,name) ?} {} {-2 146}} {{Is $A($x2,name) a proper power of $A($x1,name) ?} {} {-2 147}} }} {{(((($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)!=1))&&($A($A($x1,parent),checkin_type)!=7))&&($A($



A($x1,parent),checkin_type)!=2))} {{{Is $A($x1,name) a proper power of $A($x2,name) ?} {} {}} {{Is $A($x2,name) a proper power of $A($x1,name) ?} {} {}} }}}
<(28) menu_defn_ menu tools signature {SMHomomorphism SMHomomorphism} itemGroups {{{($A($x1,range)==$A($x2,domain))} {{{Form the composition $A($x2,name) $A($x1,name)} {} {-2 148}} }} {{($A($x2,range)==$A($x1,domain))} {{{Form the composition $A($x1,name) $A($x2,name)} {} {-2 149}} }} {{(($A($x1,domain)==$A($x2,domain))&&($A($A($x1,domain),checkin_type)!=1))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {}} }} {{(($A($x1,domain)==$A($x2,domain))&&($A($A($x1,domain),checkin_type)==1))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {-2 150}} }}}
<(29) menu_defn_ menu tools signature {SMHomomorphism2 SMHomomorphism2} itemGroups {{{($A($x1,range)==$A($x2,domain))} {{{Form the composition $A($x2,name) $A($x1,name)} {} {-2 151}} }} {{($A($x2,range)==$A($x1,domain))} {{{Form the composition $A($x1,name) $A($x2,name)} {} {-2 152}} }} {{((($A($x1,domain)==$A($x2,domain))&&($A($x1,range)==$A($x2,range)))&&($A($A($x1,domain),checkin_type)!=1))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {}} }} {{((($A($x1,domain)==$A($x2,domain))&&($A($x1,range)==$A($x2,range)))&&($A($A($x1,domain),checkin_type)==1))} {{{Is $A($x1,name) = $A($x2,name) ?} {} {-2 153}} }}}
<(30) menu_defn_ menu tools signature {SMHomomorphism SMHomomorphism2} itemGroups {{{($A($x1,range)==$A($x2,domain))} {{{Form the composition $A($x2,name) $A($x1,name)} {} {-2 154}} }} {{($A($x2,range)==$A($x1,domain))} {{{Form the composition $A($x1,name) $A($x2,name)} {} {-2 155}} }}}
<(31) menu_defn_ menu tools signature {SMHomomorphism SMWord} itemGroups {{{($A($x2,parent)==$A($x1,domain))} {{{Compute the image of $A($x2,name) under $A($x1,name)} {} {-2 156}} }}}
<(32) menu_defn_ menu tools signature {SMHomomorphism2 SMWord} itemGroups {{{($A($x2,parent)==$A($x1,domain))} {{{Compute the image of $A($x2,name) under $A($x1,name)} {} {-2 157}} }}}
<(33) menu_defn_ menu tools signature {SMHomomorphism SMSubgroup} itemGroups {{{($A($x2,parent)==$A($x1,domain))} {{{Compute the image of $A($x2,name) under $A($x1,name)} {} {-2 158}} }}}
<(34) menu_defn_ menu tools signature {SMHomomorphism2 SMSubgroup} itemGroups {{{($A($x2,parent)==$A($x1,domain))} {{{Compute the image of $A($x2,name) under $A($x1,name)} {} {-2 159}} }}}
<(35) menu_defn_ menu tools signature {SMSubgroup SMWord} itemGroups {{{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==2))} {{{Is $A($x2,name) in $A($x1,name) ?} {} {-2 160}} {{Compute power of $A($x2,name) in $A($x1,name)} {} {-2 161}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==3))} {{{Is $A($x2,name) in $A($x1,name) ?} {} {}} {{Is a power of $A($x2,name) in $A($x1,name) ?} {} {}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==1))} {{{Does $A($x2,name) represent an element of $A($x1,name) ?} {} {-2 162}} {{Does a power of $A($x2,name) represent an element of $A($x1,name) ?} {} {-2 163}} {{Does a conjugate of $A($x2,name) represent an element of $A($x1,name) ?} {} {-2 164}}  s {{Compute the right Schreier representative of $A($x2,name) mod $A($x1,name)} {} {-2 165}} }}}
<(36) menu_defn_ menu tools signature {SMSubgroup SMSubgroup} itemGroups {{{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==2))} {{{Does $A($x1,name) contain $A($x2,name) ?} {} {-2 166}} {{Does $A($x2,name) contain $A($x1,name) ?} {} {-2 167}} {{Is  $A($x1,name)  isomorphic to  $A($x2,name) ?} {} {-2 168}} {{Is $A($x1,name) = $A($x2,name) ?} {} {-2 169}}  s {{Compute the join of $A($x1,name) and $A($x2,name)} {} {-2 170}} {{Compute the intersection of $A($x1,name) and $A($x2,name)} {} {}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==3))} {{{Does $A($x1,name) contain $A($x2,name) ?} {} {}} {{Does $A($x2,name) contain $A($x1,name) ?} {} {}} {{Is $A($x1,name) = $A($x2,name) ?} {} {}} }} {{(($A($x1,parent)==$A($x2,parent))&&($A($A($x1,parent),checkin_type)==1))} {{{Does $A($x1,name) contain $A($x2,name) ?} {} {-2 171}} {{Does $A($x2,name) contain $A($x1,name) ?} {} {-2 172}} {{Is $A($x1,name) = $A($x2,name) ?} {} {-2 173}} {{Does $A($x1,name) contain a conjugate of $A($x2,name) ?} {} {-2 174}} {{Does $A($x2,name) contain a conjugate of $A($x1,name) ?} {} {-2 175}} {{Are $A($x1,name) and $A($x2,name) conjugate ?} {} {-2 176}}  s {{Compute the join of $A($x1,name) and $A($x2,name)} {} {-2 177}} {{Compute the intersection of $A($x1,name) and $A($x2,name)} {} {-2 178}} }}}
<(37) menu_defn_ menu tools signature {SMFPGroup SMFPGroup} itemGroups {{{(($A($x1,checkin_type)==2)&&($A($x2,checkin_type)==2))} {{{Are $A($x1,name) and $A($x2,name) isomorphic ?} {} {-2 179}} }}}
<(38) menu_defn_ menu make signature {SMFPGroup} itemGroups {{{($A($x1,checkin_type)==2)} {{{Cyclic Decomposition of $A($x1,name)} {} {-2 180}} }} {1 {{{Quotient of $A($x1,name)} {_defineSetOfRelators_ {Define a set of words}} {-2 181}} }} {{($A($x1,checkin_type)!=2)} {{{Abelian Quotient of $A($x1,name)} {} {-2 182}} }} {{(($A($x1,checkin_type)!=2)&&($A($x1,checkin_type)!=3))} {{{Nilpotent Quotient of $A($x1,name)} {_defineInt_ {Enter the nilpotency class: } 1 {}} {-2 183}} }} {1 { s {{Another Presentation of $A($x1,name)} {} {}} }}}
<(39) menu_defn_ menu make signature {SMFPGroup SMFPGroup SMSubgroup SMSubgroup} itemGroups {{{((((($A($x1,checkin_type)==1)&&($A($x2,checkin_type)==1))&&(($A($x3,parent)==$A($x1,oid))||($A($x3,parent)==$A($x2,oid))))&&(($A($x4,parent)==$A($x1,oid))||($A($x4,parent)==$A($x2,oid))))&&($A($x3,parent)!=$A($x4,parent)))} {{{Amalgamated Product} {} {-2 184}} }}}
<(40) boot_done_
>(41) -2 4 G1 < x,y,z,t ; x^3 y^2 x^3 [z,y][z,t] >
<(42) create_ objectID 0 typeID SMFPGroup iconID group name {G1} dependencies {} properties {{ key {$A(0,checkin_type)} datum {5}} { key {$A(0,oid)} datum {0}} } viewStructure {viewBuilder objectView viewParameters {viewID 0 heritage {User defined one relator group}}}
<(43) post_to_log_ {0 } {$A(0,name) is a one-relator group and so it has a solvable word problem.} 1
>(44) -2 30 0
<(45) create_ objectID 2 typeID ComputationManager iconID problem name {} dependencies { 0} properties {} viewStructure {viewBuilder problemView viewParameters {viewID 2 viewAbbreviation {$A(0,name) free ?} viewTitle {Freeness problem} viewBanner {Is  $A(0,name)  free ?} totalARCs {ARCSlotID -1 value 0} helpID ORIsFreeProblem::ONE_RELATOR subproblems {{1 {{ARCSlotID 0 name {For the use of this problem} state 1 value 50 helpID foo } }}}}} definition {}
>(46) 2 1 0 50
>(47) 2 2
<(48) confirm_start_ viewID 2
<(49) arc_update_ viewID 2 ARCSlotID 0 value 1
<(50) arc_update_ viewID 2 ARCSlotID 0 value 1
<(51) arc_update_ viewID 2 ARCSlotID 0 value 1
<(52) arc_update_ viewID 2 ARCSlotID 0 value 1
<(53) arc_update_ viewID 2 ARCSlotID 0 value 1
<(54) arc_update_ viewID 2 ARCSlotID 0 value 1
<(55) post_to_log_ {2 0 } {$A(0,name) is not free.} 1
<(56) terminate_problem_ viewID 2
>(57) -2 29 0
<(58) post_to_log_ {0 } {The presentation of $A(0,name) is not metric small cancellation; it is only C'(1/5).} 1
>(59) -2 41 0
<(60) post_to_log_ {0 } {The integral homology groups of $A(0,name) are: H_2( $A(0,name) ) = 0, H_n( $A(0,name) ) = 0 for n > 2, .} 1
>(61) -2 36 0
<(62)  defineMagnusBreakdown  title {Define a generator(s)}  descr { To find HNN-presentation of one-relator group you can specify a stable letter (and an accompanying second letter if it needed, using comma as separator).}  zero { z, t } nonzero { x, y } default { z } message { 3 0 } 
>(63)  3 0  { t }
<(64) create_ objectID 3 typeID SMFPGroup iconID group name {} dependencies {} properties {{ key {$A(3,checkin_type)} datum {0}} { key {$A(3,oid)} datum {3}} } viewStructure {viewBuilder objectView viewParameters {viewID 3 heritage {User defined HNN presentation of group $A(0,name) with the stable letter t}}} definition {< x_0, y_0, z_-1, z_0, t ; x_0^3 y_0^2 x_0^3 z_0^-1 y_0^-1 z_0 y_0 z_0^-1 z_-1,t z_-1 t^-1 z_0^-1 >}
<(65) create_ objectID 6 typeID SMHomomorphism2 iconID homomorphism name {} dependencies { 0 3} properties {{ key {$A(6,domain)} datum {0}} { key {$A(6,range)} datum {3}} } viewStructure {viewBuilder objectView viewParameters {viewID 6 heritage {The isomorphism from the group  $A(0,name)  into its HNN-presentation  $A(3,name)}}} definition {x -> x_0, y -> y_0, z -> z_0, t -> t}
<(66) create_ objectID 8 typeID SMHomomorphism2 iconID homomorphism name {} dependencies { 0 3} properties {{ key {$A(8,domain)} datum {3}} { key {$A(8,range)} datum {0}} } viewStructure {viewBuilder objectView viewParameters {viewID 8 heritage {The isomporphism from the HNN-presentation  $A(3,name) to the group  $A(0,name)}}} definition {x_0 -> x, y_0 -> y, z_-1 -> t^-1 z t, z_0 -> z, t -> t}
<(67) create_ objectID 10 typeID SMFPGroup iconID group name {} dependencies {} properties {{ key {$A(10,checkin_type)} datum {5}} { key {$A(10,oid)} datum {10}} } viewStructure {viewBuilder objectView viewParameters {viewID 10 heritage {The basis group of HNN presentation $A(3,name) of group $A(0,name) with stable letter t}}} definition {< x_0, y_0, z_-1, z_0 ; x_0^3 y_0^2 x_0^3 z_0^-1 y_0^-1 z_0 y_0 z_0^-1 z_-1 >}
<(68) create_ objectID 12 typeID SMHomomorphism2 iconID homomorphism name {} dependencies { 3 10} properties {{ key {$A(12,domain)} datum {3}} { key {$A(12,range)} datum {10}} } viewStructure {viewBuilder objectView viewParameters {viewID 12 heritage {The restricting map of the group  $A(3,name)  onto the group  $A(10,name)}}} definition {x_0 -> x_0, y_0 -> y_0, z_-1 -> z_-1, z_0 -> z_0, t -> 1}
<(69) create_ objectID 14 typeID SMHomomorphism2 iconID homomorphism name {} dependencies { 3 10} properties {{ key {$A(14,domain)} datum {10}} { key {$A(14,range)} datum {3}} } viewStructure {viewBuilder objectView viewParameters {viewID 14 heritage {The embedding map of the group  $A(10,name)  into the group  $A(3,name)}}} definition {x_0 -> x_0, y_0 -> y_0, z_-1 -> z_-1, z_0 -> z_0}
<(70) post_to_log_ {10 } {$A(10,name) is a one-relator group and so it has a solvable word problem.} 1
>(71) -1 1 1 2
<(72) confirm_delete_ 2
>(73) -2 7 0 w1 [x,y] (x z t)^3
<(74) create_ objectID 2 typeID SMWord iconID elt name {w1} dependencies { 0} properties {{ key {$A(2,parent)} datum {0}} } viewStructure {viewBuilder objectView viewParameters {viewID 2 heritage {User defined word in the generators of $A(0,name)}}}
>(75) -2 157 6 2
<(76) create_ objectID 17 typeID SMWord iconID elt name {} dependencies { 3} properties {{ key {$A(17,parent)} datum {3}} } viewStructure {viewBuilder objectView viewParameters {viewID 17 heritage {The image of $A(2,name) under $A(6,name)}}} definition {x_0^-1 y_0^-1 x_0 y_0 x_0 z_0 t x_0 z_0 t x_0 z_0 t}
>(77) -2 36 10
<(78)  defineMagnusBreakdown  title {Define a generator(s)}  descr { To find HNN-presentation of one-relator group you can specify a stable letter (and an accompanying second letter if it needed, using comma as separator).}  zero {  } nonzero { x_0, y_0, z_-1, z_0 } default { x_0, y_0 } message { 4 0 } 
>(79)  4 0  { x_0 }
<(80) fatal_error_ {Internal error in ORFindHNNPresentation::takeControl()}
