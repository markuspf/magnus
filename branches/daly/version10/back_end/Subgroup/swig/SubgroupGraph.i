%module Magnus

%{
#include "SubgroupGraph.h"

%}

class SubgroupGraph {
  
public:

  typedef SubgroupGraphRep::VertexType VertexType;

  typedef SubgroupGraphRep::LabelType LabelType;

  SubgroupGraph(int ambientRank, const SetOf<Word>& S) ;
  // Construct a subgroup graph from the rank of the ambient free group,
  // and the subgroup generators.

  %name(SubgroupGraphFromVector) SubgroupGraph(int ambientRank, const VectorOf<Word>& V);
  // Construct a subgroup graph from the rank of the ambient free group,
  // and the subgroup generators.

  // Copy constructor, operator=, and destructor supplied by compiler.

  int rank( ) const ;
  // Returns the rank of this subgroup as a free group.

  VectorOf<Word> normalizer( ) ;

  VectorOf<Word> nielsenBasis( ) const;
  // Returns a Nielsen basis for this subgroup as a free group.

  Word nielsenWord(int i) const ;
  // Returns an  i^th element of the Nielsen basis.

  Word inNielsenWords(const Word& w) const ;
  // Returns the word `w' written in elements of the Nielsen basis.

  SubgroupGraph join(const SubgroupGraph& SG) const;
  // Returns a SubgroupGraph which represents the join of this
  // subgroup and the argument (i.e. the subgroup generated by the
  // union of generating sets for the two subgroups).

  SubgroupGraph intersection(const SubgroupGraph& SG) const ;
  // Returns a SubgroupGraph which represents the intersection of
  // this subgroup and the argument.

  Bool contains(const Word& w) const ;
  // Returns TRUE iff this subgroup contains `w'.

  %name(containsFromSet) Bool contains(const SetOf<Word>& S) const ;
  // Returns TRUE iff this subgroup contains the subgroup generated by `S'.

  %name(containsFromVector)  Bool contains(const VectorOf<Word>& V) const ;
  // Returns TRUE iff this subgroup contains the subgroup generated by `V'.

  %name(containsFromSubgroupGraph)  Bool contains(SubgroupGraph& SG) const ;

  Bool equalTo(const SetOf<Word>& S) ;
  // Returns TRUE iff this subgroup and the subgroup generated by `S' are equal.

  %name(equalToFromSubgroupGraph) Bool equalTo(SubgroupGraph& SG) ;
  // Returns TRUE iff this subgroup and the argument are equal.

  Bool conjugateInSubgroup(const Word& w, Word& conjugator) const ;
  // Returns TRUE iff some conjugate of `w' is in the subgroup.
  // If TRUE, `conjugator' is set to the conjugator.

  %name(conjugateInSubgroupFromSet) Bool conjugateInSubgroup(const SetOf<Word>& S, Word& conjugator) ;
  // Returns TRUE iff some conjugate of the subgroup generated by `S' is
  // in the subgroup. If TRUE, `conjugator' is set to the conjugator.

  bool conjugateTo(const SetOf<Word>& S) ;
  // Returns true iff this subgroup and the argument are conjugate.

  long powerInSubgroup( const Word& w ) const ;
  // returns `the minimal power' or 0 if there are no powers of the
  // element `aWord' in H.

  int findIndex();
  // Returns the index of the subgroup or 0 if infinite.

  VectorOf<Word> findWhiteheadBasis() ;
  // Finds the subgroup of the free group authomorphic to this with
  // smallest sum of lengths of generators.
  // Returns a vector of generators.

  Bool isAFreeFactor() ;
  // Returns TRUE iff this subgroup is a free factor.

  Bool generatesTheFreeGroup() const ;

  Word rightSchreierRepresentative(const Word& w) ;

  SubgroupGraph MHallCompletion( ) const ;
  // Returns a SubgroupGraph which represents a subgroup of the
  // ambient free group of finite index, containing this one.
  // This one is a free factor of the result.

  void MHallComplete( ) ;
  // An `in place' version of above.

  void joinConjugate(Generator g) ;
  // Alters this SubgroupGraph in place so that it also contains the
  // conjugate by `g' of every element it contained before.

  float completeness( ) const ;
  // Returns ratio of existing edges to number of edges in complete graph.

  Bool isComplete( ) const;
  // Returns TRUE iff this graph is complete (can't trust floats!).

  VertexType vertexCount( ) const ;

  #ifdef DEBUG
    void debugPrint(ostream& ostr) const;
    Bool consistentData( ) const ;
  #endif


  VertexType targetOfGenerator(VertexType source, int generator) const ;


  VertexType targetOfLabel(VertexType source, LabelType label) const ;


  long getValence( ) const ;


  LabelType inverseLabel(LabelType label) const ;

  int labelToGenerator(LabelType label) const ;

  LabelType generatorToLabel(int g) const ;

/*
  /////////////////////////////////////////////////////////////////////////
  //                                                                     //
  // IPC tools:                                                          //
  //                                                                     //
  /////////////////////////////////////////////////////////////////////////

  friend ostream& operator < ( ostream& ostr, const SubgroupGraph& g )
  {
    g.look()->write(ostr);
    return ostr;
  }
  
  friend istream& operator > ( istream& istr, SubgroupGraph& g )
  {
    g.change()->read(istr);
    return istr;
  }
*/
  bool readPiece( istream& istr, const class Timer& timer ) ;
  // To read a big amount of information piece by piece. Returns true
  // if the last is read, false otherwise.
/*

//@dbprivate:
protected:

  SubgroupGraph(SubgroupGraphRep* SGRp) : ObjectOf<SubgroupGraphRep>(SGRp) { }
*/
};
