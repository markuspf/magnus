%module Magnus

%{
#include "SGofFreeGroup.h"

%}



class SGofFreeGroup {

public:

  ///////////////////////////////////////////////////////
  //                                                   //
  //  Constructors                                     //
  //                                                   //
  ///////////////////////////////////////////////////////

  SGofFreeGroup( const FreeGroup& parent, const VectorOf<Word>& gens );
  // to make a finitely generated SGofFreeGroup with a vector of unnamed
  // generators


  ///////////////////////////////////////////////////////
  //                                                   //
  //  Accessors                                        //
  //                                                   //
  ///////////////////////////////////////////////////////


  const FreeGroup& parentGroup( ) const;

  const VectorOf<Word>& generators( ) const;

  Type type( );

  Type actualType( ) const ;

  ///////////////////////////////////////////////////////
  //                                                   //
  //  Group structure methods                          //
  //                                                   //
  ///////////////////////////////////////////////////////
 
  int order( ) ;
  Bool isTrivial( ) ;
  Bool isFinite( ) ;
  Bool isInfinite( );
  Bool isAbelian( ) ;

  bool isMalnormal( Word& conjugator ) ;
  // A subgroup is malnormal iff the intersection of the subgroup and
  // conjugation of the one by any element from the difference 
  // of the parent group and the subgroup is not trivial.
  // The function returns `false' and a word to conjugate the 
  // if the subgroup is not malnormal. If the subgroup is malnormal
  // then it returns only `true' and the parameter `conjugator' is meanless.

  SGofFreeGroup join(SGofFreeGroup& SG) ;
  // Returns the join of this subgroup and the argument.

  SGofFreeGroup intersection(SGofFreeGroup& SG) ;
  // Returns the intersection of this subgroup and the argument.

  Bool isNormal( ) ;

  VectorOf<Word> normalizer( ) ;

  VectorOf<Word> nielsenBasis( ) ;
  // Returns a Nielsen basis for this subgroup.

  Word nielsenWord(int i) ;
  // Returns an  i^th element of the Nielsen basis.

  Word inNielsenWords(const Word& w) ;
  // Returns the word `w' written in elements of the Nielsen basis.

  int rank() ;
  // Returns the rank of this subgroup as a free group

  SGofFreeGroup MHallCompletion( ) ;


  ///////////////////////////////////////////////////////
  //                                                   //
  //  Methods which deal with subgroup elements        //
  //                                                   //
  ///////////////////////////////////////////////////////

  // Trichotomy areEqual(const Elt& e1, const Elt& e2) const; 
  // Elt firstElt( ) const;                                   
  // Elt nextElt(const Elt& e) const;                         
  // Elt multiply(const Elt& e1, const Elt& e2) const;        
  // Elt inverseOf(const Elt& e) const;                       
  // Elt raiseToPower(const Elt& e, int n) const;             
  // Elt conjugateBy(const Elt& e1, const Elt& e2) const;     
  // Elt commutator(const Elt& e1, const Elt& e2) const;      

  Elt eval( const Word& w ) const;
  // `w' is in the subgroup's generators. Returns the word `w' written
  // in the free group's generators.

  Bool wordProblem( const Word& w ) const ;
  // `w' is a word in the subgroup's generators. Returns TRUE iff
  // `w' is trivial in the free group.

  Bool conjugacyProblem( const Word& u, const Word& v ) const ;

  Bool contains(const Word& w) ;
  // Returns TRUE iff this subgroup contains `w'.

  %name(containsFromSet) Bool contains(const SetOf<Word>& S) ;
  // Returns TRUE iff this subgroup contains the subgroup generated by `S'.

  %name(containsFromVector)  Bool contains(const VectorOf<Word>& V);
  // Returns TRUE iff this subgroup contains the subgroup generated by `V'.

  %name(containsFromSGofFreeGroup)  Bool contains(const SGofFreeGroup& SG) ;
  // Returns TRUE iff this subgroup contains `SG'.

  Bool equalTo(const SetOf<Word>& S) ;
  // Returns TRUE iff this subgroup and the subgroup generated by `S' are equal.

  Bool conjugateInSubgroup(const Word& w, Word& conjugator);
  // Returns TRUE iff some conjugate of `w' is in the subgroup.
  // If TRUE, `conjugator' is set to the conjugator.

  %name(conjugateInSubgroupFromSet) Bool conjugateInSubgroup(const SetOf<Word>& S, Word& conjugator) ;
  // Returns TRUE iff some conjugate of the subgroup generated by `S' is
  // in the subgroup. If TRUE, `conjugator' is set to the conjugator.

  bool conjugateTo(const SetOf<Word>& S);
  // Returns true iff this subgroup and the argument are conjugate.

  long powerInSubgroup( const Word& w );
  // returns `the minimal power' or 0 if there are no powers of the
  // element `aWord' in H.

  int findIndex() ;
  // Returns the index of the subgroup or 0 if infinite.

  VectorOf<Word> findWhiteheadBasis() ;
  // Finds the subgroup of the free group authomorphic to this with
  // smallest sum of lengths of generators.
  // Returns a vector of generators.

  Bool isAFreeFactor() ;
  // Returns TRUE iff this subgroup is a free factor.

  Bool generatesTheFreeGroup() ;

  Word rightSchreierRepresentative(const Word& w);

  ///////////////////////////////////////////////////////
  //                                                   //
  //  Methods which deal with sets of group elements   //
  //                                                   //
  ///////////////////////////////////////////////////////
 
  // @rn Want these?
  // SetOf<Elt> setMultiply(const SetOf<Elt>& S1, const SetOf<Elt>& S2) const;
  // SetOf<Elt> setMultiply(const Elt& e, const SetOf<Elt>& S) const;
  // SetOf<Elt> setMultiply(const SetOf<Elt>& S, const Elt& e) const;
  // SetOf<Elt> conjugateBy(const SetOf<Elt>& S1, const SetOf<Elt>& S2) const;
  // SetOf<Elt> conjugateBy(const Elt& e, const SetOf<Elt>& S) const;
  // SetOf<Elt> conjugateBy(const SetOf<Elt>& S, const Elt& e) const;
  // void closeUnderInverses(SetOf<Elt>& S) const;
  // void closeUnderCyclicPermutations(SetOf<Word>& S) const;

  ///////////////////////////////////////////////////////
  //                                                   //
  //  I/O                                              //
  //                                                   //
  ///////////////////////////////////////////////////////
 
//  void printWord( ostream& ostr, const Word& w ) const ;
  // w is a word in the subgroup's generators.

//  int hash() const;

//  bool operator == ( const SGofFreeGroup& g) const;
   %addmethods {

	int __cmp__(const SGofFreeGroup& w) {
	// only makes sense for == and !=, not for > or <
		if ((*self)==w)
			return 0;
		return 1;
	}

	int __hash__() {
		return self->hash();
	}
	char* printWord(const Word& w ) const {
		strstream *s=new strstream();
		self->printWord(*s,w);
		(*s) << '\0' << flush;
		return s->str();
        }

        bool testConjugateInSubgroup(const Word& w ) {
            Word s;
            return self->conjugateInSubgroup(w,s);
        }

    }


 /*
  ///////////////////////////////////////////////////////
  //                                                   //
  //  Representation access methods                    //
  //                                                   //
  ///////////////////////////////////////////////////////

protected:


  // Shadow representation accessors to get representations of the
  // right type in the members of this class:

  const SGofFreeGroupRep* look( ) const {
	 return (const SGofFreeGroupRep*)GenericObject::look();
  }
  SGofFreeGroupRep* enhance( ) const {
	 return (SGofFreeGroupRep*)GenericObject::enhance();
  }
  SGofFreeGroupRep* change( ) {
	 return (SGofFreeGroupRep*)GenericObject::change();
  }

  // Special wrapping constructor to wrap new representations (returned
  // by eg. delegated methods) and for GenericObject initialisation by derived
  // classes:

  SGofFreeGroup( SGofFreeGroupRep* newrep ) : GenericObject(newrep) { }
*/
};




Word expressWordInSubgroupGenerators( const SGofFreeGroup& H, const Word& w);
// Returns the word `w' written in the given generators of the subgroup `H'.

