<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/magnus/back_end/Subgroup/include/Subgroup.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/magnus/back_end/Subgroup/include/Subgroup.h</h1><a href="Subgroup_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">// Copyright (C) 1994 The New York Group Theory Cooperative</font>
00002 <font class="comment">// See magnus/doc/COPYRIGHT for the full notice.</font>
00003 
00004 <font class="comment">// Contents: Definition of SubgroupRep and Subgroup classes.</font>
00005 <font class="comment">//</font>
00006 <font class="comment">// * provisional one-class implementation of the notion of subgroup</font>
00007 <font class="comment">//</font>
00008 <font class="comment">// Principal Authors: Stephane Collart, Roger Needham</font>
00009 <font class="comment">//</font>
00010 <font class="comment">// Status: Draft</font>
00011 <font class="comment">//</font>
00012 <font class="comment">// Description:</font>
00013 <font class="comment">//</font>
00014 <font class="comment">//   A subgroup stores a shared-reference `copy' of its parent group.</font>
00015 <font class="comment">//   Enhancements to the parent group are thus available to its</font>
00016 <font class="comment">//   subgroups. The subgroup is generated by (formal) words interpretable</font>
00017 <font class="comment">//   in the generators of the parent group.</font>
00018 <font class="comment">//</font>
00019 <font class="comment">// Caveats:</font>
00020 <font class="comment">//</font>
00021 <font class="comment">// * If adding data members which store information computed about the</font>
00022 <font class="comment">//   the subgroup, make sure that subgroup manipulators which modify the</font>
00023 <font class="comment">//   semantics of the subgroup (for instance addGenerator()) either</font>
00024 <font class="comment">//   recompute or erase any data which might become invalid.</font>
00025 <font class="comment">//</font>
00026 <font class="comment">// Restrictions:</font>
00027 <font class="comment">//</font>
00028 <font class="comment">// * The subgroup does not store names for its generators (generating</font>
00029 <font class="comment">//   words): as the subgroup is mutable, this would involve finicky work.</font>
00030 <font class="comment">//</font>
00031 <font class="comment">// Bugs:</font>
00032 <font class="comment">//</font>
00033 <font class="comment">// * Being stored as a set, the generators do not have a fixed controllable</font>
00034 <font class="comment">//   order when generators are added or deleted, making the meaning of</font>
00035 <font class="comment">//   of formal words in the subgroup generators vary unpredictably.</font>
00036 <font class="comment">//</font>
00037 <font class="comment">// Revision History:</font>
00038 <font class="comment">//</font>
00039 <font class="comment">// * First implemented: oct 94.</font>
00040 <font class="comment">//</font>
00041 <font class="comment">// Notes:</font>
00042 <font class="comment">//</font>
00043 <font class="comment">// * If it becomes necessary to initialise subgroups with unspecified parent</font>
00044 <font class="comment">//   groups, several alternatives are possible</font>
00045 <font class="comment">//   - Group can be given a default constructor</font>
00046 <font class="comment">//   - SubgroupRep can be made to derive from a representation</font>
00047 <font class="comment">//     `UnspecifiedSubgroupRep' not requiring a parent group</font>
00048 <font class="comment">//</font>
00049 <font class="comment">// Questions:</font>
00050 <font class="comment">//</font>
00051 <font class="comment">// * It might be better to store the subgroup generators as a vector, in</font>
00052 <font class="comment">//   order to have faster permanent direct access, for instance for</font>
00053 <font class="comment">//   interpreting subgroup elements in the parent group. This would</font>
00054 <font class="comment">//   make adjoining and removing generators less efficient. Another</font>
00055 <font class="comment">//   possibility is taking seperate representations.</font>
00056 <font class="comment">//</font>
00057 
00058 <font class="preprocessor">#ifndef _SUBGROUP_H_</font>
00059 <font class="preprocessor"></font><font class="preprocessor">#define _SUBGROUP_H_</font>
00060 <font class="preprocessor"></font>
00061 <font class="preprocessor">#include "<a class="code" href="FGGroupRep_h.html">FGGroupRep.h</a>"</font>
00062 <font class="preprocessor">#include "<a class="code" href="FGGroup_h.html">FGGroup.h</a>"</font>
00063 <font class="preprocessor">#include "<a class="code" href="FPGroup_h.html">FPGroup.h</a>"</font>
00064 <font class="preprocessor">#include "<a class="code" href="File_h.html">File.h</a>"</font>
00065 <font class="preprocessor">#include "<a class="code" href="CosetEnumerator_h.html">CosetEnumerator.h</a>"</font>
00066 
<a name="l00067"></a><a class="code" href="struct_SubgroupRep.html">00067</a> <font class="keyword">struct </font><a class="code" href="struct_SubgroupRep.html">SubgroupRep</a> : <a class="code" href="struct_FGGroupRep.html">FGGroupRep</a> {
00068 
00069   <font class="comment">// Constructors:</font>
00070 
<a name="l00071"></a><a class="code" href="struct_SubgroupRep.html#a0">00071</a>   <a class="code" href="struct_SubgroupRep.html#a0">SubgroupRep</a>( <font class="keyword">const</font> <a class="code" href="class_FGGroup.html">FGGroup</a>&amp; parent )
00072   : <a class="code" href="struct_FGGroupRep.html">FGGroupRep</a>(0),
00073          theParentGroup(parent)
00074   { }
00075 
<a name="l00076"></a><a class="code" href="struct_SubgroupRep.html#a1">00076</a>   <a class="code" href="struct_SubgroupRep.html#a0">SubgroupRep</a>( <font class="keyword">const</font> <a class="code" href="class_FGGroup.html">FGGroup</a>&amp; parent, <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gens )
00077   : <a class="code" href="struct_FGGroupRep.html">FGGroupRep</a>( gens.length() ),
00078          theParentGroup( parent ),
00079          theGenerators( gens )
00080   { }
00081 
00082   <a class="code" href="struct_SubgroupRep.html#a0">SubgroupRep</a>( <font class="keyword">const</font> <a class="code" href="class_FGGroup.html">FGGroup</a>&amp; parent, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; gens );
00083   <font class="comment">// @rn Can do without this when we have container class conversions.</font>
00084 
00085 
00086   <font class="comment">// Representation methods:</font>
00087 
<a name="l00088"></a><a class="code" href="struct_SubgroupRep.html#a3">00088</a>   <a class="code" href="struct_PureRep.html">PureRep</a>* <a class="code" href="struct_GenericRep.html#a1">clone</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <font class="keyword">new</font> <a class="code" href="struct_SubgroupRep.html#a0">SubgroupRep</a>(*<font class="keyword">this</font>); }
00089   <font class="comment">// overrides PureRep* FGGroupRep::clone();</font>
00090 
<a name="l00091"></a><a class="code" href="struct_SubgroupRep.html#p0">00091</a>   <font class="keyword">static</font> <font class="keyword">const</font> <a class="code" href="class_Type.html">Type</a> theSubgroupType;
00092 
<a name="l00093"></a><a class="code" href="struct_SubgroupRep.html#d0">00093</a>   <font class="keyword">static</font> <a class="code" href="class_Type.html">Type</a> <a class="code" href="struct_FGGroupRep.html#d0">type</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> theSubgroupType; }
00094 
<a name="l00095"></a><a class="code" href="struct_SubgroupRep.html#a4">00095</a>   <a class="code" href="class_Type.html">Type</a> <a class="code" href="struct_FGGroupRep.html#a2">actualType</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="struct_FGGroupRep.html#d0">type</a>(); }
00096   <font class="comment">// Overrides FGGroupRep::actualType( )</font>
00097 
00098 
00099   <font class="comment">// Operators:</font>
00100 
00101 <font class="keyword">private</font>:
00102 
00103   <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>&amp; <a class="code" href="struct_FGGroupRep.html#c0">operator = </a>( <font class="keyword">const</font> <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>&amp; );
00104   <font class="comment">// disable assignment</font>
00105 
00106 <font class="keyword">public</font>:
00107 
00108   <font class="comment">// Methods dealing with group structure:</font>
00109   <font class="comment">// @stc these are implemented provisionally in a trivial way</font>
00110  
<a name="l00111"></a><a class="code" href="struct_SubgroupRep.html#a5">00111</a>   <font class="keywordtype">int</font> <a class="code" href="struct_GroupRep.html#a3">order</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> -1; }
00112   <font class="comment">// overrides FGGroupRep::...</font>
00113 
<a name="l00114"></a><a class="code" href="struct_SubgroupRep.html#a6">00114</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_GroupRep.html#a4">isTrivial</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> DONTKNOW; }
00115   <font class="comment">// overrides FGGroupRep::...</font>
00116 
<a name="l00117"></a><a class="code" href="struct_SubgroupRep.html#a7">00117</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_GroupRep.html#a5">isFinite</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> DONTKNOW; }
00118   <font class="comment">// overrides FGGroupRep::...</font>
00119 
<a name="l00120"></a><a class="code" href="struct_SubgroupRep.html#a8">00120</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_GroupRep.html#a6">isInfinite</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> DONTKNOW; }
00121   <font class="comment">// overrides FGGroupRep::...</font>
00122 
<a name="l00123"></a><a class="code" href="struct_SubgroupRep.html#a9">00123</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_GroupRep.html#a7">isAbelian</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> DONTKNOW; } <font class="comment">//@rn can do</font>
00124   <font class="comment">// overrides FGGroupRep::...</font>
00125 
00126   <font class="comment">// Methods dealing with group elements:</font>
00127 
00128   <font class="comment">// Inherited from FGGroupRep:</font>
00129   <font class="comment">// Elt makeIdentity( ) const;</font>
00130 
00131   <font class="comment">// Inherited from FGGroupRep:</font>
00132   <font class="comment">// Bool isSyntacticIdentity(const Elt&amp;) const</font>
00133 
<a name="l00134"></a><a class="code" href="struct_SubgroupRep.html#a10">00134</a>   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_GroupRep.html#a11">areEqual</a>(<font class="keyword">const</font> <a class="code" href="class_Elt.html">Elt</a>&amp;, <font class="keyword">const</font> <a class="code" href="class_Elt.html">Elt</a>&amp;)<font class="keyword"> const </font>{ <font class="keywordflow">return</font> DONTKNOW; } <font class="comment">//@rn can do</font>
00135   <font class="comment">// overrides FGGroupRep::...</font>
00136   <font class="comment">// @stc provisional trivial implementation</font>
00137 
00138   <font class="comment">// Inherited from FGGroupRep:</font>
00139   <font class="comment">// Elt firstElt( ) const</font>
00140 
00141   <font class="comment">// Inherited from FGGroupRep:</font>
00142   <font class="comment">// Elt nextElt(const Elt&amp;) const</font>
00143   <font class="comment">// beware: this deals with formal words in the subgroup generators:</font>
00144   <font class="comment">// to get an element in the parent group, apply eval</font>
00145          
00146   <font class="comment">// Inherited from FGGroupRep:</font>
00147   <font class="comment">// Elt multiply(const Elt&amp;, const Elt&amp;) const</font>
00148   <font class="comment">// result is as actual type of args: if formal words in subgroup</font>
00149   <font class="comment">// generators, then such; if elt in parent group, then such</font>
00150   <font class="comment">// if mixed, then nonsense</font>
00151 
00152   <font class="comment">// Inherited from FGGroupRep:</font>
00153   <font class="comment">// Elt inverseOf(const Elt&amp;) const</font>
00154   <font class="comment">// @stc this should really override with appropriate algorithm</font>
00155          
00156   <font class="comment">// Inherited from FGGroupRep:</font>
00157   <font class="comment">// Elt raiseToPower(const Elt&amp;, int) const</font>
00158   <font class="comment">// @stc this should really override with appropriate algorithm</font>
00159 
00160   <font class="comment">// Inherited from FGGroupRep:</font>
00161   <font class="comment">// Elt conjugateBy(const Elt&amp;, const Elt&amp;) const</font>
00162   <font class="comment">// @stc this should really override with appropriate algorithm</font>
00163 
00164   <font class="comment">// Inherited from FGGroupRep:</font>
00165   <font class="comment">// Elt commutator(const Elt&amp;, const Elt&amp;) const</font>
00166   <font class="comment">// @stc this should really override with appropriate algorithm</font>
00167 
00168   <a class="code" href="class_Elt.html">Elt</a> <a class="code" href="struct_FGGroupRep.html#a10">eval</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w ) <font class="keyword">const</font>;
00169   <font class="comment">// overrides FGGroupRep::...</font>
00170  
00171   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FGGroupRep.html#a11">wordProblem</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w ) <font class="keyword">const</font>;
00172   <font class="comment">// overrides FGGroupRep::...</font>
00173  
00174   <a class="code" href="class_Trichotomy.html">Trichotomy</a> <a class="code" href="struct_FGGroupRep.html#a12">conjugacyProblem</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u, <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; v ) <font class="keyword">const</font>;
00175   <font class="comment">// overrides FGGroupRep::...</font>
00176 
00177   <a class="code" href="class_Word.html">Word</a> <a class="code" href="struct_SubgroupRep.html#a14">findRelator</a>( );
00178 
00179   Bool <a class="code" href="struct_SubgroupRep.html#a15">redundantRelator</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u);
00180   <font class="comment">// This tries as best it can to decide whether the given word is a</font>
00181   <font class="comment">// product of conjugates of words from relators.</font>
00182 
00183   <font class="comment">// I/O:</font>
00184  
<a name="l00185"></a><a class="code" href="struct_SubgroupRep.html#a16">00185</a>   <font class="keywordtype">void</font> <a class="code" href="struct_GroupRep.html#a19">printOn</a>(ostream&amp;)<font class="keyword"> const </font>{ }
00186   <font class="comment">// overrides FGGroupRep::...</font>
00187   <font class="comment">// @stc provisional</font>
00188 
<a name="l00189"></a><a class="code" href="struct_SubgroupRep.html#a17">00189</a>   <font class="keyword">virtual</font> <a class="code" href="struct_GroupRep.html">GroupRep</a>* <a class="code" href="struct_GroupRep.html#a20">readFrom</a>(istream&amp;, <a class="code" href="class_Chars.html">Chars</a>&amp;)<font class="keyword"> const </font>{ <font class="keywordflow">return</font> 0; }
00190   <font class="comment">// overrides FGGroupRep::...</font>
00191   <font class="comment">// @stc provisional: do not call...</font>
00192 
00193   <font class="comment">// Inherited from FGGroupRep:</font>
00194   <font class="comment">// virtual void printGenerator( ostream&amp; ostr, int n ) const;</font>
00195   <font class="comment">// virtual void printGenerators( ostream&amp; ostr ) const;</font>
00196   <font class="comment">// virtual void printWord( ostream&amp; ostr, const Word&amp; w ) const;</font>
00197 
00198 
00199   <font class="comment">// Data members:</font>
00200 
00201   <font class="comment">// Inherited from FGGroupRep:</font>
00202   <font class="comment">// int theOrder;</font>
00203   <font class="comment">// int theNumberOfGenerators;</font>
00204   <font class="comment">// VectorOf&lt;Chars&gt; theNamesOfGenerators;</font>
00205 
<a name="l00206"></a><a class="code" href="struct_SubgroupRep.html#m0">00206</a>   <a class="code" href="class_FGGroup.html">FGGroup</a> theParentGroup;
00207 
<a name="l00208"></a><a class="code" href="struct_SubgroupRep.html#m1">00208</a>   <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a> theGenerators;
00209 
00210   <font class="comment">// @rn Provisional members which support finding relators:</font>
00211 
<a name="l00212"></a><a class="code" href="struct_SubgroupRep.html#m2">00212</a>   <a class="code" href="class_Word.html">Word</a> lastWordTried;
00213   <font class="comment">// The last cyclically reduced word we checked for relatorness.</font>
00214   <font class="comment">// Start with the empty word.</font>
00215 
<a name="l00216"></a><a class="code" href="struct_SubgroupRep.html#m3">00216</a>   <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a> relators;  <font class="comment">// The relators we've found so far.</font>
00217 
00218 };
00219 
00220 
00221 <font class="comment">//------------------------- Subgroup ---------------------------//</font>
00222 
00223 
<a name="l00224"></a><a class="code" href="class_Subgroup.html">00224</a> <font class="keyword">class </font><a class="code" href="class_Subgroup.html">Subgroup</a> : <font class="keyword">public</font> <a class="code" href="class_FGGroup.html">FGGroup</a> {
00225 
00226 <font class="keyword">public</font>:
00227 <font class="comment"></font>
00228 <font class="comment">  ///////////////////////////////////////////////////////</font>
00229 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00230   <font class="comment">//  Constructors                                     //</font>
00231   <font class="comment">//                                                   //</font><font class="comment"></font>
00232 <font class="comment">  ///////////////////////////////////////////////////////</font>
00233 <font class="comment"></font>
00234   <font class="comment">// @stc at some point, this default construtor may be wanted (see notes)</font>
00235   <font class="comment">// Subgroup( ) : FGGroup( new SubgroupRep() ) { }</font>
00236   <font class="comment">// to initialise an unspecified subgroup</font>
00237 
<a name="l00238"></a><a class="code" href="class_Subgroup.html#a0">00238</a>   <a class="code" href="class_Subgroup.html#a0">Subgroup</a>( <font class="keyword">const</font> <a class="code" href="class_FGGroup.html">FGGroup</a>&amp; parent )
00239   : <a class="code" href="class_FGGroup.html">FGGroup</a>( new <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>( parent ) )
00240   { }
00241   <font class="comment">// to make the trivial subgroup</font>
00242 
<a name="l00243"></a><a class="code" href="class_Subgroup.html#a1">00243</a>   <a class="code" href="class_Subgroup.html#a0">Subgroup</a>( <font class="keyword">const</font> <a class="code" href="class_FGGroup.html">FGGroup</a>&amp; parent, <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; gens )
00244   : <a class="code" href="class_FGGroup.html">FGGroup</a>( new <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>(parent,gens) )
00245   { }
00246   <font class="comment">// to make a finitely generated subgroup with a vector of unnamed</font>
00247   <font class="comment">// generators</font>
00248 
<a name="l00249"></a><a class="code" href="class_Subgroup.html#a2">00249</a>   <a class="code" href="class_Subgroup.html#a0">Subgroup</a>( <font class="keyword">const</font> <a class="code" href="class_FGGroup.html">FGGroup</a>&amp; parent, <font class="keyword">const</font> <a class="code" href="class_SetOf.html">SetOf&lt;Word&gt;</a>&amp; gens )
00250   : <a class="code" href="class_FGGroup.html">FGGroup</a>( new <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>(parent,gens) )
00251   { }
00252   <font class="comment">// to make a finitely generated subgroup with a set of unnamed</font>
00253   <font class="comment">// generators</font>
00254 
00255 <font class="comment"></font>
00256 <font class="comment">  ///////////////////////////////////////////////////////</font>
00257 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00258   <font class="comment">//  Accessors                                        //</font>
00259   <font class="comment">//                                                   //</font><font class="comment"></font>
00260 <font class="comment">  ///////////////////////////////////////////////////////</font>
00261 <font class="comment"></font>
<a name="l00262"></a><a class="code" href="class_Subgroup.html#d0">00262</a>   <font class="keyword">static</font> <a class="code" href="class_Type.html">Type</a> <a class="code" href="class_FGGroup.html#d0">type</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="struct_FGGroupRep.html#d0">SubgroupRep::type</a>(); }
00263 
00264   <font class="comment">// Inherited from FGGroup:</font>
00265   <font class="comment">// Chars FGGroup::nameOfGenerator( int i ) const;</font>
00266   <font class="comment">// VectorOf&lt;Chars&gt; FGGroup::namesOfGenerators( ) const;</font>
00267 
<a name="l00268"></a><a class="code" href="class_Subgroup.html#a3">00268</a>   <font class="keyword">const</font> <a class="code" href="class_FGGroup.html">FGGroup</a>&amp; <a class="code" href="class_Subgroup.html#a3">parentGroup</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;theParentGroup; }
00269 
<a name="l00270"></a><a class="code" href="class_Subgroup.html#a4">00270</a>   <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; <a class="code" href="class_Subgroup.html#a4">generators</a>( )<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b0">look</a>()-&gt;theGenerators; }
00271 
<a name="l00272"></a><a class="code" href="class_Subgroup.html#a5">00272</a>   <font class="keywordtype">void</font> <a class="code" href="class_Subgroup.html#a5">setParentGroup</a>( <font class="keyword">const</font> <a class="code" href="class_Group.html">Group</a>&amp; g )<font class="keyword"> </font>{ <a class="code" href="class_DerivedObjectOf.html#b2">change</a>()-&gt;theParentGroup = g; }
00273 
<a name="l00274"></a><a class="code" href="class_Subgroup.html#a6">00274</a>   <font class="keywordtype">void</font> <a class="code" href="class_Subgroup.html#a6">setGenerators</a>( <font class="keyword">const</font> <a class="code" href="class_VectorOf.html">VectorOf&lt;Word&gt;</a>&amp; s )<font class="keyword"> </font>{ <a class="code" href="class_DerivedObjectOf.html#b2">change</a>()-&gt;theGenerators = s; }
00275 
00276 <font class="keyword">public</font>:
00277 <font class="comment"></font>
00278 <font class="comment">  ///////////////////////////////////////////////////////</font>
00279 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00280   <font class="comment">//  Subgroup manipulators                            //</font>
00281   <font class="comment">//                                                   //</font><font class="comment"></font>
00282 <font class="comment">  ///////////////////////////////////////////////////////</font>
00283 <font class="comment"></font>
00284   <font class="comment">// NB manipulators which modify the semantics of the subgroup must</font>
00285   <font class="comment">// modify all necessary stored data to maintain consistency</font>
00286 
00287   <a class="code" href="class_Subgroup.html">Subgroup</a>&amp; <a class="code" href="class_Subgroup.html#a7">addGenerator</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w );
00288 
00289   <a class="code" href="class_Subgroup.html">Subgroup</a>&amp; <a class="code" href="class_Subgroup.html#a8">deleteGenerator</a>( <font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; w );
00290 <font class="comment"></font>
00291 <font class="comment">  ///////////////////////////////////////////////////////</font>
00292 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00293   <font class="comment">//  Group structure methods                          //</font>
00294   <font class="comment">//                                                   //</font><font class="comment"></font>
00295 <font class="comment">  ///////////////////////////////////////////////////////</font>
00296 <font class="comment"></font> 
00297   <font class="comment">// Inherited from FGGroup:</font>
00298   <font class="comment">// int order( ) const;             // pseudo-virtual</font>
00299   <font class="comment">// Trichotomy isTrivial( ) const;  // pseudo-virtual</font>
00300   <font class="comment">// Trichotomy isFinite( ) const;   // pseudo-virtual</font>
00301   <font class="comment">// Trichotomy isInfinite( ) const; // pseudo-virtual</font>
00302   <font class="comment">// Trichotomy isAbelian( ) const;  // pseudo-virtual</font>
00303  <font class="comment"></font>
00304 <font class="comment">  ///////////////////////////////////////////////////////</font>
00305 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00306   <font class="comment">//  Methods which deal with group elements           //</font>
00307   <font class="comment">//                                                   //</font><font class="comment"></font>
00308 <font class="comment">  ///////////////////////////////////////////////////////</font>
00309 <font class="comment"></font>
00310   <font class="comment">// Inherited from FGGroup:</font>
00311   <font class="comment">// Elt makeIdentity( ) const;                               // pseudo-virtual</font>
00312   <font class="comment">// Bool isSyntacticIdentity(const Elt&amp; e) const;            // pseudo-virtual</font>
00313   <font class="comment">// Trichotomy areEqual(const Elt&amp; e1, const Elt&amp; e2) const; // pseudo-virtual</font>
00314   <font class="comment">// Elt firstElt( ) const;                                   // pseudo-virtual</font>
00315   <font class="comment">// Elt nextElt(const Elt&amp; e) const;                         // pseudo-virtual</font>
00316   <font class="comment">// Elt multiply(const Elt&amp; e1, const Elt&amp; e2) const;        // pseudo-virtual</font>
00317   <font class="comment">// Elt inverseOf(const Elt&amp; e) const;                       // pseudo-virtual</font>
00318   <font class="comment">// Elt raiseToPower(const Elt&amp; e, int n) const;             // pseudo-virtual</font>
00319   <font class="comment">// Elt conjugateBy(const Elt&amp; e1, const Elt&amp; e2) const;     // pseudo-virtual</font>
00320   <font class="comment">// Elt commutator(const Elt&amp; e1, const Elt&amp; e2) const;      // pseudo-virtual</font>
00321   <font class="comment">// Elt eval( const Word&amp; w ) const;                         // pseudo-virtual</font>
00322   <font class="comment">// Trichotomy wordProblem( const Word&amp; w ) const;           // pseudo-virtual</font>
00323   <font class="comment">// Trichotomy conjugacyProblem( const Word&amp; u, const Word&amp; v ) const;</font>
00324                                                               <font class="comment">// pseudo-virtual</font>
00325 
<a name="l00326"></a><a class="code" href="class_Subgroup.html#a9">00326</a>   <a class="code" href="class_Word.html">Word</a> <a class="code" href="class_Subgroup.html#a9">findRelator</a>( )<font class="keyword"> </font>{ <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b1">enhance</a>()-&gt;<a class="code" href="struct_SubgroupRep.html#a14">findRelator</a>(); }
00327   <font class="comment">// Attempts to find and return a relator for this group.</font>
00328   <font class="comment">// The words returned by successive calls will be distinct, but</font>
00329   <font class="comment">// they may be redundant as relators.</font>
00330   <font class="comment">// @rn We could use some means of querying whether this has any</font>
00331   <font class="comment">//     chance at all, e.g., is there at least a partial soln of the</font>
00332   <font class="comment">//     word problem for the parent group?</font>
00333 
<a name="l00334"></a><a class="code" href="class_Subgroup.html#a10">00334</a>   Bool <a class="code" href="class_Subgroup.html#a10">redundantRelator</a>(<font class="keyword">const</font> <a class="code" href="class_Word.html">Word</a>&amp; u)<font class="keyword"> </font>{
00335          <font class="keywordflow">return</font> <a class="code" href="class_DerivedObjectOf.html#b1">enhance</a>()-&gt;<a class="code" href="struct_SubgroupRep.html#a15">redundantRelator</a>(u);
00336   }
00337   <font class="comment"></font>
00338 <font class="comment">  ///////////////////////////////////////////////////////</font>
00339 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00340   <font class="comment">//  Methods which deal with sets of group elements   //</font>
00341   <font class="comment">//                                                   //</font><font class="comment"></font>
00342 <font class="comment">  ///////////////////////////////////////////////////////</font>
00343 <font class="comment"></font> 
00344   <font class="comment">// Inherited from FGGroup:</font>
00345   <font class="comment">// SetOf&lt;Elt&gt; setMultiply(const SetOf&lt;Elt&gt;&amp; S1, const SetOf&lt;Elt&gt;&amp; S2) const;</font>
00346   <font class="comment">// SetOf&lt;Elt&gt; setMultiply(const Elt&amp; e, const SetOf&lt;Elt&gt;&amp; S) const;</font>
00347   <font class="comment">// SetOf&lt;Elt&gt; setMultiply(const SetOf&lt;Elt&gt;&amp; S, const Elt&amp; e) const;</font>
00348   <font class="comment">// SetOf&lt;Elt&gt; conjugateBy(const SetOf&lt;Elt&gt;&amp; S1, const SetOf&lt;Elt&gt;&amp; S2) const;</font>
00349   <font class="comment">// SetOf&lt;Elt&gt; conjugateBy(const Elt&amp; e, const SetOf&lt;Elt&gt;&amp; S) const;</font>
00350   <font class="comment">// SetOf&lt;Elt&gt; conjugateBy(const SetOf&lt;Elt&gt;&amp; S, const Elt&amp; e) const;</font>
00351   <font class="comment">// void closeUnderInverses(SetOf&lt;Elt&gt;&amp; S) const;</font>
00352   <font class="comment">// void closeUnderCyclicPermutations(SetOf&lt;Word&gt;&amp; S) const;</font>
00353  <font class="comment"></font>
00354 <font class="comment">  ///////////////////////////////////////////////////////</font>
00355 <font class="comment"></font>  <font class="comment">//                                                   //</font>
00356   <font class="comment">//  Representation access methods                    //</font>
00357   <font class="comment">//                                                   //</font><font class="comment"></font>
00358 <font class="comment">  ///////////////////////////////////////////////////////</font>
00359 <font class="comment"></font> 
00360 <font class="keyword">private</font>:
00361 
00362   <font class="comment">// Shadow representation accessors to get representations of the</font>
00363   <font class="comment">// right type in the members of this class:</font>
00364 
<a name="l00365"></a><a class="code" href="class_Subgroup.html#c0">00365</a>   <font class="keyword">const</font> <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>* <a class="code" href="class_DerivedObjectOf.html#b0">look</a>( )<font class="keyword"> const </font>{
00366          <font class="keywordflow">return</font> (<font class="keyword">const</font> <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>*)<a class="code" href="class_ObjectOf.html#b0">GenericObject::look</a>();
00367   }
<a name="l00368"></a><a class="code" href="class_Subgroup.html#c1">00368</a>   <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>* <a class="code" href="class_DerivedObjectOf.html#b1">enhance</a>( )<font class="keyword"> const </font>{
00369          <font class="keywordflow">return</font> (<a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>*)<a class="code" href="class_ObjectOf.html#b1">GenericObject::enhance</a>();
00370   }
<a name="l00371"></a><a class="code" href="class_Subgroup.html#c2">00371</a>   <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>* <a class="code" href="class_DerivedObjectOf.html#b2">change</a>( )<font class="keyword"> </font>{
00372          <font class="keywordflow">return</font> (<a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>*)<a class="code" href="class_ObjectOf.html#b2">GenericObject::change</a>();
00373   }
00374 
00375   <font class="comment">// Special wrapping constructor to wrap new representations (returned</font>
00376   <font class="comment">// by eg. delegated methods) and for GenericObject initialisation by derived</font>
00377   <font class="comment">// classes:</font>
00378 
<a name="l00379"></a><a class="code" href="class_Subgroup.html#c3">00379</a>   <a class="code" href="class_Subgroup.html#a0">Subgroup</a>( <a class="code" href="struct_SubgroupRep.html">SubgroupRep</a>* newrep ) : <a class="code" href="class_FGGroup.html">FGGroup</a>(newrep) { }
00380 
00381 };
00382 
00383 <font class="preprocessor">#endif</font>
00384 <font class="preprocessor"></font>
00385 
00386 
00387 
00388 
00389 
00390 
</pre></div><hr><address><small>Generated at Tue Jun 19 09:49:43 2001 for Magnus Classes by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
